<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>장고쟁이</title>
    <link>http://djangojeng-e.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>장고쟁이의 Python, Django 공부 노트</description>
    <pubDate>Sat, 09 May 2020 04:57:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Writing your first Django app, part 7 - 4편</title>
      <link>http://djangojeng-e.github.io/2020/05/09/Writing-your-first-Django-app-part-7-4%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/09/Writing-your-first-Django-app-part-7-4%ED%8E%B8/</guid>
      <pubDate>Sat, 09 May 2020 02:44:01 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;admin-모양과-느낌-꾸미기&quot;&gt;&lt;a href=&quot;#admin-모양과-느낌-꾸미기&quot; class=&quot;headerlink&quot; title=&quot;admin 모양과 느낌 꾸미기&quot;&gt;&lt;/a&gt;admin 모양과 느낌 꾸미기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;확실히 django administration 을 어디믄 페이지 상단에 가지는것은 좋아보이지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;그저 따분한 타이틀 텍스트 같아 보여서 더더욱이 안좋아 보이고, 지루해 보입니다.&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;Django 의 템플릿 시스템을 사용하여 바꿀수 있습니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;Django admin 은 Django 에 의해서 동작하고, 어드민 인터페이스는 Django 의 자체 템플릿 시스템을 사용합니다.&lt;br&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="admin-모양과-느낌-꾸미기"><a href="#admin-모양과-느낌-꾸미기" class="headerlink" title="admin 모양과 느낌 꾸미기"></a>admin 모양과 느낌 꾸미기</h2><br><p>확실히 django administration 을 어디믄 페이지 상단에 가지는것은 좋아보이지 않습니다.</p><p><br>그저 따분한 타이틀 텍스트 같아 보여서 더더욱이 안좋아 보이고, 지루해 보입니다.</p><br><br><p>Django 의 템플릿 시스템을 사용하여 바꿀수 있습니다. </p><p><br>Django admin 은 Django 에 의해서 동작하고, 어드민 인터페이스는 Django 의 자체 템플릿 시스템을 사용합니다.<br><br></p><a id="more"></a><br><h2 id="프로젝트의-templates-꾸미기"><a href="#프로젝트의-templates-꾸미기" class="headerlink" title="프로젝트의 templates 꾸미기"></a>프로젝트의 templates 꾸미기</h2><p><br><br></p><p>프로젝트 폴더내에 templates 라는 폴더를 생성합니다 (manage.py 파일과 같은 위치에 생성합니다) </p><br><p>templates 폴더는 Django 가 접근할수 있는 파일 시스템 어디에 위치해 있어도 상관없습니다. </p><p><br>하지만,  project 폴더 내에 templates 폴더를 갖게 하는것은 관례적으로 따라하기 좋습니다. </p><br><br><blockquote><p>mysite/settings.py 파일을 열고, </p><p>TEMPLATES 세팅에 DIR 옵션을 추가해 줍니다. </p></blockquote><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">TEMPLATES = [</span></span><br><span class="line"><span class="xml">    &#123;</span></span><br><span class="line"><span class="xml">        'BACKEND': 'django.template.backends.django.DjangoTemplates',</span></span><br><span class="line"><span class="xml">        'DIRS': [os.path.join(BASE_DIR, 'templates')],</span></span><br><span class="line"><span class="xml">        'APP_DIRS': True,</span></span><br><span class="line"><span class="xml">        'OPTIONS': &#123;</span></span><br><span class="line"><span class="xml">            'context_processors': [</span></span><br><span class="line"><span class="xml">                'django.template.context_processors.debug',</span></span><br><span class="line"><span class="xml">                'django.template.context_processors.request',</span></span><br><span class="line"><span class="xml">                'django.contrib.auth.context_processors.auth',</span></span><br><span class="line"><span class="xml">                'django.contrib.messages.context_processors.messages',</span></span><br><span class="line"><span class="xml">            ],</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">]</span></span><br></pre></td></tr></table></figure><p><br><br></p><blockquote><p>DIRS 는 파일시스템 폴더들을 가진 리스트입니다. </p><p>Django 가 templates 를 읽을때 확인 합니다. </p></blockquote><br><br><blockquote><p>템플릿 정리하기 </p><p>static files 들과 비슷하게, </p><p>우리는 모든 템플릿들을 하나의 큰 템플릿 폴더안에 넣어둘수 있고, 완벽하게 작동할것입니다. </p><p>하지만, 특정 어플리케이션을 따르는 템플릿들은 </p><p>프로젝트의 tempaltes 폴더안에 넣기보다는 어플리케이션의 templates 폴더에 넣습니다. </p><p>(예, polls/templates)</p><p>resuable app 튜토리얼에서 이것에 대해 더 얘기해볼겁니다 </p></blockquote><br><br><p>생성된 templates 폴더 안에, admin 폴더를 생성합니다. <br>그리고, django/contrib/admin/templates 에서 admin/base_site.html 을 복사해서 붙여놓습니다. </p><p><br>아래 커맨드를 실행해서, django 소스 파일들이 어디있는지 찾아냅니다. </p><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python -c <span class="string">"import django; print(django.__path__)"</span></span><br><span class="line">(django-tutorial)  dhkang  ~/django_tutorial/mysite   master  python -c <span class="string">"import django; print(django.__path__)"</span></span><br><span class="line">[<span class="string">'/home/dhkang/.pyenv/versions/3.7.4/envs/django-tutorial/lib/python3.7/site-packages/django'</span>]</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p><br><br></p><p>해당 경로로 들어가서, base_site.html 파일을 cp 커멘드를 입력하여, mysite/templates 폴더 안에 카피해줍니다. </p><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> dhkang  ~/.pyenv/versions/3.7.4/envs/django-tutorial/lib/python3.7/site-packages/django/contrib/admin/templates/admin   master  </span><br><span class="line">cp base_site.html ~/django_tutorial/mysite/templates/</span><br></pre></td></tr></table></figure><br><br><h2 id="admin-base-site-html-수정하기"><a href="#admin-base-site-html-수정하기" class="headerlink" title="admin base_site.html 수정하기"></a>admin base_site.html 수정하기</h2><br><blockquote><p>mysite/templates/admin/base_site.html </p><p>파일을, 아래와 같이 수정해 줍니다. </p></blockquote><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "admin/base.html" %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="template-variable">&#123;&#123; title &#125;&#125;</span><span class="xml"> | </span><span class="template-variable">&#123;&#123; site_title|<span class="name">default</span>:_('Django site admin') &#125;&#125;</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> branding %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"site-name"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> 'admin:index' %&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>Polls Administration<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> nav-global %&#125;</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span></span><br></pre></td></tr></table></figure><br><p>이 방식을 사용해서 어떻게 템플릿들을 덮어쓸수 있는지 가르쳐줍니다. 실제 프로젝트에서는, django.contrib.admin.AdminSite.site_header 속성을 사용해서 이런 특수한 꾸미기를 더 쉽게 만들수 있습니다. </p><p><br><br></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> branding %&#125;</span><span class="xml"> 이나 </span><span class="template-variable">&#123;&#123; title &#125;&#125;</span><span class="xml"> 같은 템플릿 테그들이 이 템플릿 </span></span><br><span class="line"><span class="template-tag">&#123;% %&#125;</span><span class="xml"> 나 </span><span class="template-variable">&#123;&#123; &#125;&#125;</span><span class="xml"> 태그들은 django 언어들입니다. </span></span><br><span class="line"></span><br><span class="line"><span class="xml">Django admin/base_site.html 파일을 그릴때, </span></span><br><span class="line"><span class="xml">이 템플릿 언어들이 검토되어 마지막 HTML 페이지를 그려냅니다.</span></span><br><span class="line"></span><br><span class="line"><span class="xml">튜토리얼 part3 에서 이미 확인한 바 있습니다.</span></span><br></pre></td></tr></table></figure><br><br><p>Django 의 기본 어드민 템플릿 어떤것이든 덮어써서 사용할수 있습니다. </p><p><br>템플릿을 덮어쓸때에는, base_html 을 덮어쓴 방식과 같은 일을 수행하면 됩니다. <br></p><br><blockquote><p>admin 에 들어가서, </p><p>템플릿이 잘 수정되었는지 확인 합니다. </p><p>Polls Administration 이라고 어드민 페이지 상단에 잘 표시되는걸 확인할수 있습니다. </p></blockquote><br><img src="/2020/05/09/Writing-your-first-Django-app-part-7-4%ED%8E%B8/image1.png" class=""><br><h2 id="어플리케이션의-템플릿-꾸미기"><a href="#어플리케이션의-템플릿-꾸미기" class="headerlink" title="어플리케이션의 템플릿 꾸미기"></a>어플리케이션의 템플릿 꾸미기</h2><br><p>눈치빠른 독자들은, 물어볼것입니다. <br></p><p>만약, DIRS 가 기본값으로 비어 있으면, Django 는 어떻게 기본 admin templates 를 찾았을까요? </p><p><br>정답은, APP_DIRS 가 True 로 설정 되어 있었기 때문입니다. </p><p><br>Django 는 자동으로 각 어플리케이션 안에 있는 templates/ 서브 디렉토리를 찾고 폴백으로 사용합니다. <br></p><p>(django.contrib.admin 도 하나의 어플리케이션이란것을 잊지 않습니다) </p><br><p>poll 어플리케이션은 너무 복잡하지 않고, 사용자 정의 admin 템플릿들을 필요로 하지 않습니다. <br>하지만, 만약 앱이 더 복잡하게 자라나고 Django 의 기본 어드민 템플릿들을 어떤 기능들을 위해서 수정이 필요할때는,<br> 어플리케이션들의 템플릿들을 고쳐주는것이 프로젝트의 템플릿을 고쳐주는것보다 나을것입니다. </p><br><br><p>이 방식으로, polls application 을 새로운 프로젝트에 포함시킬수 있고, 사용자 정의 템플릿을 필요에 따라 찾을것입니다. </p><p><br><br></p><p>Django 가 어떻게 템플릿들을 찾는지에 대해서는, template loading documentation 문서를 참조합니다.  </p><p><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>Django 어드민 페이지의 템플릿을 수정해 보았습니다. <br></p><p>어드민 템플릿에서 기존 템플릿 파일을 프로젝트내에 templates/admin 폴더에 복사해서 붙여놓고. <br></p><p>파일을 수정하면 됩니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/09/Writing-your-first-Django-app-part-7-4%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part 7 - 3편</title>
      <link>http://djangojeng-e.github.io/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/</guid>
      <pubDate>Fri, 08 May 2020 06:59:45 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;어드민-변경메뉴-목록-꾸미기&quot;&gt;&lt;a href=&quot;#어드민-변경메뉴-목록-꾸미기&quot; class=&quot;headerlink&quot; title=&quot;어드민 변경메뉴 목록 꾸미기&quot;&gt;&lt;/a&gt;어드민 변경메뉴 목록 꾸미기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;현재 Question 어드민 페이지는 좋아 보입니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;change list 페이지를 변경해 보도록 합시다. change list 페이지는 시스템에 있는 모든 질문들을 출력합니다.&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;img src=&quot;/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/image1.png&quot; class=&quot;&quot;&gt;

&lt;br&gt;

&lt;p&gt;기본값으로, Django 는 각 객체의 str() 을 출력해 줍니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="어드민-변경메뉴-목록-꾸미기"><a href="#어드민-변경메뉴-목록-꾸미기" class="headerlink" title="어드민 변경메뉴 목록 꾸미기"></a>어드민 변경메뉴 목록 꾸미기</h2><br><p>현재 Question 어드민 페이지는 좋아 보입니다. </p><p><br>change list 페이지를 변경해 보도록 합시다. change list 페이지는 시스템에 있는 모든 질문들을 출력합니다.</p><br><br><img src="/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/image1.png" class=""><br><p>기본값으로, Django 는 각 객체의 str() 을 출력해 줍니다. </p><br><a id="more"></a><br>하지만, 때때로, 각각의 fields 를 출력하는게 더 도움될때가 있습니다. <br>어드민 옵션으로, list_display 를 사용해서 display 를 바꿔줄수 있습니다. <br><br><h2 id="list-display-어드민-옵션"><a href="#list-display-어드민-옵션" class="headerlink" title="list_display 어드민 옵션"></a>list_display 어드민 옵션</h2><br><br><blockquote><p>list_display 어드민 옵션은, </p><p>field 명들을 가진 튜플로 이루어져 있습니다. </p><p>polls/admin.py 파일을 열어서, list_display 를 써보도록 합시다. </p></blockquote><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    list_display = (<span class="string">'question_text'</span>, <span class="string">'pub_date'</span>)</span><br></pre></td></tr></table></figure><br><img src="/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/image2.png" class=""><br><blockquote><p>was_published_recently() 메서드도, </p><p>list_display 안에 추가해 봅니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    list_display = (<span class="string">'question_text'</span>. <span class="string">'pub_date'</span>, <span class="string">'was_published_recently'</span>)</span><br></pre></td></tr></table></figure><br><p>list_display 튜플안에 있는 필드대로, 테이블이 생성되고, 데이터가 출력 되는것을 확인 할수 있습니다. </p><br><img src="/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/image3.png" class=""><br><p>컬럼의 헤더를 클릭하면, 값을 기반으로 정렬이 가능합니다. </p><p><br>was_published_recently 헤더는 예외입니다, arbitrary method 를 정렬하는것은 지원하지 않기 때문입니다. <br></p><blockquote><p>polls/models.py 파일을 개선 시킬수 있습니다. </p><p>몇가지 속성들을 추가해 줍니다. </p></blockquote><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Question</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">was_published_recently</span><span class="params">(self)</span>:</span></span><br><span class="line">        now = timezone.now()</span><br><span class="line">        <span class="keyword">return</span> now - datetime.timedelta(days=<span class="number">1</span>) &lt;= self.pub_date &lt;= now</span><br><span class="line">    was_published_recently.admin_order_field = <span class="string">'pub_date'</span></span><br><span class="line">    was_published_recently.boolean = <span class="literal">True</span> </span><br><span class="line">    was_published_recently.short_description = <span class="string">'Published recently?'</span></span><br></pre></td></tr></table></figure><br><p>이 메서드 속성들에 대해서 더 알고 싶으면, list_display 문서를 참조 하면 됩니다. </p><br><h2 id="list-filter-옵션"><a href="#list-filter-옵션" class="headerlink" title="list_filter 옵션"></a>list_filter 옵션</h2><br><blockquote><p>polls/admin.py 파일을 다시 열고, </p><p>Question 의 변경 리스트 페이지의 개선사항을 추가합니다. </p><p>list_filter 를 사용해서, QuestionAdmin 에 추가해줍니다. </p></blockquote><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fieldsets = [</span><br><span class="line">        (<span class="string">'질문들'</span>, &#123;<span class="string">'fields'</span>: [<span class="string">'question_text'</span>]&#125;),</span><br><span class="line">        (<span class="string">'날짜정보'</span>, &#123;<span class="string">'fields'</span>: [<span class="string">'pub_date'</span>], <span class="string">'classes'</span>: [<span class="string">'collapse'</span>]&#125;),</span><br><span class="line">    ]</span><br><span class="line">    inlines = [ChoiceInline]</span><br><span class="line">    list_display = (<span class="string">'question_text'</span>, <span class="string">'pub_date'</span>, <span class="string">'was_published_recently'</span>)</span><br><span class="line">    list_filter = [<span class="string">'pub_date'</span>]</span><br></pre></td></tr></table></figure><br><p>어드민에서 Filter 사이드바를 추가해주어서, 사람들이 pub_date 로 필터를 할수 있게 해줍니다. </p><br><img src="/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/image4.png" class=""><br><p>출력된 필터 타입은, 필터를 하고 싶은 필드의 타입을 따라갑니다. </p><p><br>pub_date 는 DateTimeField 이기 때문에,<br>Django 에서는, filter option 으로, <br> “Any date”, “Today”, “Past 7 days”, “This month”, “This Year” 라고 적절하게 옵션을 써줍니다. <br><br></p><br><h2 id="검색기능-추가"><a href="#검색기능-추가" class="headerlink" title="검색기능 추가"></a>검색기능 추가</h2><p><br>모양새가 좋아졌습니다. 검색 기능도 가능하게 추가해 보겠습니다. </p><br><blockquote><p>polls/admin.py 파일을 열고, </p><p>아래 내용을 QuestionAdmin 클래스에 추가해 줍니다. </p><p>search_fields = [‘quesiton_text’]</p></blockquote><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fieldsets = [</span><br><span class="line">        (<span class="string">'질문들'</span>, &#123;<span class="string">'fields'</span>: [<span class="string">'question_text'</span>]&#125;),</span><br><span class="line">        (<span class="string">'날짜정보'</span>, &#123;<span class="string">'fiedls'</span>: [<span class="string">'pub_date'</span>], <span class="string">'classes'</span>: [<span class="string">'collapse'</span>]&#125;),</span><br><span class="line">    ]</span><br><span class="line">    inlines = [ChoiceInline]</span><br><span class="line">    list_display = (<span class="string">'quesiton_text'</span>, <span class="string">'pub_date'</span>, <span class="string">'was_published_recently'</span>)</span><br><span class="line">    list_filter = [<span class="string">'pub_date'</span>]</span><br><span class="line">    search_fields = [<span class="string">'question_text'</span>]</span><br></pre></td></tr></table></figure><br><br><p>화면에 검색바가 하나 추가되는것을 확인 할수 있습니다. </p><br><img src="/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/image5.png" class=""><br><p>검색 바에 내용을 입력하면, Django 는 question_text 필드를 조회할것 입니다. <br><br></p><p>사용하고 싶은 필드들을 입력할수 있습니다. <br>다만, 서치바 뒤에서 작업되는 방식은 LIKE 쿼리문이 동작하는 것과 동일한 방식으로 사용됩니다. <br>사용 가능한 필드 숫자를 제한하여 데이터베이스가 조회 작업을 하기 편하게 해줘야 합니다. </p><p><br><br></p><p>Change List, 즉 변경 리스트는 pagination 을 제공합니다.<br> 기본값은 100개의 아이템을 한페이지에 출력 하는것입니다. </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>어드민 파일 클래스에, 아래 내용들을 추가하면, </p><p>디스플레이가 바뀐다는것을 복습하고 넘어갑니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_display = (<span class="string">'question_text'</span>, <span class="string">'pub_date'</span>, <span class="string">'was_published_recently'</span>)</span><br><span class="line">list_filter = [<span class="string">'pub_date'</span>]</span><br><span class="line">search_fields = [<span class="string">'question_text'</span>]</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/08/Writing-your-first-Django-app-part-7-3%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part 7 - 2편</title>
      <link>http://djangojeng-e.github.io/2020/05/07/Writing-your-first-Django-app-part-7-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/07/Writing-your-first-Django-app-part-7-2%ED%8E%B8/</guid>
      <pubDate>Thu, 07 May 2020 10:41:56 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;관련된-객체-추가하기&quot;&gt;&lt;a href=&quot;#관련된-객체-추가하기&quot; class=&quot;headerlink&quot; title=&quot;관련된 객체 추가하기&quot;&gt;&lt;/a&gt;관련된 객체 추가하기&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;Question 은 admin 페이지에 등록이 되었습니다.&lt;/p&gt;
&lt;p&gt;하지만, Question 은 다수의 Choices 들을 가지고 있고, 이것은 어드민 페이지에 아직 표시가 되지 않습니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;아직은요,..&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;Question 이 가진 Choices 들을 어드민에 표시하기 위해서는 2가지 해결 방법이 존재합니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="관련된-객체-추가하기"><a href="#관련된-객체-추가하기" class="headerlink" title="관련된 객체 추가하기"></a>관련된 객체 추가하기</h2><br><br><p>Question 은 admin 페이지에 등록이 되었습니다.</p><p>하지만, Question 은 다수의 Choices 들을 가지고 있고, 이것은 어드민 페이지에 아직 표시가 되지 않습니다. </p><br><br><p>아직은요,..</p><br><br><blockquote><p>Question 이 가진 Choices 들을 어드민에 표시하기 위해서는 2가지 해결 방법이 존재합니다. </p></blockquote><br><a id="more"></a><br><br><h2 id="1-polls-admin-py에-Choice-등록"><a href="#1-polls-admin-py에-Choice-등록" class="headerlink" title="1. polls/admin.py에 Choice 등록"></a>1. polls/admin.py에 Choice 등록</h2><br><br><p>Choice 모델을 가져오고, admin.site.register(Choice)를 사용하여, </p><p><br>어드민에 등록해줍니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question, Choice </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fieldsets = [</span><br><span class="line">        (<span class="string">'질문내용'</span>,&#123;<span class="string">'fields'</span>: [<span class="string">'question_text'</span>]&#125;),</span><br><span class="line">        (<span class="string">'Date information'</span>, &#123;<span class="string">'fields'</span>: [<span class="string">'pub_date'</span>]&#125;),</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">admin.site.register(Question, QuestionAdmin)</span><br><span class="line">admin.site.register(Choice)</span><br></pre></td></tr></table></figure><br><img src="/2020/05/07/Writing-your-first-Django-app-part-7-2%ED%8E%B8/image1.png" class=""><p><br><br></p><img src="/2020/05/07/Writing-your-first-Django-app-part-7-2%ED%8E%B8/image2.png" class=""><p><br><br></p><img src="/2020/05/07/Writing-your-first-Django-app-part-7-2%ED%8E%B8/image3.png" class=""><p><br><br></p><p>Django 어드민에서, Choice 가 사용 가능합니다. “Add choice” 양식은 위와 같이 보입니다. </p><p><br><br></p><blockquote><p>해당 양식에서, </p><p>Question 필드는 선택 박스로 데이베이스에 있는 모든 질문들을 가지고 있습니다. </p><p>DJango 는 ForeignKey 로 등록된것을 <code>&lt;select&gt;</code> 박스 안에 넣어둡니다. </p></blockquote><p><br><br></p><p>또한, Question 옆에 “Add Another” 링크는, 모든 ForeignKey 의 관계를 가진 객체는 이 버튼을 그냥 가지게 됩니다. “Add Another” 를 클릭하면, <br>“Add quesiton” 폼을 가진 팝업이 뜹니다. 이 팝업 윈도우에서 “Save” 버튼을 누르면, <br>Django 는 question을 동적으로 데이터베이스 저장합니다. </p><p>하지만, 이것은 Choice 객체를 추가하는데 있어서 효율적인 방법이 아닙니다.<br> 아마도, Question 객체를 생성할때 몇개의 Choices 들을 추가해주는것이 더욱 효율적인 방법일것 입니다. 한번 해봅시다. </p><p><br><br></p><h2 id="Question-등록-코드-수정"><a href="#Question-등록-코드-수정" class="headerlink" title="Question 등록 코드 수정"></a>Question 등록 코드 수정</h2><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChoiceInline</span><span class="params">(admin.StackedInline)</span>:</span></span><br><span class="line">    model = Choice</span><br><span class="line">    extra = <span class="number">3</span> </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fieldsets = [</span><br><span class="line">        (<span class="literal">None</span>,&#123;<span class="string">'fields'</span>: [<span class="string">'question_text'</span>]&#125;),</span><br><span class="line">        (<span class="string">'Date information'</span>, &#123;<span class="string">'fields'</span>: [<span class="string">'pub_date'</span>], <span class="string">'classes'</span>: [<span class="string">'collapse'</span>]&#125;),</span><br><span class="line">    ]</span><br><span class="line">    inlines = [ChoiceInline]</span><br><span class="line">    </span><br><span class="line">admin.site.register(Question, QuestionAdmin)</span><br></pre></td></tr></table></figure><br><br><p>Choice 객체가 Question 어드민 페이지에서도 수정될수 있게 만들었습니다. </p><p><br>기본값으로, 3개의 선택을 넣을수 있는 충분한 필드 공간들을 제공합니다, extra 로 명시된 필드 수입니다. </p><p><br><br></p><p>3개 이상의 Choice 도 등록할수 있습니다, “Add Another Choice” 버튼을 누르면, 3개 이상도 등록 가능합니다. </p><br><br><img src="/2020/05/07/Writing-your-first-Django-app-part-7-2%ED%8E%B8/image4.png" class=""><p><br><br></p><h2 id="TabularInline"><a href="#TabularInline" class="headerlink" title="TabularInline"></a>TabularInline</h2><br><blockquote><p>허나, 작은 문제점은, 화면에 자리를 너무 많이 차지한다는 점입니다. </p><p>이런 이유로, Django 는 Tabular 방식으로, </p><p>관련 객체를 inline 형식으로 출력할수 있습니다. </p><p>polls/admin.py 에서 ChoiceInline 이 TabularInline 을 상속받도록 수정합니다. </p></blockquote><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChoiceInline</span><span class="params">(admin.TabularInline)</span>:</span></span><br><span class="line">    model = Choice</span><br><span class="line">    extra = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><br><br></p><p>ChoiceInline 클래스가 StackedInline 대신에, TabularInline 을 상속 받음으로써, </p><p><br>조금 더 간소화된 테이블 기반 포맷으로 바뀌어 어드민에 출력됩니다.<br><br></p><img src="/2020/05/07/Writing-your-first-Django-app-part-7-2%ED%8E%B8/image5.png" class=""><p><br><br></p><p>추가로, Delete 컬럼이 생기고, <br></p><p>Add Another Choice 를 사용해서 추가된 이미 저장된 자료들을 지울수 있습니다. </p><p><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p><br><br></p><p>어드민에 객체를 등록할때 클래스 형태로 StackedInline 과 TabularInline 을 사용해 보았습니다.<br></p><p>아무리 봐도 다시 봐도 잘외워지지가 않습니다;;; 나중에 프로젝트 진행할때 다시 한번 써봐야 할것 같습니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/07/Writing-your-first-Django-app-part-7-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part 7 - 1편</title>
      <link>http://djangojeng-e.github.io/2020/05/07/Writing-your-first-Django-app-part-7-1%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/07/Writing-your-first-Django-app-part-7-1%ED%8E%B8/</guid>
      <pubDate>Thu, 07 May 2020 01:01:21 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Admin-form-고치기&quot;&gt;&lt;a href=&quot;#Admin-form-고치기&quot; class=&quot;headerlink&quot; title=&quot;Admin form 고치기&quot;&gt;&lt;/a&gt;Admin form 고치기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;Question 모델을 admin.site.register(Question) 을 사용해서 polls/admin.py 에 등록을 하면, &lt;/p&gt;
&lt;p&gt;&lt;br&gt;Django 는 기본 어드민 표시 양식을 만들수 있었습니다.  그러나, 때때로 우리는 관리자 양식이 조금 다르게 보이고 작동하길 원합니다.&lt;br&gt;&lt;/p&gt;
&lt;br&gt;

&lt;p&gt;관리자 페이지가 조금 다른 모습과 조금 다른 동작을 원한다면, &lt;/p&gt;
&lt;p&gt;&lt;br&gt;Django 에 객체를 등록할때, 이 옵션에 대해서 얘기해 주어야 합니다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Admin-form-고치기"><a href="#Admin-form-고치기" class="headerlink" title="Admin form 고치기"></a>Admin form 고치기</h2><br><p>Question 모델을 admin.site.register(Question) 을 사용해서 polls/admin.py 에 등록을 하면, </p><p><br>Django 는 기본 어드민 표시 양식을 만들수 있었습니다.  그러나, 때때로 우리는 관리자 양식이 조금 다르게 보이고 작동하길 원합니다.<br></p><br><p>관리자 페이지가 조금 다른 모습과 조금 다른 동작을 원한다면, </p><p><br>Django 에 객체를 등록할때, 이 옵션에 대해서 얘기해 주어야 합니다. </p><a id="more"></a><br><br><blockquote><p>polls/admin.py 파일에 </p><p>class QuestionAdmin 코드를 추가해 주고, </p><p>코드 순서를 아래와 같이 바꾸어 줍니다. </p></blockquote><br><br><h2 id="fields-사용하기"><a href="#fields-사용하기" class="headerlink" title="fields 사용하기"></a>fields 사용하기</h2><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">from django.contrib import admin </span></span><br><span class="line"><span class="xml">from .models import Question </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">class QuestionAdmin(admin.ModelAdmin):</span></span><br><span class="line"><span class="xml">    fields = ['pub_date', 'question_text']</span></span><br><span class="line"></span><br><span class="line"><span class="xml">admin.site.register(Question, QuestionAdmin)</span></span><br></pre></td></tr></table></figure><br><br><p>새로 등록된 QuestionAdmin 클래스를, admin.site.register 의 두번째 인자로 넣어줍니다.</p><p><br>이 특정 변경 사항은, Publication date” 가 “Question” 필드 전에 나오게 만듭니다. </p><br><br><img src="/2020/05/07/Writing-your-first-Django-app-part-7-1%ED%8E%B8/image1.png" class=""> <br><p>두개의 필드밖에 없는 앱이라서 별로 특별해 보이지 않을지 모르지만, </p><p><br>필드가 많은때에는, 사용성 측면에서 직관적인 순서가 중요할수 있습니다.</p><br><br><h2 id="fieldsets-사용하기"><a href="#fieldsets-사용하기" class="headerlink" title="fieldsets 사용하기"></a>fieldsets 사용하기</h2><br><br><blockquote><p>polls/admin.py 파일에서, </p><p>fieldsets 를 사용해서, form 을 나눕니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fieldsets = [</span><br><span class="line">        (<span class="string">'질문내용'</span>, &#123;<span class="string">'fields'</span>: [<span class="string">'question_text'</span>]&#125;),</span><br><span class="line">        (<span class="string">'Date information'</span>, &#123;<span class="string">'fields'</span>: [<span class="string">'pub_date'</span>]&#125;),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><br><p>fieldsets 안에 있는 각 튜플들의 첫번째 요소들은 fieldset 의 제목들입니다. </p><p><br>polls/admin.py 파일을 위와 같이 고쳐놓고, <br>서버를 실행한다음, 어드민에 접속하면, 아래와 같은 화면을 볼수 있습니다.<br><br></p><img src="/2020/05/07/Writing-your-first-Django-app-part-7-1%ED%8E%B8/image2.png" class=""><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>간단하게 admin 을 커스터마이즈 해보았습니다. </p><p>다음 포스팅에서는, 관계된 객체를 어드민에 추가하는것에 대해 둘러봅니다. </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/07/Writing-your-first-Django-app-part-7-1%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part 6 - 2편</title>
      <link>http://djangojeng-e.github.io/2020/05/06/Writing-your-first-Django-app-part-6-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/06/Writing-your-first-Django-app-part-6-2%ED%8E%B8/</guid>
      <pubDate>Wed, 06 May 2020 05:18:03 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Background-image-추가하기&quot;&gt;&lt;a href=&quot;#Background-image-추가하기&quot; class=&quot;headerlink&quot; title=&quot;Background-image 추가하기&quot;&gt;&lt;/a&gt;Background-image 추가하기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;다음은, 배경 이미지를 추가해 보는것입니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;polls/static/polls/ 폴더 아래에 서브 폴더로 images 라는 폴더를 생성합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;이 폴더 안에 background.jpg 라는 이미지를 저장 했습니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;polls/static/polls/background.jpg 를 저장 하였으면, &lt;/p&gt;
&lt;p&gt;polls/static/polls/style.css 에 아래 내용을 추가해서, 배경 이미지가 나오게 합니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Background-image-추가하기"><a href="#Background-image-추가하기" class="headerlink" title="Background-image 추가하기"></a>Background-image 추가하기</h2><br><p>다음은, 배경 이미지를 추가해 보는것입니다. </p><p><br>polls/static/polls/ 폴더 아래에 서브 폴더로 images 라는 폴더를 생성합니다. </p><br><p>이 폴더 안에 background.jpg 라는 이미지를 저장 했습니다. </p><br><blockquote><p>polls/static/polls/background.jpg 를 저장 하였으면, </p><p>polls/static/polls/style.css 에 아래 내용을 추가해서, 배경 이미지가 나오게 합니다. </p></blockquote><br><a id="more"></a><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: white <span class="built_in">url</span>(<span class="string">"images/background.jpg"</span>) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><blockquote><p>위 내용대로, 파일을 잘 정리해 두었으면, </p><p>브라우저에서 <a href="http://localhost:8000/polls/" target="_blank" rel="noopener">http://localhost:8000/polls/</a> 로 접속해서 확인해 봅니다. </p></blockquote><br><img src="/2020/05/06/Writing-your-first-Django-app-part-6-2%ED%8E%B8/image1.png" class=""><br><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">경고사항! </span></span><br><span class="line"><span class="xml">Django 에서 생성된 페이지가 아니라면, </span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">static</span></span> %&#125;</span><span class="xml"> 이라는 템플릿 테그를 사용할수 없습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="xml">그리고, 항상 정적파일들을 연결할때에는, 상대 경로로 지정해 주어야 합니다.</span></span><br></pre></td></tr></table></figure><br><br><p>이것은 아주 기본적인 것만 다룬것이고, 프레임워크에 포함된 세부 사항들은, </p><p><br>the static files howto 그리고 the staticfiles reference, Deploying static files 문서들을 참고하여,</p><p><br>실제 정적 파일들을 사용하는 법을 알수 있습니다. </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><br><p>정적파일들과 친숙해졌으면, 튜토리얼의 Part 7 으로 넘어갑니다.</p><p><br>Part 7 에서는, Django 에서 자동으로 생성되는 관리자 사이트를 맞춤화 하는것에 대해 배웁니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/06/Writing-your-first-Django-app-part-6-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part 6 - 1편</title>
      <link>http://djangojeng-e.github.io/2020/05/06/Writing-your-first-Django-app-part-6-1%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/06/Writing-your-first-Django-app-part-6-1%ED%8E%B8/</guid>
      <pubDate>Tue, 05 May 2020 15:41:46 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Django에서-정적-파일-사용하기&quot;&gt;&lt;a href=&quot;#Django에서-정적-파일-사용하기&quot; class=&quot;headerlink&quot; title=&quot;Django에서 정적 파일 사용하기&quot;&gt;&lt;/a&gt;Django에서 정적 파일 사용하기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;이번 튜토리얼은 part 5 에서 이어서 진행 합니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;Web-poll 어플리케이션을 만들었고, 이제 stylesheet 과  이미지들을 추가해야 할때입니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;서버에서 생성되는 HTML 파일 외에 &lt;/p&gt;
&lt;p&gt;웹 어플리케이션은 보통 이미지나, JavaScript 혹은 CSS 같은 &lt;/p&gt;
&lt;p&gt;추가적인 파일을 가져야 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;이 파일들은 웹페이지를 완성할때 필요합니다. &lt;/p&gt;
&lt;p&gt;Django에서는, 이 파일들을 “static files” 라고 불릅니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Django에서-정적-파일-사용하기"><a href="#Django에서-정적-파일-사용하기" class="headerlink" title="Django에서 정적 파일 사용하기"></a>Django에서 정적 파일 사용하기</h2><br><p>이번 튜토리얼은 part 5 에서 이어서 진행 합니다. </p><p><br>Web-poll 어플리케이션을 만들었고, 이제 stylesheet 과  이미지들을 추가해야 할때입니다. </p><br><br><blockquote><p>서버에서 생성되는 HTML 파일 외에 </p><p>웹 어플리케이션은 보통 이미지나, JavaScript 혹은 CSS 같은 </p><p>추가적인 파일을 가져야 합니다. </p><br><p>이 파일들은 웹페이지를 완성할때 필요합니다. </p><p>Django에서는, 이 파일들을 “static files” 라고 불릅니다. </p></blockquote><br><a id="more"></a><br><p>작은 프로젝트에는, 이게 아주 큰 문제가 되지 않습니다. 왜냐하면, static files 들은 웹서버 어딘가에 두고 웹서버가 찾게 하면 되기 때문입니다. 하지만, 큰 프로젝트들 - 특히 다수의 앱으로 구성되고 다중의 static files 들을 처리해야 할때가 오면 좀 어려워 집니다. </p><br><blockquote><p>이것이 바로, django.contrib.staticfiles 가 하는 일입니다.</p><p>각 어플리케이션에서 정적파일들을 한곳에 모아서 놓아줍니다.</p><p>프로덕션 환경에서 쉽게 찾을수 있게 한곳에 모아서 관리 합니다. </p></blockquote><br><br><h2 id="App-의-느낌과-모양-정의하기"><a href="#App-의-느낌과-모양-정의하기" class="headerlink" title="App 의 느낌과 모양 정의하기"></a>App 의 느낌과 모양 정의하기</h2><br><br><p>첫번째로, polls 폴더안에, static 폴더를 만듭니다. Django 는 정적파일들을 이 폴더에서 찾게 됩니다. </p><p><br>Django 가 템플릿들을 polls/templates/ 폴더에서 찾는 방식과 비슷하게 이루어 집니다. </p><p><br>Django 의 STATICFILES_FINDERS 세팅은 검색자의 리스트들을 포함하고 있습니다. Finders 즉 검색자들은 여러 곳에서 static files 들을 찾습니다. </p><br><br><p>기본값중 하나는, AppDirectoriesFinder 인데, </p><p><br>이것은, 각 INSTALLED_APPS 에 등록된 앱의 서브폴더인 ‘static’ 을 찾습니다. 위에 생성한 polls/static 같은 폴더를 의미 합니다. 장고의 관리자 페이지는 정적파일들을 찾기 위해, 위와 같은 구조의 폴더 구조를 사용합니다. </p><br><br><blockquote><p>polls/static/polls/style.css 파일을 생성해 줍니다. </p><p>AppDirectoriesFinder 가 polls/styles.css 같은 정적파일들을 찾을수 있게 </p><p>경로를 지정해 주는 것인데, </p><p>이 방식은 템플릿 경로를 설정해준 방식과 비슷합니다. </p></blockquote><br><br><h2 id="Static-file-namespacing"><a href="#Static-file-namespacing" class="headerlink" title="Static file namespacing"></a>Static file namespacing</h2><br><br><blockquote><p>Static file namespacing </p><p>템플릿과 비슷하게, 우리는 정적파일들을 바로 polls/static 에 넣을수 있었을 겁니다. </p><p>하지만, 이것은 좋은 생각이 아닙니다. Django 는 static 이름과 매치되는 첫번째 static 파일을 찾습니다. </p><br><p>만약, 같은 이름의 정적파일이 다른 앱에 존재하면, Django 는 이 정적파일들을 구분할수 없을겁니다. </p><br><p>따라서, polls/static/polls/style.css 와 같이, poll 앱이 사용될 정적파일들을 담아놓습니다.</p><p>우리는 장고에게 정확한 정적파일들을 가르키게 해야하고, 최선의 방법은 namespacing (이름공간)을 두어서 구분 하는것입니다. </p><br><p>따라서, 정적파일들을 어플리케이션을 위한 폴더명 안에 넣어줍니다. </p></blockquote><br><br><p>polls/static/polls/style.css 파일을 생성해 주고, 아래 내용을 추가해 줍니다. </p><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="staticfiles-읽어오기"><a href="#staticfiles-읽어오기" class="headerlink" title="staticfiles 읽어오기"></a>staticfiles 읽어오기</h2><p><br><br></p><p>정적 파일을 생성하였으니, </p><p>index.html 파일에서 이 정적파일들을 불러오게끔 해줘야 합니다. polls/templates/polls/index.html 파일을 열고, </p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> static %&#125;</span><span class="xml"> 이라고 파일 상단에서 정적파일을 열어줍니다.</span></span><br><span class="line"><span class="xml">그리고나서, link 테그를 통해 해당 CSS 파일을 읽어줍니다. </span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> static %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">static</span></span> 'polls/style.css' %&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><br><br></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> static %&#125;</span><span class="xml"> 템플릿 테그는 정적파일들의 절대경로의 URL 을 생성해줍니다. </span></span><br><span class="line"><span class="xml">python manage.py runserver 를 실행 시켜서 정적파일이 잘 적용되었는지 확인 해봅니다.</span></span><br></pre></td></tr></table></figure><p><br><br></p><p>브라우저를 열어서  <a href="http://localhost:8000/polls/" target="_blank" rel="noopener">http://localhost:8000/polls/</a> 로 접속해보면, </p><p>Stylesheet 이 잘 읽어져서, 질문 링크들이 Django 스타일인 초록색으로 표시가 됩니다. </p><p><br><br></p><img src="/2020/05/06/Writing-your-first-Django-app-part-6-1%ED%8E%B8/image1.png" class=""><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p><br><br></p><p>Django 페이지에 정적파일을 적용해 보았습니다. </p><p><br>이 정적파일 경로 설정을 유의깊게 보고 있다가, 앱마다 사용되는 정적파일들을 사용합시다.</p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/06/Writing-your-first-Django-app-part-6-1%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part5 - 6편</title>
      <link>http://djangojeng-e.github.io/2020/05/05/Writing-your-first-Django-app-part5-6%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/05/Writing-your-first-Django-app-part5-6%ED%8E%B8/</guid>
      <pubDate>Tue, 05 May 2020 06:11:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;더많은-테스트가-좋습니다&quot;&gt;&lt;a href=&quot;#더많은-테스트가-좋습니다&quot; class=&quot;headerlink&quot; title=&quot;더많은 테스트가 좋습니다&quot;&gt;&lt;/a&gt;더많은 테스트가 좋습니다&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;우리가 작성한 테스트는 우리의 제어 능력을 벗어나 보일지 모릅니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;이대로 가다가는, 테스트에 있는 코드가 어플리케이션에 있는 코드보다 많아질것이고, &lt;/p&gt;
&lt;p&gt;&lt;br&gt;미심쩍은 반복만 늘어날것입니다. 기타 코드와 비교해서 우아할것 같아 보이지 않기도 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;상관 없습니다! 코드가 자라나게 냅둬도 되니다 ㅎㅎ&lt;/p&gt;
&lt;p&gt;&lt;br&gt;가장 좋은 방법은 테스트를 한번만 작성하고, 잊고 사는겁니다. 테스트는 프로그래밍 개발이 계속 되는동안 그 기능을 계속 수행합니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="더많은-테스트가-좋습니다"><a href="#더많은-테스트가-좋습니다" class="headerlink" title="더많은 테스트가 좋습니다"></a>더많은 테스트가 좋습니다</h2><br><br><p>우리가 작성한 테스트는 우리의 제어 능력을 벗어나 보일지 모릅니다. </p><p><br>이대로 가다가는, 테스트에 있는 코드가 어플리케이션에 있는 코드보다 많아질것이고, </p><p><br>미심쩍은 반복만 늘어날것입니다. 기타 코드와 비교해서 우아할것 같아 보이지 않기도 합니다. </p><br><br><p>상관 없습니다! 코드가 자라나게 냅둬도 되니다 ㅎㅎ</p><p><br>가장 좋은 방법은 테스트를 한번만 작성하고, 잊고 사는겁니다. 테스트는 프로그래밍 개발이 계속 되는동안 그 기능을 계속 수행합니다. </p><br><a id="more"></a><br><p>때때로, 테스트들은 업데이트 되어야 합니다. view 를 수정해서 Choices 를 가진 Questions 만 발행 된다고 가정해 봅시다. 이런 상황에서는, 이미 존재하는 많은 테스트들이 실패할것입니다. 따라서, 테스트들은 view  에 맞게 업데이트 되어야 합니다. </p><p><br><br></p><p>개발을 계속 하면서, 테스트가 불필요해지는 경우를 발견할수 있습니다. </p><p><br>테스트가 불필요해진다는것은 문제될게 없습니다. 테스트가 불필요해진다는것은 좋은 일입니다. </p><br><p>테스트들이 좋게 마련이 되어 있으면, 관리를 못하는 상황이 오지 않습니다. 아래는 테스트에 대한 좋은 원칙들 입니다.</p><br><ul><li>별도의 Testclass 를 각 모델 혹은 뷰에 가짐 </li><li>별도의 테스트 메서드를 각 테스트를 하고 싶은 조건에 가짐 </li><li>테스트 메서드 이름은 해당 함수를 묘사 </li></ul><br><br><h2 id="추가-테스트"><a href="#추가-테스트" class="headerlink" title="추가 테스트"></a>추가 테스트</h2><br><p>튜토리얼은 몇가지의 기본 테스팅을 소개합니다. </p><p><br>더 할수 있는것이 존재하고, 몇가지 매우 유용한 도구들도 존재합니다. <br><br><br></p><p>예를들어, 우리의 테스트가 모델의 내부 로직과, 정보를 발행하는 방식을 둘러보았고, </p><p><br>Selenium 같은 ‘in-browser’ 프레임워크를 사용해서 HTML  이 실제로 브라우저에서 그려지는지도 테스트 할수 있습니다. </p><br><p>이러한 툴들은, Django 코드의 동작을 확인하는것 뿐만 아니라, JavaScript 의 브라우저를 실행하여, 마치 사람이 동작시키는것처럼 테스트를 할수 있습니다. Django 는 Selenium 같은 툴과 연동을 도와주기 위해서, LiveServerTestCase  같은 모듈을 제공합니다.<br></p><br><p>만약 복잡한 어플리케이션을 가지고 있다면, 자동으로 각 커밋마다 테스트를 실행 시키고 싶을수 있습니다. </p><p><br>지속적인 연동의 목적을 가지고 말이죠, 따라서 품질관리가 스스로 혹은 적어도 부분적으로는 자동화가 됩니다. </p><p><br><br></p><p>테스트 되지 않은 응용 프로그램 부분을 확인 하는 좋은 방법은 코드 범위를 확인 하는것 입니다. </p><br><p>또한, 깨지기 쉬운 코드나 죽은 코드를 식별하는데에 도움이 됩니다. 코드를 테스트 할수 없는 경우 보통 코드를 리펙토링 하거나 제거 합니다. 적용 범위는 죽은 코드를 식별하는데에 도움이 됩니다. 자세한 내용은 coverage.py 와의 통합을 참조하면 됩니다. </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>테스트에 대한 토픽을 한번 읽어보았는데. </p><p>무슨 소리하는건지 하나도 모르겠습니다. <br></p><br><p>테스트를 진행하는것을 겪어본적이 없으니, 당췌 뭔소린지 알수가 없군요. </p><br><p>공부를 더 진행 해보면서, 체크 해봐야 되겠습니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/05/Writing-your-first-Django-app-part5-6%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part5 - 5편</title>
      <link>http://djangojeng-e.github.io/2020/05/04/Writing-your-first-Django-app-part5-5%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/04/Writing-your-first-Django-app-part5-5%ED%8E%B8/</guid>
      <pubDate>Mon, 04 May 2020 05:24:14 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;새로운-view-테스트하기&quot;&gt;&lt;a href=&quot;#새로운-view-테스트하기&quot; class=&quot;headerlink&quot; title=&quot;새로운 view 테스트하기&quot;&gt;&lt;/a&gt;새로운 view 테스트하기&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;이제 우리는 runserver 를 통해서 만족스러운 결과를 가질수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;브라우저로 사이트를 열어서 과거와 미래 날짜를 가진 Question 을 생성하고, 발행이 완료된 Question 만 리스트 되어야 합니다. shell 세션을 기반으로, tests.py 를 작성해 줍니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;첫번째로, polls/tests.py 에 reverse 를 추가해 줍니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; django.urls &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; reverse&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="새로운-view-테스트하기"><a href="#새로운-view-테스트하기" class="headerlink" title="새로운 view 테스트하기"></a>새로운 view 테스트하기</h2><br><br><p>이제 우리는 runserver 를 통해서 만족스러운 결과를 가질수 있습니다.</p><p><br>브라우저로 사이트를 열어서 과거와 미래 날짜를 가진 Question 을 생성하고, 발행이 완료된 Question 만 리스트 되어야 합니다. shell 세션을 기반으로, tests.py 를 작성해 줍니다. </p><br><br><p>첫번째로, polls/tests.py 에 reverse 를 추가해 줍니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br></pre></td></tr></table></figure><br><a id="more"></a><br><p>그 다음에, 질문들을 생성하기 위해서 단축 함수를 만들어주고,</p><p><br>새로운 클래스도 생성해 줍니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_question</span><span class="params">(question_text, days)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a question with the given 'question_text' and published the given number of 'days' offset to now (negative for question published in the past, </span></span><br><span class="line"><span class="string">    positive for questions that have yet to be published).</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    time = timezone.now() + datetime.timedelta(days=days)</span><br><span class="line">    <span class="keyword">return</span> Question.objects.create(question_text=question_text, pub_date=time)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionIndexViewTest</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_no_questions</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        If no questions exist, an appropriate message is displayed. </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        response = self.client.get(reverse(<span class="string">'polls:index'</span>))</span><br><span class="line">        self.assertEqual(response.status_code, <span class="number">200</span>)</span><br><span class="line">        self.assertContains(response, <span class="string">"No polls are available"</span>)</span><br><span class="line">        self.assertQuerysetEqual(response.context[<span class="string">'latest_question_list'</span>], [])</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_past_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Questions with a pub_date in the past are displayed on the index page </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        create_question(question_text=<span class="string">"Past question."</span>, days=<span class="number">30</span>)</span><br><span class="line">        response = self.client.get(reverse(<span class="string">'polls:index'</span>))</span><br><span class="line">        self.assertQuerysetEqual(</span><br><span class="line">        response.context[<span class="string">'latest_question_list'</span>],</span><br><span class="line">            [<span class="string">'&lt;Question: Past quesiton.&gt;'</span>]</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">test_future_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Questions with a pub_date in the future aren't displayed on</span></span><br><span class="line"><span class="string">        the index page.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        create_question(question_text=<span class="string">"Future question."</span>, days=<span class="number">30</span>)</span><br><span class="line">        response = self.client.get(reverse(<span class="string">'polls:index'</span>))</span><br><span class="line">        self.assertContains(response, <span class="string">"No polls are available."</span>)</span><br><span class="line">        self.assertQuerysetEqual(response.context[<span class="string">'latest_question_list'</span>], [])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_future_question_and_past_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Even if both past and future questions exist, only past questions</span></span><br><span class="line"><span class="string">        are displayed.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        create_question(question_text=<span class="string">"Past question."</span>, days=<span class="number">-30</span>)</span><br><span class="line">        create_question(question_text=<span class="string">"Future question."</span>, days=<span class="number">30</span>)</span><br><span class="line">        response = self.client.get(reverse(<span class="string">'polls:index'</span>))</span><br><span class="line">        self.assertQuerysetEqual(</span><br><span class="line">            response.context[<span class="string">'latest_question_list'</span>],</span><br><span class="line">            [<span class="string">'&lt;Question: Past question.&gt;'</span>]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two_past_questions</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        The questions index page may display multiple questions.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        create_question(question_text=<span class="string">"Past question 1."</span>, days=<span class="number">-30</span>)</span><br><span class="line">        create_question(question_text=<span class="string">"Past question 2."</span>, days=<span class="number">-5</span>)</span><br><span class="line">        response = self.client.get(reverse(<span class="string">'polls:index'</span>))</span><br><span class="line">        self.assertQuerysetEqual(</span><br><span class="line">            response.context[<span class="string">'latest_question_list'</span>],</span><br><span class="line">            [<span class="string">'&lt;Question: Past question 2.&gt;'</span>, <span class="string">'&lt;Question: Past question 1.&gt;'</span>]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><br><br><p>세부사항들을 잠시 체크하고 넘어갑니다. </p><br><p>첫번째로, quesiton 숏컷 함수인, create_question 은 질문 생성하는데에 반복되는 부분을 책임집니다. </p><br><p>test_no_questions 는 질문을 생성하지 않습니다. 하지만 “No polls are available” 이라는 메시지를 체크 하고, latest_question_list 가 비어있는것을 검증합니다. <br>django.test.TestCase 클래스는 추가적인 assertion 메써드들을 제공합니다.<br><br> 해당 예시에서는, assertContains() 그리고 assertQuerysetEqual() 을 사용합니다. </p><p><br><br></p><p>test_past_question 에서는, 질문을 생성하고 리스트에 표시되는지 확인 합니다. </p><br><p>test_future_question 에서는, pub_date 가 미래일인 질문을 생성합니다.<br> 데이터베이스는 각 테스트 메써드 마다 재설정 됩니다. <br><br>따라서, 첫번째 질문은 더이상 데이터베이스에 존재하지 않습니다. 그러므로, 인덱스는 아무 질문들도 가지고 있지 않아야 합니다. </p><p><br><br></p><p>추가적으로, 우리는 관리자 입력값과 사용자 경험 그리고 각 상태 와 각 변경사항, 예상된 결과들의 발행 같은 것들을 테스트를 통해 하나의 이야기를 만들어 가는겁니다. </p><br><p>python manage.py test polls 를 실행하면, 8개의 테스트가 진행되고 OK 가 됩니다. </p><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Creating <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">........</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 8 tests <span class="keyword">in</span> 0.031s</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line">Destroying <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br></pre></td></tr></table></figure><br><br><h3 id="DetailView-테스트-하기"><a href="#DetailView-테스트-하기" class="headerlink" title="DetailView 테스트 하기"></a>DetailView 테스트 하기</h3><br><p>우리가 또 해결해야 하는것은, 미래의 질문들이 인덱스에 표시가 되지 않는다 하더라도, </p><p><br>사용자들이 정확한 URL 을 알고 있거나, 추측할수 있다면, 사용자들은, 여전히 질문들에 접근할수 있습니다.  </p><p><br>따라서, DetailView 에 비슷한 제약을 추가해 줍니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        아직 발행되지 않은 질문들을 제외합니다.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> Question.objects.filter(pub_date__lte=timezone.now())</span><br></pre></td></tr></table></figure><br><br><p>그리고, 물론, 몇개의 테스트를 추가해 줄겁니다. pub_date 가 미래는 출력이 되지 않는 상황에서,<br></p><p>pub_date 가 과거값인 Question 이 출력될수 있는지, </p><p><br><br></p><p>polls/tests.py 파일을 아래와 같이 업데이트 해줍니다</p><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionDetailViewTests</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_future_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        The detail view of a question with a pub_date in the future</span></span><br><span class="line"><span class="string">        returns a 404 not found.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        future_question = create_question(question_text=<span class="string">'Future question.'</span>, days=<span class="number">5</span>)</span><br><span class="line">        url = reverse(<span class="string">'polls:detail'</span>, args=(future_question.id,))</span><br><span class="line">        response = self.client.get(url)</span><br><span class="line">        self.assertEqual(response.status_code, <span class="number">404</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_past_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        The detail view of a question with a pub_date in the past</span></span><br><span class="line"><span class="string">        displays the question's text.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        past_question = create_question(question_text=<span class="string">'Past Question.'</span>, days=<span class="number">-5</span>)</span><br><span class="line">        url = reverse(<span class="string">'polls:detail'</span>, args=(past_question.id,))</span><br><span class="line">        response = self.client.get(url)</span><br><span class="line">        self.assertContains(response, past_question.question_text)</span><br></pre></td></tr></table></figure><br><p>python manage.py test polls 를 실행하면,<br></p><p>아래와 같이 10가지의 테스트 케이스가 OK 됩니다.<br><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Creating <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">..........</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 10 tests <span class="keyword">in</span> 0.047s</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line">Destroying <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="더많은-테스트를-위한-아이디어"><a href="#더많은-테스트를-위한-아이디어" class="headerlink" title="더많은 테스트를 위한 아이디어"></a>더많은 테스트를 위한 아이디어</h2><p><br><br></p><p>비슷한 개념의 get_queryset 메써드를 ResultsView 에 추가해 주어야 하고 새로운 테스트 클래스를 생성 해주어야 합니다.. <br>방금 DetailView 를 위해 한 작업과 굉장히 비슷한 작업이 될것이고, <br>사실 반복적인 작업이 될것 입니다. </p><p><br><br></p><p>또한 다른 방식으로도 어플리케이션을 향상 시킬수 있습니다.<br> 예를 들어, Choices 가 없는 Questions 를 사이트에 발행 시키는것은 어리석은 짓입니다. <br>따라서, 우리의 뷰들은 이것에 대해 체크하고 Choice 가 없는 Questions 들을 제외할수 있습니다. <br><br>우리의 테스트들은 Choices 가 없는 Question 을 생성하고, 발행이 되지 않았는지 테스트 하고 비슷한 Question 인데  Choices 가 있는 것을 생성해서, 발행 되는지 테스트 합니다. </p><p><br><br></p><p>아마도, 로그인이 되어있는 관리자들은 발행이 취소된 Questions 도 볼수 있어야 합니다. 하지만, 일반 사이트 방문자는 볼수 없어야 하겠죠. 다시한번, 이것을 위해서 소프트웨어에 추가되어야 하는 그 어떤것이던지, </p><p><br><br></p><p>테스트와 함께 병행 되어야 합니다. 테스트를 먼저 작성하고 테스트를 통과하는 코드를 작성하던, </p><p>로직을 먼저 생각한다음에 테스트를 작성하여 증명하던지. </p><p><br><br></p><p>어떤 방식으로던, 테스트와 같이 병행되어야 합니다.  <br><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p><br><br></p><p>view 들을 테스트 해보았는데. </p><p>아직은 test 를 작성할 상황이 많지 않았어서 그런지.. 전반적인 순서라던지, 감이 오지 않네요. </p><p>작동은 완벽하게 되지만, 코드 동작 자체의 연계성에 대한 이해가 좀 부족한것 같습니다;;; </p><br><p>조금 더 공부 진행하면서 알아봐야 할것 같습니다. <br></p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/04/Writing-your-first-Django-app-part5-5%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part5 - 4편</title>
      <link>http://djangojeng-e.github.io/2020/05/03/Writing-your-first-Django-app-part5-4%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/03/Writing-your-first-Django-app-part5-4%ED%8E%B8/</guid>
      <pubDate>Sun, 03 May 2020 06:49:43 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;View-테스트-하기&quot;&gt;&lt;a href=&quot;#View-테스트-하기&quot; class=&quot;headerlink&quot; title=&quot;View 테스트 하기&quot;&gt;&lt;/a&gt;View 테스트 하기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;우리가 작성한 polls 어플리케이션은 구분을 잘 못합니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;이게 무슨 이야기냐면, polls app은 아무 질문이나 발행하고, pub_date 필드가 미래의 값인것도 발행 가능합니다. 이점은 개선 되어야 할점입니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;pub_date 를 미래의 날짜로 설정한다는것은, &lt;/p&gt;
&lt;p&gt;&lt;br&gt;Question 은 그때 발행은 되지만, 해당 pub_date 날짜가 올때까지 보여지지 않아야 합니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="View-테스트-하기"><a href="#View-테스트-하기" class="headerlink" title="View 테스트 하기"></a>View 테스트 하기</h2><br><p>우리가 작성한 polls 어플리케이션은 구분을 잘 못합니다. </p><p><br>이게 무슨 이야기냐면, polls app은 아무 질문이나 발행하고, pub_date 필드가 미래의 값인것도 발행 가능합니다. 이점은 개선 되어야 할점입니다. </p><p><br><br></p><p>pub_date 를 미래의 날짜로 설정한다는것은, </p><p><br>Question 은 그때 발행은 되지만, 해당 pub_date 날짜가 올때까지 보여지지 않아야 합니다. </p><br><a id="more"></a><br><h3 id="View-를-위한-테스트"><a href="#View-를-위한-테스트" class="headerlink" title="View 를 위한 테스트"></a>View 를 위한 테스트</h3><br><br><p>버그를 위에서 고쳤을때, 테스트를 처음 써주고, 해당 버그를 고치는 코드를 써주었습니다. 하지만, 이것은 테스트 기반 개발 방식의 예시입니다. 어떤 순서로 일을 하던 상관은 없습니다. </p><br><br><p>우리의 첫번째 테스트에서는, 코드의 내부 동작에 대해 조금 더 집중하였습니다. 이번 테스트에서는, 코드의 동작이 웹브라우저를 통한 사용자가 경험할 법한 것들에 대해서 확인 하고 싶습니다. </p><br><p>뭐든지 고치기 전에, 몇가지 도구들을 둘러보고 갑니다. </p><br><h3 id="Django-테스트-클라이언트"><a href="#Django-테스트-클라이언트" class="headerlink" title="Django 테스트 클라이언트"></a>Django 테스트 클라이언트</h3><br><p>장고는 테스트 클라이언트를 제공합니다. 뷰에서 사용자가 코드와 상호작용 하는것을 시뮬레이션 할수 있습니다.</p><p><br>tests.py 에서도 사용할수 있고, 심지어 shell 에서도 사용이 가능합니다. </p><p><br>shell 에서 먼저 시작해 보도록 합시다. shell 에서 tests.py 에서 불필요한것들을 수행해 보려 합니다. </p><br><br><blockquote><p>첫번째로, shell 에서 테스트 환경을 설정해 줘야 합니다 </p><p>튜토리얼에서는, shell 을 사용하나, 저는 shell_plus 를 사용했습니다. </p></blockquote><p><br><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell_plus</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from django.test.utils import setup_test_environment                                                                                                              </span><br><span class="line"></span><br><span class="line">In [2]: setup_test_environment()</span><br></pre></td></tr></table></figure><br><br><p><code>setup_test_environment()</code> 는 템플릿 렌더러를 설치합니다. template renderer 는 response.context 같은 리스폰스에 추가적인 속성들을 실험해 볼수 있게 해줍니다. 하지만, 이 메서드는 테스트 데이터베이스를 생성하지 않습니다. </p><p><br><br></p><p>따라서, 이것을 실행 하면, 이미 존재하는 데이터베이스를 기반으로 실행이 되고, 결과는 어떤 질문들을 생성했느냐에 따라서 살짝 달라질수 있습니다. settings.py 에 있는 TIME_ZONE 설정이 잘못 되어 있을 경우, 전혀 예상치 못한 결과가 나타날수 있습니다. </p><br><p>다음은, test 클라이언트 클래스를 가져 오는 겁니다. </p><p><br><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [3]: from django.test import Client                                                                                                                               </span><br><span class="line">In [4]: client = Client()</span><br></pre></td></tr></table></figure><br><br><p>여기까지 준비가 되었으면, 우리는 클라이언트에 어떠한 일을 수행해 달라고 할수 있습니다. </p><br><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [5]: # / 에서 response 를 가져옴                                                                                                                                       </span><br><span class="line"></span><br><span class="line">In [6]: response = Client.get('/')                                                                                                                                        </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-6-4f89fae61f34&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta">----&gt;</span><span class="bash"> 1 response = Client.get(<span class="string">'/'</span>)</span></span><br><span class="line"></span><br><span class="line">TypeError: get() missing 1 required positional argument: 'path'</span><br></pre></td></tr></table></figure><p><br><br></p><p><code>/</code>로 접속하면, 접속이 되질 않지만, <code>/polls/</code> 를 입력하면 접속이 됩니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [8]: response = client.get('/polls/')                                                                                                                             </span><br><span class="line">In [9]: response.status_code                                                                                                                                         </span><br><span class="line">Out[9]: 200</span><br><span class="line"><span class="meta">#</span><span class="bash"> reverse() 함수를 사용하여 하드코드된 URL 을 피할수 있습니다. </span></span><br><span class="line"></span><br><span class="line">In [11]: from django.urls import reverse                                           </span><br><span class="line"></span><br><span class="line">In [12]: response = client.get(reverse('polls:index'))                                                                                                               </span><br><span class="line">In [13]: response.status_code                                                                                                                                       </span><br><span class="line">Out[13]: 200</span><br><span class="line"></span><br><span class="line">In [14]: response.content                                                                                                                                            Out[14]: b'\n    &lt;ul&gt;\n    \n        &lt;li&gt;&lt;a href="/polls/specifics/1/"&gt;What&amp;#x27;s up?&lt;/a&gt;&lt;/li&gt;\n    \n    &lt;/ul&gt;\n'</span><br><span class="line"></span><br><span class="line">In [15]: response.context['latest_question_list']                                                                                                               </span><br><span class="line">Out[15]: &lt;QuerySet [&lt;Question: What's up?&gt;]&gt;</span><br></pre></td></tr></table></figure><br><p>shell 을 통해서 테스트 환경을 테스트 해보았습니다. </p><br><h3 id="View-향상-시키기"><a href="#View-향상-시키기" class="headerlink" title="View 향상 시키기"></a>View 향상 시키기</h3><br><br><p>polls 의 리스트는 발행되지 않은 polls 도 표시합니다. 이건 문제가 될수 있으니, 수정해주어야 합니다. </p><p><br>part4 에서 ListView 를 기반으로 하는 클래스 기반 뷰를 소개했었습니다. </p><p><br>polls/views.py 파일을 열어서, IndexView 안의 get_queryset() 메서드를 수정해줍니다. timezone.now() 와 날짜를 비교하여 체크하게 만들겁니다. 일단 polls/views.py 에 timezone 가져옵니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> generic</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexView</span><span class="params">(generic.ListView)</span>:</span></span><br><span class="line">    template_name = <span class="string">'polls/index.html'</span></span><br><span class="line">    context_object_name = <span class="string">'latest_question_list'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        가장 최근의 5개의 발행된 질문들을 반환합니다 </span></span><br><span class="line"><span class="string">        미래 날짜에 발행된 질문들은 반환되지 않습니다</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> Question.objects.filter(pub_date__lte=timezone.now()).order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><br><p>Question.objects.filter(pub_date__lte=timezone.now()) 는 pub_date 가 timezone.now 보다 작거나 같은, 즉 timezone.now 보다 이르거나 같은 시간대를 가진 QUestion 을 반환합니다. </p><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>너무 길어질것 같아서 포스팅을 나눕니다. 다음 포스팅에 이어 합니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/03/Writing-your-first-Django-app-part5-4%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part5 - 3편</title>
      <link>http://djangojeng-e.github.io/2020/05/02/Writing-your-first-Django-app-part5-3%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/02/Writing-your-first-Django-app-part5-3%ED%8E%B8/</guid>
      <pubDate>Sat, 02 May 2020 06:59:18 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;첫번째-테스트-작성하기&quot;&gt;&lt;a href=&quot;#첫번째-테스트-작성하기&quot; class=&quot;headerlink&quot; title=&quot;첫번째 테스트 작성하기&quot;&gt;&lt;/a&gt;첫번째 테스트 작성하기&lt;/h2&gt;&lt;br&gt;

&lt;h3 id=&quot;버그찾기&quot;&gt;&lt;a href=&quot;#버그찾기&quot; class=&quot;headerlink&quot; title=&quot;버그찾기&quot;&gt;&lt;/a&gt;버그찾기&lt;/h3&gt;&lt;br&gt;

&lt;p&gt;운좋게도, polls 어플리케이션에는 고쳐야할 작은 버그가 있습니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;Question.was_publishd_recently() 메서드는, Question 이 어제 이전에 발행되었거나, Question 의 pub_date 필드가 미래일일 경우에 True 를 반환합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;쉘을 통해성 버그를 확인하고 확실하게 찾아냅시다. shell 을 사용해서 날짜가 미래의 날짜로 지정된 질문의 메서드를 확인 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python manage.py shell_plus&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="첫번째-테스트-작성하기"><a href="#첫번째-테스트-작성하기" class="headerlink" title="첫번째 테스트 작성하기"></a>첫번째 테스트 작성하기</h2><br><h3 id="버그찾기"><a href="#버그찾기" class="headerlink" title="버그찾기"></a>버그찾기</h3><br><p>운좋게도, polls 어플리케이션에는 고쳐야할 작은 버그가 있습니다. </p><p><br>Question.was_publishd_recently() 메서드는, Question 이 어제 이전에 발행되었거나, Question 의 pub_date 필드가 미래일일 경우에 True 를 반환합니다. </p><br><p>쉘을 통해성 버그를 확인하고 확실하게 찾아냅시다. shell 을 사용해서 날짜가 미래의 날짜로 지정된 질문의 메서드를 확인 합니다. </p><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell_plus</span><br></pre></td></tr></table></figure><p><br><br></p><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import datetime                                                                                                                                                   </span><br><span class="line"></span><br><span class="line">In [2]: from django.utils import timezone                                                                                                                                 </span><br><span class="line"></span><br><span class="line">In [3]: from polls.models import Question                                                                                                                                 </span><br><span class="line"></span><br><span class="line">In [4]: # pub_date 이 30일 미래 날짜를 가진 Question 인스턴스 생성                                                                                                        </span><br><span class="line"></span><br><span class="line">In [5]: future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))                                                                                 </span><br><span class="line"></span><br><span class="line">In [6]: # 이게 최근에 발행 됬나요?                                                                                                                                        </span><br><span class="line"></span><br><span class="line">In [7]: future_question.was_published_recently()                                                                                                                          </span><br><span class="line">Out[7]: True</span><br><span class="line"></span><br><span class="line">In [8]: # 최근 발행된 질문이 아닌데도 True 가 표시됩니다. 버그 입니다.</span><br></pre></td></tr></table></figure><br><p>발행일짜가 30일 이후로 되어 있는데도, 최근인지 확인하는 메서드는 True 를 반환합니다. </p><p><br>이것은 명백하게 잘못되어 있는것입니다. <br></p><br><h2 id="버그를-노출시키는-테스트"><a href="#버그를-노출시키는-테스트" class="headerlink" title="버그를 노출시키는 테스트"></a>버그를 노출시키는 테스트</h2><br><p>방금 shell 에서 진행 한것은, 자동화 테스트가 문제점에 대해서 정확히 무엇을 할수 있는지 테스트 해본 겁니다. </p><p><br>자, 그럼 자동화 테스트로 전환을 해봅시다.<br></p><br><p>관례적으로 어플리케이션의 테스트는 어플리케이션의 tests.py 파일에 작성합니다. 테스트 시스템은 자동으로 테스트 코드들을 test 로 시작하는 파일에서 찾습니다. </p><br><blockquote><p>polls/tests.py  파일을 생성하고 </p><p>아래 코드를 작성해 줍니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase </span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question </span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your tests here </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionModelTests</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_was_published_recently_with_future_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        was_published_recently() 가 pub_date 가 미래 날짜로 지정되어 있는 질문들에 대해서   False 를 반환함</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        time = timezone.now() + datetime.timedelta(days=<span class="number">30</span>)</span><br><span class="line">        future_question = Question(pub_date=time)</span><br><span class="line">        self.assertIs(future_question.was_published_recently(), <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><br><br><p>여기에 우리는 django.test.TestCase 서브 클래스를 만들고, pub_date 가 미래 날짜인 Question 인스턴스를 만들어 줍니다. 그 후에, 값이 False 여야 하는 was_published_recently() 의 결과를 체크합니다. </p><br><br><h3 id="테스트-실행하기"><a href="#테스트-실행하기" class="headerlink" title="테스트 실행하기"></a>테스트 실행하기</h3><br><p>터미널에서 테스트를 실행 할수 있습니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py test polls</span><br></pre></td></tr></table></figure><br><br><p>실행해 보면, 아래와 같은 스크린을 볼수 있습니다. </p><br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Creating <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">F</span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/home/dhkang/django_tutorial/mysite/polls/tests.py"</span>, line 19, <span class="keyword">in</span> test_was_published_recently_with_future_question</span><br><span class="line">    self.assertIs(future_question.was_published_recently(), False)</span><br><span class="line">AssertionError: True is not False</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 <span class="built_in">test</span> <span class="keyword">in</span> 0.001s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br><span class="line">Destroying <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br></pre></td></tr></table></figure><br><br><p>무엇이 발생했냐면.. </p><br><ol><li><p>manage.py test polls 명령어를 실행하여, polls 앱 안에 test 를 찾았습니다 </p></li><li><p>django.test.TestCase 클래스의 서브 클래스를 찾았습니다 </p></li><li><p>테스트의 목적을 수행할 특수한 데이터베이스를 하나 생성했습니다 </p></li><li><p>test 로 시작하는 테스트의 메서드를 찾습니다 </p></li><li><p>test_was_published_recently_with_future_question 안에 Question 인스턴스를 하나 생성합니다. 이때, pub_date 는 30일 이후의 날짜로 지정해서 생성합니다 </p></li><li><p>assertIs() 함수를 사용해서, False 가 반환되어야 하는데, was_published_recently() 가 True 를 반환하는것을 발견합니다 </p></li></ol><br><p>테스트는 어떤 테스트가 실패했고, 어느 줄에서 실패가 발생했는지 알려줍니다. </p><br><h3 id="버그-수정하기"><a href="#버그-수정하기" class="headerlink" title="버그 수정하기"></a>버그 수정하기</h3><br><p>우리는 이미 문제점이 무엇인지 알고 있습니다. </p><br><blockquote><p>Question.was_published_recently() 는 </p><p>pub_date 가 미래의 날짜일 경우, </p><p>False 를 반환 해야 합니다. </p><p> polls/models.py 의 이 메서드를 수정해 줍니다. </p></blockquote><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">was_published_recently</span><span class="params">(self)</span>:</span></span><br><span class="line">    now = timezone.now()</span><br><span class="line">    <span class="keyword">return</span> now - datetime.timedelta(days=<span class="number">1</span>) &lt;= self.pub_date &lt;= now</span><br></pre></td></tr></table></figure><br><p>수정을 마쳤으면, 테스트를 다시 실행 해 줍니다. <code>python manage.py test polls</code></p><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python manage.py <span class="built_in">test</span> polls </span><br><span class="line">Creating <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">.</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 <span class="built_in">test</span> <span class="keyword">in</span> 0.001s</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line">Destroying <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br></pre></td></tr></table></figure><br><p>버그를 확인한 뒤에, 버그를 노출 시키는 테스트를 작성 하였고. </p><p><br>버그를 코드에서 수정하여, 테스트를 통과하게 만들었습니다.  </p><p><br>향후, 다른 많은 부분들이 우리의 어플리케이션에서 잘못될수 있습니다. 하지만, 우리는 이 버그를 다시 가지지 않을것입니다. 왜냐하면, 테스트를 실행 시키기만 하면, 바로 버그에 대한 경고를 받을 수 있기 때문입니다. <br></p><p>이 부분에 대해서 고쳐졌다고 볼수 있습니다. </p><br><br><h3 id="좀더-다양한-테스트"><a href="#좀더-다양한-테스트" class="headerlink" title="좀더 다양한 테스트"></a>좀더 다양한 테스트</h3><p><br><br></p><p>was_published_recently() 를 조금 더 고쳐보기로 합니다. 사실 이것은 긍정적인 의미를 가진 당황스러움 이 있습니다. </p><p><br>polls/tests.py 파일을 열고, 두개의 테스트를 같은 클래스에 추가해 줍니다<br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_was_published_recently_with_old_question</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    was_published_recently() returns False for question whose pub_date is older       than 1 day</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time = timezone.now() - datetime.timedelta(days=<span class="number">1</span>, seconds=<span class="number">1</span>)</span><br><span class="line">    old_question = Question(pub_date=time)</span><br><span class="line">    self.assertIs(old_question.was_published_recently(), <span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_was_published_recently_with_recent_question</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    was_published_recently() returns True for questions whose pub_date is within  the last day</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time = timezone.now() - datetime.timedelta(hours=<span class="number">23</span>, minutes=<span class="number">59</span>, seconds=<span class="number">59</span>)</span><br><span class="line">    recent_question = Quesiton(pub_date=time)</span><br><span class="line">    self.assertIs(recent_question.was_published_recently(), <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br><p>이제 Question.was_published_recently() 가 과거, 현재, 미래 날짜에 발행된 질문들에 대한 체크에 센스 있는 값을 반환 하는지 봅니다. </p><br><p><code>python manage.py test polls</code>를 실행해 봅니다. 3개의 테스트를 진행 했고, OK 가 표시되는것을 확인 할수 있습니다. </p><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Creating <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests <span class="keyword">in</span> 0.002s</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line">Destroying <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br></pre></td></tr></table></figure><p><br><br></p><p>다시 한번, 튜토리얼에서 만든 polls 어플리케이션은 매우 최소한의 단위를 가진 어플리케이션 입니다. </p><p><br>하지만, 향후에는 더 복잡함이 자라날것이고, 다른 코드들과 상호 작용을 함에 있어서, 더 복잡해 질것입니다.<br></p><p>우리는 우리가 작성한 코드가 예상대로 동작할것이라는 어느정도의 보장성을 가질수 있습니다. </p><p><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며."></a>마치며.</h2><br><p>테스트를 진행 할때, 기억해야 하는 포인트는,, </p><p><br><br></p><ol><li>앱안에 tests.py 파일 생성 </li><li>django.test.TestCase 클래스를 상속받는 클래스를 작성 </li><li>클래스 안에 test  로 시작하는 메서드를 작성 </li><li>해당 메서드 안에서, 테스트 할 인스턴스 생성 </li><li>assertIs 함수를 사용해서, 테스트가 원하는값을 반환하는지 확인 </li><li>버그 수정하기 </li></ol>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/02/Writing-your-first-Django-app-part5-3%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part5 - 2편</title>
      <link>http://djangojeng-e.github.io/2020/05/01/Writing-your-first-Django-app-part5-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/01/Writing-your-first-Django-app-part5-2%ED%8E%B8/</guid>
      <pubDate>Fri, 01 May 2020 09:23:40 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;기본테스트-전략&quot;&gt;&lt;a href=&quot;#기본테스트-전략&quot; class=&quot;headerlink&quot; title=&quot;기본테스트 전략&quot;&gt;&lt;/a&gt;기본테스트 전략&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;테스트 작성에 접근하는 방식은 많습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;어떤 프로그래머들은 “test-driven development” (테스트 기반 개발 방식) 원칙을 따릅니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;테스트 기반 개발 방식에서는, 개발자들이 실제 코드를 작성하기 전에 테스트를 먼저 작성합니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;이것은 직관적이지 않아 보일수 있습니다만, 어쨋든 대부분의 사람들이 하는일과 다를바가 별로 없습니다. 문제점들을 묘사하고, 문제점들을 풀기 위해서 코드를 작성합니다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="기본테스트-전략"><a href="#기본테스트-전략" class="headerlink" title="기본테스트 전략"></a>기본테스트 전략</h2><br><p>테스트 작성에 접근하는 방식은 많습니다. </p><br><p>어떤 프로그래머들은 “test-driven development” (테스트 기반 개발 방식) 원칙을 따릅니다. </p><p><br>테스트 기반 개발 방식에서는, 개발자들이 실제 코드를 작성하기 전에 테스트를 먼저 작성합니다. </p><br><br><p>이것은 직관적이지 않아 보일수 있습니다만, 어쨋든 대부분의 사람들이 하는일과 다를바가 별로 없습니다. 문제점들을 묘사하고, 문제점들을 풀기 위해서 코드를 작성합니다. </p><a id="more"></a><br><br><blockquote><p>테스트 기반 개발 방식은, 파이썬 테스트 케이스를 공식화 합니다. </p></blockquote><br><br><p>종종, 테스팅에 새로 입문하는 사람들은, 어떤 코드를 먼저 작성하고, 나중에 테스트가 있어야 한다고 결정합니다. </p><p><br>하지만, 그때는 테스트를 좀 더 일찍 작성하는것이 나았을거라 생각할겁니다. 하지만, 언제든 테스트 작성을 시작하는것은 늦지 않았습니다. </p><br><br><p>때때로, 테스트 작성을 시작해야하는 시점을 결정하기 어렵습니다. </p><p><br>만약, 몇천줄의 파이썬 코드를 이미 작성했다고 가정한다면, 어떤것을 테스트 해야할지 결정하는것이 쉽지 않을수 있습니다. 이런 상황에서는, 다음에 코드를 바꿀때에, 첫번째 테스트를 작성하는것이 좋습니다. </p><p><br>새로운 코드를 추가할때나 버그를 수정할때 말이죠. 바로 이것을 다음에 진행 해 볼 예정입니다. </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><br><p>테스트 코드 작성은 실제 코드를 작성하기 이전에 이미 작성하는것이 좋지만. <br></p><p>코드가 이미 몇천줄 작성이 되어 있더라도 언제든 테스트 코드를 작성하는것은 늦지 않습니다.</p><p><br><br></p><p>이미 작성된 코드가 너무 방대할 경우, 해당 코드에 새로운 기능을 추가하거나 버그를 고치는 코드를 작성할때 테스트 코드 작성을 시작해도 늦지 않습니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/01/Writing-your-first-Django-app-part5-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part5 - 1편</title>
      <link>http://djangojeng-e.github.io/2020/05/01/Writing-your-first-Django-app-part5-1%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/05/01/Writing-your-first-Django-app-part5-1%ED%8E%B8/</guid>
      <pubDate>Fri, 01 May 2020 01:51:57 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;자동화된-테스트-소개하기&quot;&gt;&lt;a href=&quot;#자동화된-테스트-소개하기&quot; class=&quot;headerlink&quot; title=&quot;자동화된 테스트 소개하기&quot;&gt;&lt;/a&gt;자동화된 테스트 소개하기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;튜토리얼 part4 에 이어서 진행합니다&lt;/p&gt;
&lt;p&gt;&lt;br&gt;튜토리얼을 통해서, 현재까지 Web-poll 어플리케이션을 만들었습니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;이번 part 5 에서는, 자동화된 테스트를 생성해 봅니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;자동화-테스트란&quot;&gt;&lt;a href=&quot;#자동화-테스트란&quot; class=&quot;headerlink&quot; title=&quot;자동화 테스트란?&quot;&gt;&lt;/a&gt;자동화 테스트란?&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;자동화 테스트는 코드의 동작을 체크하는 루틴 입니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="자동화된-테스트-소개하기"><a href="#자동화된-테스트-소개하기" class="headerlink" title="자동화된 테스트 소개하기"></a>자동화된 테스트 소개하기</h2><br><p>튜토리얼 part4 에 이어서 진행합니다</p><p><br>튜토리얼을 통해서, 현재까지 Web-poll 어플리케이션을 만들었습니다. </p><p><br>이번 part 5 에서는, 자동화된 테스트를 생성해 봅니다. </p><br><br><h2 id="자동화-테스트란"><a href="#자동화-테스트란" class="headerlink" title="자동화 테스트란?"></a>자동화 테스트란?</h2><br><br><p>자동화 테스트는 코드의 동작을 체크하는 루틴 입니다. </p><br><a id="more"></a> <br><p>테스팅은 모두 다른 단위로 행해집니다. 어떤 테스트는 아주 작은 세부 사항을 테스트를 합니다 (예, 특정 모델 메서드가 예상된 값을 반환하는지) </p><br><p>반면, 어떤 또다른 테스트는 전반적인 소프트웨어의 동작을 테스트 합니다 (예, 사용자 입력값의 순서가 요구하는 결과를 도출해 내는가?) </p><br><p>튜토리얼 part 2 에서 쉘을 이용하여 메서드의 동작과 어플리케이션 실행 그리고 데이터를 입력해서 어떻게 동작하는지 확인해 보았던것과 다르지 않습니다. </p><br><p>자동화 테스트가 다른점은, 시스템에서 자동으로 테스트를 실행해 볼수 있다는 점입니다. </p><p><br>테스트를 한번 생성하고, 앱에 변경 사항들을 만듭니다. 그리고, 생성한 테스트로 코드가 원래 의도했던대로 작동하는지에 대한 확인을. 시간과 귀찮음을 들여서 수동으로 테스트할 필요 없이, 자동으로 테스트를 해볼수 있습니다. </p><br><br><h2 id="왜-테스트가-필요한가"><a href="#왜-테스트가-필요한가" class="headerlink" title="왜 테스트가 필요한가?"></a>왜 테스트가 필요한가?</h2><br><br><p>어째서 테스트가 필요한가, 그리고 지금 왜 필요할까요? </p><p><br>지금까지 단지 python/django 를 배우는것만 해도 충분하다고 느낄수 있고, 다른것을 배워야 하는것이 버겁고 불필요하게 느껴질수 있습니다. 튜토리얼에서 작성한 투표앱은 현재 잘 동작하고. 자동화 테스트를 생성하는 괴로움이 잘 동작하고 있는 투표앱을 더 나은 앱으로 만들것 같지 않습니다. </p><br><p>투표앱이 우리가 작성할 마지막 Django 프로그램 이라면, 자동화 테스트를 생성하는 괴로움은 불필요할지 모릅니다.<br> 하지만, 투표앱이 우리가 작성할 마지막 단계의 Django 프로그래밍이 아니기 때문에, 지금이 배우기 가장 적절한 때입니다. </p><br><br><h3 id="테스트는-시간을-절약해-줍니다"><a href="#테스트는-시간을-절약해-줍니다" class="headerlink" title="테스트는 시간을 절약해 줍니다"></a>테스트는 시간을 절약해 줍니다</h3><br><p>지금까지는, ‘잘 작동하는것 같아 보이면’ 만족스러운 테스트 결과 였습니다. </p><p><br>하지만, 좀 더 복잡한 어플리케이션에서는, 각 앱의 구성요소들 끼리 더 복잡한 상호 작용들을 가지게 됩니다. </p><p><br>어떤 구성요소의 변경 사항은 예상치 못한 앱 동작의 결과를 초래할수 있습니다. 이것을 ‘잘 작동하는것 같아 보여’ 라고 테스트 한다는것은, 코드의 기능들을 20개의 다른 테스트 데이터를 가지고 실행 해 보아야 하는데, 어떤것도 잘못된것이 없다는것을 증명하기 위해서 사용하는 시간들은. 시간을 쓰는 좋은 방법이 아닙니다. </p><br><br><p>특히, 자동화 테스트가 테스트를 몇초 안에 끝낼수 있는 상황이면, 이것은 전적으로 맞는 이야기 입니다. 만약 어떤것이라도 잘못 되었을때, 테스트는 예상치 못한 동작들을 찾아내는데 도움이 됩니다. </p><br><p>때때로, 코드가 정상적으로 잘 작동할때, 흉측하고 재미없는 테스트들을 작성하는 상황에 직면하는것은 우리를 생산성 잇고 창의적인 프로그래밍 작업과 멀어지게 하는일이 될수도 있습니다. </p><br><p>하지만! 테스트를 작성하는것은, 테스트를 수동으로 진행 하는것에 몇시간을 쏟거나 새로 발견된 문제점들을 찾아내는것 보다는 좀 더 생산적입니다. </p><br><br><h3 id="테스트는-문제점들을-방지해-줍니다"><a href="#테스트는-문제점들을-방지해-줍니다" class="headerlink" title="테스트는 문제점들을 방지해 줍니다"></a>테스트는 문제점들을 방지해 줍니다</h3><br><br><p>테스트는 문제점들을 찾아내기만 하는게 아니라, 문제점들을 방지해 줍니다. 테스트가 개발의 안좋은 점 이라고 생각하는것은 잘못 된 생각입니다. </p><br><p>테스트 없이는, 어플리케이션의 목적과 의도된 코드의 동작들이 불투명 해질수 있습니다. </p><p><br>본인이 직접 작성한 코드일지라도, 때로 그 코드들을 가지고 정확히 무엇을 수행하는지 찾아내야 할때가 있습니다.<br><br></p><p>테스트는 이러한 점을 바꿉니다. 테스트는 코드를 내부에서부터 보고, 무언가가 잘못되었을때 어떤 부분이 잘못 되었는지 비추어 줍니다. 본인이 어떤것이 잘못 되었는지에 대해 깨닫지 못했을때에도 어떤게 잘못 되었는지에 대해 비추어 줄수 있습니다.<br><br></p><h3 id="테스트는-코드를-좀더-매력적으로-만들어-줍니다"><a href="#테스트는-코드를-좀더-매력적으로-만들어-줍니다" class="headerlink" title="테스트는 코드를 좀더 매력적으로 만들어 줍니다"></a>테스트는 코드를 좀더 매력적으로 만들어 줍니다</h3><p><br><br></p><p>우리는 매우 엄청난 소프트웨어를 만들었을지 모릅니다. 하지만 다수의 다른 개발자들은 아무리 좋은 소프트웨어라도 그것을 보는것을 거부할지도 모릅니다. 왜냐하면, 테스트 하기에 어려움이 있을지 모르기 때문입니다. 테스트가 없이는, 엄청난 소프트웨어라는것을 믿지 않을것입니다. Django 의 기본 개발자인 Jacob Kaplan-Moss 는, “테스트가 없는 코드는 디자인적으로 깨져 잇는 코드” 라고 했습니다. </p><br><p>다른 개발자들은 소프트웨어를 심각하게 고려 하기 이전에, 소프트웨어 내의 테스트들을 확인 하기를 원합니다. </p><br><br><h3 id="테스트는-팀원들이-함께-일하게-도와줍니다"><a href="#테스트는-팀원들이-함께-일하게-도와줍니다" class="headerlink" title="테스트는 팀원들이 함께 일하게 도와줍니다"></a>테스트는 팀원들이 함께 일하게 도와줍니다</h3><p><br><br></p><p>이전까지는, 한명의 개발자가 어플리케이션을 유지 보수하는 시점에서만 작성이 되었습니다<br></p><p>하지만, 복잡한 어플리케이션들은 팀 단위로 유지 보수가 됩니다.<br><br></p><p>테스트들은 동료들이 좋지 않은 방향으로 당신이 작성한 코드들을 고치는것을 방지해 줍니다. 그리고, 다른 사람들이 작성한 코드들도 알지도 못하면서 바꾸는것을 방지해 줍니다. </p><br><p>만약, Django 프로그래머로 살아가고 싶다면, 테스트 작성하는것을 잘 할줄 알아야 합니다.<br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>테스트 코드들을 작성하는것은 어렵고, 지루하고, 재미 없습니다. </p><br><p>하지만, 테스트 코드를 작성하고, 자동화 된 테스트를 진행하면서 소프트웨어의 완성도도 높이고, 코드의 퀄리티도 높일수 있습니다. <br></p><p>협업을 할때에도 많은 도움이 되고, 본인이 작성하는 코드에 대한 이해도도 더 높아집니다. <br></p><p>좋은 Django 개발자가 되기 위해서는, 자동화 테스트를 잘 알아야 합니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/05/01/Writing-your-first-Django-app-part5-1%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part4 - 2편</title>
      <link>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part4-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part4-2%ED%8E%B8/</guid>
      <pubDate>Thu, 30 Apr 2020 13:48:56 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Generic-뷰-사용하기&quot;&gt;&lt;a href=&quot;#Generic-뷰-사용하기&quot; class=&quot;headerlink&quot; title=&quot;Generic 뷰 사용하기&quot;&gt;&lt;/a&gt;Generic 뷰 사용하기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;적은 코드가 낫다 &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;Part3 에서 detail() 과 results() 뷰들은 매우 짧지만, 중복이 됩니다. &lt;/p&gt;
&lt;p&gt;index() 뷰도 비슷하고, 투표 리스트를 출력합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;이 뷰들은 공통적인 기본 웹개발 방법을 대표합니다. &lt;/p&gt;
&lt;br&gt;

&lt;ol&gt;
&lt;li&gt;URL 에서 전달된 파라미터에 따라서 데이터를 데이터베이스에서 가져오고 &lt;/li&gt;
&lt;li&gt;템플릿을 읽고 처리된 템플릿을 반환합니다 &lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;p&gt;이것은 매우 공통된 부분이기 때문에, 이것을 쉽게 다룰수 있는 generic view 시스템을 Django 가 제공합니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Generic-뷰-사용하기"><a href="#Generic-뷰-사용하기" class="headerlink" title="Generic 뷰 사용하기"></a>Generic 뷰 사용하기</h2><br><p>적은 코드가 낫다 </p><br><p>Part3 에서 detail() 과 results() 뷰들은 매우 짧지만, 중복이 됩니다. </p><p>index() 뷰도 비슷하고, 투표 리스트를 출력합니다. </p><br><p>이 뷰들은 공통적인 기본 웹개발 방법을 대표합니다. </p><br><ol><li>URL 에서 전달된 파라미터에 따라서 데이터를 데이터베이스에서 가져오고 </li><li>템플릿을 읽고 처리된 템플릿을 반환합니다 </li></ol><br><p>이것은 매우 공통된 부분이기 때문에, 이것을 쉽게 다룰수 있는 generic view 시스템을 Django 가 제공합니다. </p><br><a id="more"></a><br><h2 id="왜-GenericView-인가"><a href="#왜-GenericView-인가" class="headerlink" title="왜 GenericView 인가?"></a>왜 GenericView 인가?</h2><br><br><p>Generic view 는 웹개발에서 공통된 패턴들에 대해서 <br>더이상 파이썬 코드들을 쓸 필요가 없는 지점까지 추상화 합니다. </p><br><p>튜토리얼에서 작업하고 있었던 polls 앱을 generic view 를 사용하도록 전환 해 봅시다. <br></p><p>몇가지 코드를 지우고도 사용할수 있게 됩니다! 전환을 위해서 다음 스텝들을 거쳐 갑니다. </p><br><ol><li>URLConf 바꾸기 </li><li>불필요하고 오래된 코드 삭제하기 </li><li>Django 의 genericview 를 기반으로 하는 새로운 코드 쓰기 </li></ol><br><blockquote><p><strong>왜 코드를 다시 작업하는가?</strong> </p><p>보통 Django 앱을 작성할때에는, </p><p>generic view 를 사용하는것이 문제 해결에 도움이 되는지에 대해 먼저 파악 합니다.</p><p>코드를 중간에 리펙토링 하지 않고, 처음부터 generic view 를 사용합니다. </p><p>튜토리얼에서는, 단지 의도적으로 주요 컨셉에 집중하기 위해서 </p><p>어려운 방식으로 뷰를 작성 했었던것 뿐입니다. </p></blockquote><br><br><h2 id="Generic-view-로-전환"><a href="#Generic-view-로-전환" class="headerlink" title="Generic view 로 전환"></a>Generic view 로 전환</h2><br><h3 id="Views-수정하기"><a href="#Views-수정하기" class="headerlink" title="Views 수정하기"></a>Views 수정하기</h3><br><p>index, detail 그리고 results 뷰들의 오래된 코드들을 삭제하고, django 의 generic view 를 사용해 봅니다. generic view  를 사용하기 위해서, polls/views.py 파일을 열고, 아래와 같이 코드를 바꾸어 줍니다. </p><br><blockquote><p>polls/views.py 파일을 열고, 아래 뷰들을 수정해 줍니다. </p><p>index()</p><p>detail()</p><p>results()</p><p>vote() 는 수정해 주지 않습니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> generic</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexView</span><span class="params">(generic.ListView)</span>:</span></span><br><span class="line">    template_name = <span class="string">'polls/index.html'</span></span><br><span class="line">    context_object_name = <span class="string">'latest_question_list'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the last five published questions."""</span></span><br><span class="line">        <span class="keyword">return</span> Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">    model = Question</span><br><span class="line">    template_name = <span class="string">'polls/detail.html'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultsView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">    model = Question</span><br><span class="line">    template_name = <span class="string">'polls/results.html'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    ... <span class="comment"># same as above, no changes needed.</span></span><br></pre></td></tr></table></figure><br><br><p>여기서 우리는 두개의 generic view 를 사용합니다. ListView 와 DetailView 입니다. </p><br><blockquote><p>ListView 는 “모든 객체의 리스트를 출력하기” </p><p>DetailView 는 “디테일 페이지 출력하기” </p><p>이 두가지 아이디어를 요약 하여, genericview 가 만들어 졌습니다. </p></blockquote><br><br><ul><li>각 generic view 들은 어떤 모델을 사용해서 작동해야 할지 알아야 합니다. 이것은 model 속성들 사용에 의해서 주어집니다. </li><li>DetailView  는 URL 에서 켑쳐된 Primary Key 를 기대하고 있기 때문에, question_id 를 pk 로 바꿔줍니다. </li></ul><br><h2 id="DetailView"><a href="#DetailView" class="headerlink" title="DetailView"></a>DetailView</h2><br><p>﻿기본값으로 <code>DetailView</code> 는 <code>&lt;appname&gt;/&lt;model name&gt;_detail.html</code>템플릿 형태를 사용합니다. 튜토리얼 예시에서는 “polls/question_detail.html” 템플릿을 사용할것 입니다.</p><br><blockquote><p>﻿</p><p>하지만, 이번 튜토리얼에서는 template_name = “polls/detail.html” 을 둠으로써,</p><p>기존에 만든 템플릿을 사용하게 하였습니다.</p><p>template_name 속성은,</p><p>기본으로 정해진 템플릿명 대신에 django에게 특정 템플릿 이름을 사용하게 합니다.</p><p>﻿</p></blockquote><br><p>﻿template_name 속성을 results 리스트 뷰에도 명시하여, <br>기존에 사용했던 results view 와 detail view 가 화면에 출력 될때, 다르게 render 되게 만듭니다.<br> 이렇게 되면 두 뷰가 같은 DetailView 라고 해도, 다르게 표시가 됩니다.</p><p><br><br></p><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><br><p><br>﻿</p><p>비슷한 맥락으로, ListView 는 기본 템플릿으로 <code>&lt;app name&gt;/&lt;model name&gt;_list.html</code>을 사용합니다.<br></p><p>하지만, 우리는 tempalte_name = ‘polls/index.html’ 템플릿으로 명시를 해줌으로써,<br> ListView 가 기존에 있던 ‘polls/index.html’ 템플릿을 사용하도록 설정해줍니다.</p><p>﻿<br><br></p><p>﻿이전 튜토리얼 과정에서, 템플릿들은 question 과 lastest_question_list 컨텍스트 변수들을 가지고 있는 컨텍스트들을 전달 받았었습니다.<br> DetailView 는 question 변수가 자동으로 주어집니다. 이것은 모델명을 기반으로 가져오는것이라, <br>자동으로 DetailView 가 적절한 컨텍스트 변수명을 판단하여 가져옵니다.</p><br><blockquote><p>﻿</p><p>ListView 에 context 변수명 속성을 명시해 줍니다</p><p>context_object_name = latest_question_list</p><p>ListView는 기본적으로 자동으로 생성하는 컨텍스트 변수명은 question_list 입니다. 이 context 변수명을 명시를 해주기 위해서,</p><p>context_object_name 속성을 지정해 줍니다.</p><p>﻿</p></blockquote><br><p>context_object_name 을 지정해주고 싶지 않다면, 그냥 템플릿에서 context 변수명들을 바꾸어 주면 됩니다. </p><br><br><h2 id="URL-세팅해주기"><a href="#URL-세팅해주기" class="headerlink" title="URL 세팅해주기"></a>URL 세팅해주기</h2><p><br><br></p><p>views.py 에 있는 뷰들이 generic view  들인 클래스 뷰들로 바뀌었습니다. </p><p>vote  를 제외한 index, detail 그리고 results 뷰들이 바뀌었고. 이것들이 url 에서 호출되도록 변경해주어야 합니다. </p><br><br><p>﻿polls/urls.py 파일을 열어서, index, detail 그리고 results 뷰에 대한 URL설정을 고쳐줍니다.</p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">""</span>, views.IndexView.as_view(), name=<span class="string">'index'</span>),</span><br><span class="line">    path(<span class="string">'specifics/&lt;int:pk&gt;/'</span>, views.DetailView.as_view(), name=<span class="string">'detail'</span>), </span><br><span class="line">    <span class="comment"># &lt;int:question_id&gt; 를 &lt;int:pk&gt; 로 바꾸어줌 </span></span><br><span class="line">    path(<span class="string">'&lt;int:pk&gt;/results/'</span>, views.ResultsView.as_view(), name=<span class="string">'results'</span>),</span><br><span class="line">    <span class="comment"># &lt;int:question_id&gt; 를 &lt;int:pk&gt; 로 바꾸어줌 </span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br><br><blockquote><p>﻿</p><p>IndexView, DetailView 그리고 ResultsView 는</p><p>클래스 기반의 generic view 입니다.</p><p>이 뷰들을 URL에서 호출하려면,</p><p>view 뒤에 as_view() 함수를 붙여줘야 잘 작동합니다.</p><p>그리고, <a href="int:question_id">int:question_id</a> 를 <a href="int:pk">int:pk</a> 로 바꾸어줘야 작동합니다.</p><p>왜냐하면, DetailView 는 pk 를 인자로 받기 때문입니다.</p><p>﻿</p></blockquote><br><br><p>서버를 시작하고, 한번 시험해 봅니다. IndexView 호출 </p><br><img src="/2020/04/30/Writing-your-first-Django-app-part4-2%ED%8E%B8/image1.png" class=""> <br><p>DetailView 호출 </p><img src="/2020/04/30/Writing-your-first-Django-app-part4-2%ED%8E%B8/image2.png" class=""> <br><p>ResultsView 호출 </p><img src="/2020/04/30/Writing-your-first-Django-app-part4-2%ED%8E%B8/image3.png" class=""> <p><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p><br><br></p><p>사전 지식 없이 튜토리얼만 보고 공부 시작했다가 낭패 봤습니다. </p><p>겨우겨우 찾아서, 클래스 기반의 뷰들을 작성 해보았지만.. 알아내기 힘들었습니다. </p><br><p>폼과 generic view 와 친숙해 졌으면, part5 로 넘어갑니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part4-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part4 - 1편</title>
      <link>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part4-1%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part4-1%ED%8E%B8/</guid>
      <pubDate>Thu, 30 Apr 2020 09:32:05 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;최소한의-폼-작성하기&quot;&gt;&lt;a href=&quot;#최소한의-폼-작성하기&quot; class=&quot;headerlink&quot; title=&quot;최소한의 폼 작성하기&quot;&gt;&lt;/a&gt;최소한의 폼 작성하기&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;튜토리얼 part3 에 이어서, 계속 진행 합니다. Web-poll 어플리케이션을 이어서 진행하고. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;part4 에서는 form 프로세싱과 코드양을 줄이는데 집중합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;polls/detail.html 수정하기 &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;지난 포스팅까지 작성한 &lt;/p&gt;
&lt;p&gt;디테일 템플릿 polls/detail.html  파일에 &lt;/p&gt;
&lt;p&gt;html &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 요소를 추가하여 업데이트 해줍니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="최소한의-폼-작성하기"><a href="#최소한의-폼-작성하기" class="headerlink" title="최소한의 폼 작성하기"></a>최소한의 폼 작성하기</h2><br><br><p>튜토리얼 part3 에 이어서, 계속 진행 합니다. Web-poll 어플리케이션을 이어서 진행하고. </p><br><p>part4 에서는 form 프로세싱과 코드양을 줄이는데 집중합니다. </p><br><p>polls/detail.html 수정하기 </p><br><blockquote><p>지난 포스팅까지 작성한 </p><p>디테일 템플릿 polls/detail.html  파일에 </p><p>html <code>&lt;form&gt;</code> 요소를 추가하여 업데이트 해줍니다. </p></blockquote><br><a id="more"></a><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; question.question_text &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> error_message %&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span><span class="template-variable">&#123;&#123; error_message &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"</span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> 'polls:vote' question.id %&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">csrf_token</span></span> %&#125;</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> choice <span class="keyword">in</span> question.choice_set.all %&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choice"</span> <span class="attr">id</span>=<span class="string">"choice</span></span></span><span class="template-variable">&#123;&#123; forloop.counter &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">value</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; choice.id &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"choice</span></span></span><span class="template-variable">&#123;&#123; forloop.counter &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span><span class="template-variable">&#123;&#123; choice.choice_text &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Vote"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br><br><p>빠른 설명: </p><br><ul><li><p>위 템플릿은 각각의 Question 의 Choice 를 라디오 버튼으로 표시해 줍니다.  각 라디오 버튼의 Value 값은 질문에 붙어 있는 Choice 의 ID 가 됩니다. 각 라디오 버튼의 이름은 choice 가 됩니다. 이것이 의미하는 바는, 누군가가 하나의 라디오 버튼을 누르고 폼을 제출하면, 폼은 POST데이터 <code>choice=#</code> 을 전송합니다. <code>#</code>은 선택된 choice  의 ID 값입니다. </p></li><li><pre><code class="django"><span class="xml">form 에 action 은 <span class="comment">{% url 'polls:vote' question.id %}</span> 를 설정해줍니다. </span><span class="xml"><span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  form의 method  는 POST 로 설정해 줍니다. Form 의 method 를 POST 로 설정해 주는것은 중요합니다. 왜냐하면, 이 form 을 제출한다는것은 서버쪽의 데이터를 변경할것이기 때문입니다. 언제든 서버쪽 데이터를 바꾸고 싶으면, method&#x3D;&quot;POST&quot; 를 사용하면 됩니다. Django 에만 국한된 이야기가 아니라, 전반적으로 좋은 웹개발을 위한 연습이 됩니다. </span><br><span class="line"></span><br><span class="line">- forloop.counter 는 for 태그가 반복문의 몇번을 수행했는지 표시합니다</span><br><span class="line"></span><br><span class="line">- POST 폼을 생성하고 있기 때문에, 우리는 &#96;Cross Site Request Forgeries&#96;. 즉, 사이트간 요청 위조에 대해서 걱정해야 합니다. 감사하게도, 이것에 대해서 너무 걱정할 필요가 없습니다. Django 는 이것에 대한 아주 요용한 시스템을 갖추고 있습니다. </span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;django</span><br><span class="line">  내부 URL 을 타겟으로 하는 모든 POST 폼들은 &#123;% csrf_token %&#125; 템플릿 테그를 사용해 줍니다.</span><br></pre></td></tr></table></figure></span></span></code></pre></li></ul><br><br><h2 id="CSRF-사이트간-요청-위조"><a href="#CSRF-사이트간-요청-위조" class="headerlink" title="CSRF (사이트간 요청 위조)"></a>CSRF (사이트간 요청 위조)</h2><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">내부 URL 을 타겟으로 하는 모든 POST 폼들은 </span><span class="template-tag">&#123;% <span class="name"><span class="name">csrf_token</span></span> %&#125;</span><span class="xml"> 템플릿 테그를 사용해 줍니다.</span></span><br></pre></td></tr></table></figure><br><blockquote><p>Cross-site Request Forgery (CSRF, XSRF) 는, </p><p>웹사이트 취약점 공격의 하나로, 사용자가 자신의 의지와는 무관하게</p><p>공격자가 의도한 행위 (수정, 삭제, 등록) 을 웹사이트에 요청하게 하는 공격을 의미합니다. </p><p>출처 : 위키백과 </p></blockquote><br><h2 id="URL-설정"><a href="#URL-설정" class="headerlink" title="URL 설정"></a>URL 설정</h2><p><br><br></p><p>이제 form 이 수행하는 Django view 를 수정해줘야 할 차례입니다. 전송된 데이터를 가지고 무언가를 수행할 django view 를 작성해 줍시다. part3 에서, vote 를 처리하는 url 설정을 해주었었습니다.</p><br><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">path('<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/vote/', views.vote, name='vote'),</span></span><br></pre></td></tr></table></figure><br><br><h2 id="polls-views-py-수정하기"><a href="#polls-views-py-수정하기" class="headerlink" title="polls/views.py 수정하기"></a>polls/views.py 수정하기</h2><br><p>위 url 은 vote 함수를 불러옵니다. part3 에서, 이것을 처리하는 예시 view 를 작성했었는데, </p><p>이 polls/views.py 파일에서 vote() 함수를 아래와 같이 업데이트 해줍니다.</p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        selected_choice = question.choice_set.get(pk=request.POST[<span class="string">'choice'</span>])</span><br><span class="line">    <span class="keyword">except</span> (KeyError, Choice.DoesNotExist):</span><br><span class="line">        <span class="comment"># 투표 폼을 다시 출력 </span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, </span><br><span class="line">                  &#123; <span class="string">'question'</span>: question,</span><br><span class="line">                    <span class="string">'error_message'</span>: <span class="string">"You didn't select a choice"</span>,</span><br><span class="line">                    &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        selected_choice.votes += <span class="number">1</span> </span><br><span class="line">        selected_choice.save()</span><br><span class="line">        <span class="comment"># 항상 POST 데이터를 성공적으로 다루었을때는</span></span><br><span class="line">        <span class="comment"># HttpResponseRedirect 를 반환해 줍니다 </span></span><br><span class="line">        <span class="comment"># 이것으로 사용자가 데이터를 뒤로가기 버튼을 눌러서 데이터를 두번 전송하는것을 방지합니다. </span></span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'polls:results'</span>, args=(question.id,)))</span><br></pre></td></tr></table></figure><br><br><p>위의 예시에는, 아직 우리가 공부하지 않은 몇가지가 있습니다. </p><br><ul><li><p><code>request.POST</code>는 사전 형태의 객체로 전송된 데이터를 key 이름으로 접근할수 있게 해줍니다. 해당 예시에서는, <code>request.POST[&#39;choie&#39;]</code>는 선택된 choice 의 ID 를 문자열 형태로 반환합니다. <code>request.POST</code> 값은 언제나 문자열로 되어 있습니다. </p></li><li><p>Django 는 <code>request.GET</code>도 지원합니다. GET 데이터를 접근할때 사용합니다. 하지만, 튜토리얼에서는, 명시적으로 <code>request.POST</code>를 사용합니다. 데이터를 바꿀때에는 <code>POST</code> 콜을 통해서만 작업합니다. </p></li><li><p>만약 choice 가 POST 데이터에서 제공되지 않았을때, <code>request.POST[&#39;choice&#39;]</code> 는 <code>KeyError</code>를 발생시킵니다. 위의 예시 코드는 choice 가 주어지지 않았을때, KeyError 를 확인하고 question 폼을 다시 표시합니다. </p></li><li><p>choice 카운트가 증가하였을때, 코드는 <code>HttpResponse</code> 대신에, <code>HttpResponseRedirect</code>를 반환합니다. <code>HttpResponseRedirect</code>는 하나의 인자, 즉 redirect 할 URL 을 받습니다. 위의 코드에 주석으로 나와 있듯이, POST 데이터를 성공적으로 다루었을때에는, <code>HttpResponseRedirect</code>를 반환하여, 데이터가 2번 전송되는것을 방지 합니다. </p></li><li><p><code>reverse()</code> 함수를 <code>HttpResponseRedirect</code>에 사용하는데. reverse() 함수는 view에서 하드코드된 URL 을 가지게 되는것을 방지합니다. <code>reverse(&#39;polls:results&#39;, args=(question.id))</code> 에서 보이듯, view 의 이름과 전달할 변수명을 받습니다. 해당 예시에서는, reverse() 함수가 아래와 같은 문자열을 반환 합니다.  </p></li><li><pre><code class="django"><span class="xml">reverse('polls:results', args=(quesiton.id,)) </span><span class="xml">'/polls/3/results/' </span><span class="xml"># 3 은 question.id 이고 </span><span class="xml"># Redirect 된 URL 은 'results' 뷰를 호출하여 마지막 페이지를 출력합니다 </span><span class="xml"><span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">part3 에서 다루었지만, request 는 HttpRequest 객체입니다. </span><br><span class="line"></span><br><span class="line">&lt;br&gt;HttpRequest 객체에 대해서 더 알고 싶으면, request and response 문서를 확인 하면 됩니다. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">누군가가 질문에 대한 투표를 마치면, vote() 뷰는 질문에 대한 results 페이지로 리다이렉트 시킵니다. 따라서, result view 도 바꿔줘야 합니다. </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## polls&#x2F;views.py (Results view) 수정</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">polls&#x2F;views.py 에 results() 함수를 아래와 같이 업데이트 해줍니다. </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;django</span><br><span class="line">from django.shortcuts import get_object_or_404, render</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def results(request, question_id):</span><br><span class="line">    question &#x3D; get_object_or_404(Question, pk&#x3D;question_id)</span><br><span class="line">    return render(request, &#39;polls&#x2F;results.html&#39;, &#123;&#39;question&#39;: question&#125;)</span><br></pre></td></tr></table></figure></span></span></code></pre></li></ul><br><br><p>part3 에서 봤던 detail() 뷰와 거의 흡사합니다만, template 이름만 다른것을 확인 할수 있습니다. </p><br><blockquote><p>results 뷰에서, </p><p>‘polls/results.html’에 render 를 해주는데.</p><p>polls/results.html 파일이 없습니다. <br></p><p>polls/results.html 파일을 생성하고, 아래와 같이 내용을 채워줍니다. </p></blockquote><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; question.question_text &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> choice <span class="keyword">in</span> question.choice_set.all %&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123; choice.choice_text &#125;&#125;</span><span class="xml"> -- </span><span class="template-variable">&#123;&#123; choice.votes &#125;&#125;</span><span class="xml"> vote</span><span class="template-variable">&#123;&#123; choice.votes|<span class="name">pluralize</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> 'polls:detail' question.id %&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>Vote again?<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br><br><blockquote><p>서버를 시작하고, 체크해봅니다. 브라우저에서 polls/ 로 접속합니다. </p></blockquote><br><img src="/2020/04/30/Writing-your-first-Django-app-part4-1%ED%8E%B8/image1.png" class=""> <br><blockquote><p>what’s up? 질문을 클릭합니다. </p></blockquote><br><img src="/2020/04/30/Writing-your-first-Django-app-part4-1%ED%8E%B8/image2.png" class=""><br><blockquote><p>Not Much 를 선택하고 Vote 를 눌러봅니다 </p></blockquote><br><img src="/2020/04/30/Writing-your-first-Django-app-part4-1%ED%8E%B8/image3.png" class=""><br><blockquote><p>아무것도 선택 안하고, </p><p>vote 버튼을 누르면, 에러가 표시될겁니다. </p></blockquote><br><img src="/2020/04/30/Writing-your-first-Django-app-part4-1%ED%8E%B8/image4.png" class=""> <br><p><strong>Race conditions</strong></p><br><p>vote() 뷰는 조그마한 문제점이 하나 있습니다. Votes 뷰는 첫번째로, selected_choice 객체를 데이터베이스에서 가져옵니다. 그리고, 새 votes 의 값을 계산하고 데이터베이스에 다시 저장합니다. </p><p>하지만, 만약 두명의 사용자가 동시에 vote 를 할때에는, 이것이 잘못 될수도 있습니다. </p><p>이것은 race condition 이라고 불리우는데, F() 함수를 사용해서 이점을 피할수도 있습니다. </p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>reverse() 함수를 자주 사용하던데, reverse 함수 사용법을 다시 숙지 해야 합니다. </p><p>그리고 F() 함수도 나중에 리뷰해야 할것 같습니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part4-1%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part3 - 7편</title>
      <link>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part3-7%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part3-7%ED%8E%B8/</guid>
      <pubDate>Thu, 30 Apr 2020 04:08:14 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;URL-이름공간-분리하기&quot;&gt;&lt;a href=&quot;#URL-이름공간-분리하기&quot; class=&quot;headerlink&quot; title=&quot;URL 이름공간 분리하기&quot;&gt;&lt;/a&gt;URL 이름공간 분리하기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;이번 튜토리얼은, polls 앱 하나 밖에 없습니다. &lt;/p&gt;
&lt;p&gt;하지만, 실제 Django 프로젝트에서는, 프로젝트에서 사용되는 앱의 갯수가, 5개, 10개, 20개 혹은 그 이상이 될수 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;그렇다면, Django 는 URL 이름들을 어떻게 구분해야 할까요? &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="URL-이름공간-분리하기"><a href="#URL-이름공간-분리하기" class="headerlink" title="URL 이름공간 분리하기"></a>URL 이름공간 분리하기</h2><br><p>이번 튜토리얼은, polls 앱 하나 밖에 없습니다. </p><p>하지만, 실제 Django 프로젝트에서는, 프로젝트에서 사용되는 앱의 갯수가, 5개, 10개, 20개 혹은 그 이상이 될수 있습니다. </p><br><p>그렇다면, Django 는 URL 이름들을 어떻게 구분해야 할까요? </p><br><a id="more"></a> <br><blockquote><p>예를들어, </p><p>polls 앱은 detail view 를 가지고 있습니다. </p><p>하지만, polls 앱 외에 다른 앱인 blog 앱이 존재한다고 가정할때, </p><p>그 앱도 detail view 를 가지고 있을수 있습니다. </p></blockquote><br><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">그렇다면, </span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> %&#125;</span><span class="xml"> 태그안에서 어떻게 이 두가지의 detail view 를 구분할까요?</span></span><br></pre></td></tr></table></figure><br><h2 id="URLConf-에-이름공간-추가하기"><a href="#URLConf-에-이름공간-추가하기" class="headerlink" title="URLConf 에 이름공간 추가하기"></a>URLConf 에 이름공간 추가하기</h2><br><p>정답은, URLConf 에 이름공간들을 추가해 주는것입니다. </p><p><br>polls/urls.py 파일로 가서, app_name 을 추가해 줍니다. </p><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">from django.urls import path</span></span><br><span class="line"></span><br><span class="line"><span class="xml">from . import views</span></span><br><span class="line"></span><br><span class="line"><span class="xml">app_name = 'polls'         # Namespace 를 추가해줍니다 </span></span><br><span class="line"><span class="xml">urlpatterns = [</span></span><br><span class="line"><span class="xml">    path('', views.index, name='index'),</span></span><br><span class="line"><span class="xml">    path('<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/', views.detail, name='detail'),</span></span><br><span class="line"><span class="xml">    path('<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/results/', views.results, name='results'),</span></span><br><span class="line"><span class="xml">    path('<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/vote/', views.vote, name='vote'),</span></span><br><span class="line"><span class="xml">]</span></span><br></pre></td></tr></table></figure><br><br><h2 id="URLConf-에-추가된-Namesapce-사용"><a href="#URLConf-에-추가된-Namesapce-사용" class="headerlink" title="URLConf 에 추가된 Namesapce 사용"></a>URLConf 에 추가된 Namesapce 사용</h2><br><p>polls/index.html 템플릿은 아래와 같이 작성되어 있습니다. (지난 포스팅) </p><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'detail' question.id %&#125;"</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>No polls are available.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><br><p>바뀐 namespace 를 적용하고, a 태그가 정확하게 polls 에 있는 detail  뷰를 가르키게 하려면, </p><p>아래와 같이 a 태그를 수정해 줍니다. </p><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'polls:detail' question.id %&#125;"</span>&gt;</span></span><br><span class="line">    &#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> %&#125;</span><span class="xml"> 태그안에, </span></span><br><span class="line"><span class="xml">'polls:detail' 이라고 써주어서, polls 에 있는 detail path 라는것을 지정해 줍니다.</span></span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><br><p>polls 앱 말고, 다른 앱이 존재 한다면, namespace  를 분리하기 위해서, 아래 절차를 따르면 됩니다. </p><br><ol><li><p>해당 엡의 urls.py 에 app_name 을 지정 </p></li><li><p>템플릿에서 </p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> %&#125;</span><span class="xml">  태그안에 '앱이름:url명' 으로 url  연결</span></span><br><span class="line"></span><br><span class="line"><span class="xml">e.g. </span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> 'polls:detail' question.id %&#125;</span></span><br></pre></td></tr></table></figure></li></ol><br><p>뷰를 작성하는것이 편해졌다면, 이제 튜토리얼의 part 4 로 넘어갑니다. </p><p><br>part4 는, form  프로세싱과 generic 뷰에 대한 기본을 다룹니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/30/Writing-your-first-Django-app-part3-7%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part3 - 6편</title>
      <link>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-6%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-6%ED%8E%B8/</guid>
      <pubDate>Tue, 28 Apr 2020 10:39:10 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;템플릿에서-하드-코드된-코드-제거하기&quot;&gt;&lt;a href=&quot;#템플릿에서-하드-코드된-코드-제거하기&quot; class=&quot;headerlink&quot; title=&quot;템플릿에서 하드 코드된 코드 제거하기&quot;&gt;&lt;/a&gt;템플릿에서 하드 코드된 코드 제거하기&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;polls/index.html 템플릿에서 question 에 연결된 링크를 기억해야 합니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;해당 링크는 부분적으로 아래와 같이 하드 코드 되어 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;/polls/&amp;#123;&amp;#123; question.id &amp;#125;&amp;#125;/&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&amp;#123; question.question_text &amp;#125;&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="템플릿에서-하드-코드된-코드-제거하기"><a href="#템플릿에서-하드-코드된-코드-제거하기" class="headerlink" title="템플릿에서 하드 코드된 코드 제거하기"></a>템플릿에서 하드 코드된 코드 제거하기</h2><br><br><p>polls/index.html 템플릿에서 question 에 연결된 링크를 기억해야 합니다. </p><p><br>해당 링크는 부분적으로 아래와 같이 하드 코드 되어 있습니다. </p><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/polls/&#123;&#123; question.id &#125;&#125;/"</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><a id="more"></a><p>하드 코드된 코드들의 문제점은, </p><p><br>템플릿 수가 많아질때, URL 들을 바꾸는것이 굉장히 어려워 진다는 점입니다. </p><br><p>하지만 path() 함수내 polls.urls 모듈에 대한 인자를 정의 하여, 특정 URL에 대한 의존도를 없앨수 있습니다. </p><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> %&#125;</span><span class="xml"> 템플릿 테그를 사용해서 이 작업을 수행합니다.</span></span><br></pre></td></tr></table></figure><br><p>polls/index.html 의 코드를 아래와 같이 바꿔줍니다. </p><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> 'detail' question.id %&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span><span class="template-variable">&#123;&#123; question.question_text &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml"># 참고 polls/urls.py </span></span><br><span class="line"></span><br><span class="line"><span class="xml">urlpatterns = [</span></span><br><span class="line"><span class="xml">    path("", views.index, name='index'),</span></span><br><span class="line"><span class="xml">    path('<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/', views.detail, name='detail'), </span></span><br><span class="line"><span class="xml">    # 위 a 태그 안에 'detail' 을 지정함 </span></span><br><span class="line"><span class="xml">    path('<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/results/', views.results, name='results'),</span></span><br><span class="line"><span class="xml">    path('<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/vote/', views.vote, name='vote'),</span></span><br><span class="line"><span class="xml">]</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"> </span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> %&#125;</span><span class="xml"> 태그 안에,  'detail' 이름을 가진 url 주소를 정의하고, </span></span><br><span class="line"><span class="xml"> question.id 라는 인자를 넣어주었습니다. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">이러한 방식으로, polls.urls 모듈에 있는 URL 정의를 조회하여 <span class="tag">&lt;<span class="name">a</span>&gt;</span> 태그가 작업을 수행 합니다.</span></span><br></pre></td></tr></table></figure><br><blockquote><p>polls/specifics/12/ 같이 </p><p>detail view 를 보여주는 URL 주소명을 다른것으로 바꾸고 싶을때에는, </p><p>이전에는 polls/index.html 의 a 태그를 바꾸어 줬어야 했겟지만, </p><p>이제는 polls/urls.py 파일에 name=’detail’ 을 가진 path 를 </p><p>아래와 같이 고쳐주면 됩니다.  </p></blockquote><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">path('specifics/<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/', views.detail, name='detail'),</span></span><br></pre></td></tr></table></figure><br><br><p>실험을 해보기 위해서, 브라우저에서 <a href="http://127.0.0.1:8000/polls/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/</a> 로 접속합니다.</p><p>What’s up? 질문이 화면에 출력이 됩니다. </p><br><img src="/2020/04/28/Writing-your-first-Django-app-part3-6%ED%8E%B8/image1.png" class=""><br><br><p>이 What’s up? 을 클릭하면, polls/urls.py 에 있는 detail 뷰가 호출이 되고, <br> </p><p>아래 path() 를 참조하여, url을 찾아가고, detial 뷰가 실행 됩니다. </p><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">path('specifics/<span class="tag">&lt;<span class="name">int:question_id</span>&gt;</span>/', views.detail, name='detail'),</span></span><br></pre></td></tr></table></figure><br><br><p>브라우저에서  <a href="http://127.0.0.1:8000/polls/specifics/1/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/specifics/1/</a> 로 이동하게 됩니다. <br></p><p>그리고, 화면에 What’s up? 질문에 딸린 choice 들이 표시가 되겠죠. </p><br><br><img src="/2020/04/28/Writing-your-first-Django-app-part3-6%ED%8E%B8/image2.png" class=""><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>urls.py 파일안에  path() 함수 안에 URL name 을 짓고. </p><p>이 이름을 템플릿에서 사용할수 있습니다.  </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-6%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part3 - 5편</title>
      <link>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-5%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-5%ED%8E%B8/</guid>
      <pubDate>Tue, 28 Apr 2020 10:25:31 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;템플릿-시스템-사용하기&quot;&gt;&lt;a href=&quot;#템플릿-시스템-사용하기&quot; class=&quot;headerlink&quot; title=&quot;템플릿 시스템 사용하기&quot;&gt;&lt;/a&gt;템플릿 시스템 사용하기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;이전 포스팅에서 작성했던 detail() 뷰로 다시 돌아갑니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;detail&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(request, question_id)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    question = get_object_or_404(Question, pk=question_id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; render(request, &lt;span class=&quot;string&quot;&gt;&#39;polls/detail.html&#39;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;question&#39;&lt;/span&gt;: question&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;컨텍스트 변수 question 이 polls/html 로 전달이 되어 render 가 됩니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="템플릿-시스템-사용하기"><a href="#템플릿-시스템-사용하기" class="headerlink" title="템플릿 시스템 사용하기"></a>템플릿 시스템 사용하기</h2><br><p>이전 포스팅에서 작성했던 detail() 뷰로 다시 돌아갑니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure><br><blockquote><p>컨텍스트 변수 question 이 polls/html 로 전달이 되어 render 가 됩니다. </p></blockquote><br><a id="more"></a><p>polls/templates/polls/detail.html 템플릿을 아래와 같이 고쳐줍니다. </p><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; question.question_text &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> choice <span class="keyword">in</span> question.choice_set.all %&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123; choice.choice_text &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br><p>템플릿 시스템은 변수의 속성들에 접근하기 위해서 <code>.</code> 을 찍어 조회를 하는, dot-lookup 형식을 사용합니다. </p><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123; question.question_text &#125;&#125;</span><span class="xml"> 에서 </span></span><br><span class="line"></span><br><span class="line"><span class="xml">첫번째로 django 는 question 객체에 대한 사전을 조회 합니다. </span></span><br><span class="line"></span><br><span class="line"><span class="xml">두번째로, . 뒤에 question_text 라는 속성값을 조회 합니다.</span></span><br></pre></td></tr></table></figure><br><br>서버를 시작하고, 브라우저를 열어서** [**http://127.0.0.1:8000/polls/1/**](http://127.0.0.1:8000/polls/1/) **에 접속하면,** <p><strong>아래와 같이 question 하나와, 해당 question에 있는 choice 들이 리스트 되어 있는것을 확인 할수 있습니다.</strong> </p><br><img src="/2020/04/28/Writing-your-first-Django-app-part3-5%ED%8E%B8/image1.png" class=""><p><br><br></p><h2 id="메서드의-호출"><a href="#메서드의-호출" class="headerlink" title="메서드의 호출"></a>메서드의 호출</h2><br><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> choice <span class="keyword">in</span> question.choice_set.all %&#125;</span><span class="xml">   </span></span><br><span class="line"><span class="xml"># question 에 붙어있는 선택들을 for 문으로 순회 시작 </span></span><br><span class="line"><span class="xml">   </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123; choice.choice_text &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"># 순회 하는동안 <span class="tag">&lt;<span class="name">li</span>&gt;</span> 태그 안에 하나씩 choice_text 들을 출력 </span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml">                                  # for 문 종료</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">메써드의 호출은 </span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> %&#125;</span><span class="xml"> 반복문에서 이루어집니다. </span></span><br><span class="line"></span><br><span class="line"><span class="xml">question.choice_set.all 은 파이썬 코드에서 question.choice_set.all() 로 해석이 됩니다. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">question.choice_set.all() 은 순회가능한 Choice 객체들을 반환하고, </span></span><br><span class="line"></span><br><span class="line"><span class="xml">이것은 </span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> %&#125;</span><span class="xml"> 테그 안에서 사용하기 적합합니다.</span></span><br></pre></td></tr></table></figure><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><br><p>템플릿에 나오는 템플릿 언어의 구분이 많이 힘들었습니다. </p><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> %&#125;</span><span class="xml"> 나 </span><span class="template-variable">&#123;&#123; question.choice_set.all &#125;&#125;</span><span class="xml"> 같은 템플릿 언어들 말입니다. </span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% %&#125;</span><span class="xml"> 어떠한 로직들을 불러오는 코드라고 생각하고 (예 조건문, 반복문) </span></span><br><span class="line"><span class="template-variable">&#123;&#123; &#125;&#125;</span><span class="xml"> 는 변수나 객체의 값들만 가지는 코드라고 이해하고 넘어갑니다.</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-5%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part3 - 4편</title>
      <link>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-4%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-4%ED%8E%B8/</guid>
      <pubDate>Tue, 28 Apr 2020 02:41:55 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;render-숏컷&quot;&gt;&lt;a href=&quot;#render-숏컷&quot; class=&quot;headerlink&quot; title=&quot;render() 숏컷&quot;&gt;&lt;/a&gt;render() 숏컷&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;템플릿을 읽고, 컨텍스를 채우고, 렌더가 된 템플릿을 결과값으로 가진 HttpResponse 객체를 반환 하는 일은 매우 흔한 일입니다. 따라서, Django 는 이것에 대한 shortcut 함수를 제공합니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;render() 함수는 &lt;/p&gt;
&lt;p&gt;템플릿을 읽고, context 를 채우고, &lt;/p&gt;
&lt;p&gt;결과를 템플릿에 객체로 반환합니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;render() 함수를 알아보기 위해서, polls/views.py 에 index() 함수를 다시 써줍니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="render-숏컷"><a href="#render-숏컷" class="headerlink" title="render() 숏컷"></a>render() 숏컷</h2><br><br><p>템플릿을 읽고, 컨텍스를 채우고, 렌더가 된 템플릿을 결과값으로 가진 HttpResponse 객체를 반환 하는 일은 매우 흔한 일입니다. 따라서, Django 는 이것에 대한 shortcut 함수를 제공합니다. </p><br><blockquote><p>render() 함수는 </p><p>템플릿을 읽고, context 를 채우고, </p><p>결과를 템플릿에 객체로 반환합니다. </p></blockquote><br><p>render() 함수를 알아보기 위해서, polls/views.py 에 index() 함수를 다시 써줍니다. </p><br><a id="more"></a> <br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="comment"># render 를 가져옵니다 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">    context = &#123;<span class="string">'latest_question_list'</span>: latest_question_list&#125;</span><br><span class="line">    <span class="comment"># return HttpResponse(template.render(context, request)) 대신 아래 render() 를 써줍니다.</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/index.html'</span>, context)</span><br></pre></td></tr></table></figure><br><br><p>render() 가 기존에 썼었던 HttpResponse 와 같은 작업을 수행하는것을 확인할수 있습니다. </p><br><blockquote><p>브라우저에서, 아래 URL로 접속해서 확인 합니다. </p><p><a href="http://127.0.0.1:8000/polls/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/</a></p></blockquote><br><img src="/2020/04/28/Writing-your-first-Django-app-part3-4%ED%8E%B8/image1.png" class=""> <br><blockquote><p>render() 를 사용하면, </p><p>loader 와 HttpResonse 모듈들을 불러오지 않아도 됩니다. </p></blockquote><br><p>render() 함수는 </p><br><ol><li>요청을 첫번째 인자로 받고, </li><li>템플릿 이름을 두번째 인자로 받고, </li><li>사전 형태의 자료를 선택적으로 세번째 인자로 받습니다. </li></ol><br><blockquote><p>render() 함수는, </p><p>주어진 context 들이 그려진 template 에 </p><p>HttpResponse 객체를 반환 합니다 </p></blockquote><br><h2 id="404-에러-발생-시키기"><a href="#404-에러-발생-시키기" class="headerlink" title="404 에러 발생 시키기"></a>404 에러 발생 시키기</h2><br><p>polls/views.py 에 있는 detail() 뷰를 한번 보겠습니다 (주어진 투표의 질문들을 나열하는 페이지). </p><p><br>Http404를 통해서, 404 에러를 발생시키는 detail 뷰는 아래와 같습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        question = Question.objects.get(pk=question_id)</span><br><span class="line">    <span class="keyword">except</span> Question.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">"Question does not exist"</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure><br><blockquote><p>여기서 새로운 컨셉은 Http404 예외 인데, </p><p>요청된 ID 를 가진 question 이 존재하지 않을때 예외를 발생시킵니다. </p></blockquote><br><p>테스트를 진행 하기 위해서, polls/templates/polls/detail.html 파일을 생성하고, 아래 내용을 추가해 줍니다. </p><br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123; quetions &#125;&#125;</span></span><br></pre></td></tr></table></figure><br><blockquote><p>현재 데이터베이스에 있는 질문은 딱 1개로, </p><p>이전 과정에서 생성한 “What’s up?” 질문밖에 없으므로, </p><p>id 값이 2 인 질문은 존재하지 않습니다. </p></blockquote><br><p><a href="http://127.0.0.1:8000/polls/1/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/1/</a> 로 접속하면, </p><p>What’s Up? 질문이 페이지에 출력이 되겠지만. </p><br><p> <a href="http://127.0.0.1:8000/polls/2/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/2/</a> 로 접속하면, </p><p>출력할 질문이 없어서, 예외가 발생합니다. 이때 Http404 가 메시지를 출력할겁니다. </p><br><img src="/2020/04/28/Writing-your-first-Django-app-part3-4%ED%8E%B8/image2.png" class=""> <br><p>Quetion does not exist 가 잘 표시되는것을 확인할수 있습니다. </p><br><h2 id="get-object-or-404-숏컷-함수"><a href="#get-object-or-404-숏컷-함수" class="headerlink" title="get_object_or_404() 숏컷 함수"></a>get_object_or_404() 숏컷 함수</h2><br><p>get() 함수를 사용하고, 객체가 존재하지 않을때,<br></p><p>Http404 를 발생시키는것은 매우 빈번하게 일어나는 일입니다. Django 는 이것에 대한 숏컷도 제공합니다. </p><p><br>다시 쓰여진 detail() 뷰는 아래와 같습니다.<br></p><br><p>polls/views.py 에 detail() 뷰를 아래와 같이 수정해 줍니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="comment"># get_object_or_404 를 코드 상단에서 가져오는것을 잊지 않습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure><p><br><br></p><p>get_object_or_404() 함수는 Django 모델을 첫번째 인수로 받고, 키워드 인수들을 두번째로 받습니다. </p><p>받은 인수들을 get() 함수에 전달하고, 객체가 존재하지 않으면 Http404 를 발생 시킵니다.  </p><p><br><br></p><blockquote><p>아래 캡쳐 화면을 통해서, </p><p>get_object_or_404() 가 잘 동작하는지 확인 해 봅시다. </p><p><a href="http://127.0.0.1:8000/polls/1/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/1/</a> 로 접속하면, </p><p>What’s Up? 질문이 페이지에 출력이 되겠지만. </p><p> <a href="http://127.0.0.1:8000/polls/2/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/2/</a> 로 접속하면, </p><p>출력할 질문이 없어서, 예외가 발생하는것은 같은데. </p><p>메시지가 “No Question matches the given query” 라고 표시됩니다. </p></blockquote><p><br><br></p><img src="/2020/04/28/Writing-your-first-Django-app-part3-4%ED%8E%B8/image3.png" class=""> <br><p>또한, get_list_or_404() 라는 함수도 존재합니다. get_object_or_404 와 비슷하게 동작하지만, </p><p>받은 인자들을 함수 대신, filter() 함수에 전달 합니다. <br></p><br><p>get_list_or_404() 함수는, 빈 리스트가 조회되었을때,  Http404 를 발생 시킵니다. </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>장고 숏컷을 다시 리뷰 합니다. </p><br><ol><li>render() 함수 </li><li>Http404() 함수 </li><li>get_object_or_404() 함수 </li></ol><br><p>filter() 함수와 get() 함수의 차이점도 숙지하고 지나갑니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/28/Writing-your-first-Django-app-part3-4%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part3 - 3편</title>
      <link>http://djangojeng-e.github.io/2020/04/27/Writing-your-first-Django-app-part3-3%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/27/Writing-your-first-Django-app-part3-3%ED%8E%B8/</guid>
      <pubDate>Mon, 27 Apr 2020 04:23:42 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;실제로-무언가를-하는-view-작성하기&quot;&gt;&lt;a href=&quot;#실제로-무언가를-하는-view-작성하기&quot; class=&quot;headerlink&quot; title=&quot;실제로 무언가를 하는 view 작성하기&quot;&gt;&lt;/a&gt;실제로 무언가를 하는 view 작성하기&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;각각의 뷰는 두가지중 하나를 실행 하도록 되어 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;ol&gt;
&lt;li&gt;요청된 페이지의 컨텐츠를 포함하고 있는 HttpResponse 객체를 반환 &lt;/li&gt;
&lt;li&gt;Http404 같은 예외를 발생 &lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;p&gt;나머지 동작은, 개발자 마음대로 입니다~ &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="실제로-무언가를-하는-view-작성하기"><a href="#실제로-무언가를-하는-view-작성하기" class="headerlink" title="실제로 무언가를 하는 view 작성하기"></a>실제로 무언가를 하는 view 작성하기</h2><br><p>각각의 뷰는 두가지중 하나를 실행 하도록 되어 있습니다. </p><br><ol><li>요청된 페이지의 컨텐츠를 포함하고 있는 HttpResponse 객체를 반환 </li><li>Http404 같은 예외를 발생 </li></ol><br><p>나머지 동작은, 개발자 마음대로 입니다~ </p><br><a id="more"></a><br><blockquote><p>view  는 데이터베이스에서 기록을 읽어 올수 있고, </p><p>Django 가 제공하는 혹은 파이썬 템플릿 시스템들을 사용 할수 있고. </p><p>PDF, XML, ZIP 같은 파일등을 생성할수도 있습니다 </p><br><p>어떤 파이썬 라이브러리든지 사용해서 View 가 작업을 수행할수 있습니다. </p></blockquote><br><p>편의성 측면에서, Django 가 원하는건 단지 두가지 뿐입니다. HttpResponse 혹은 예외 처리 뿐입니다. </p><br><p>Part 2 에서 진행 했었던, database API 를 사용해서, index() view  를 한번 실행 해 봅시다 </p><br><blockquote><p>polls/views.py 의 index 뷰를 </p><p>시스템에 존재하는 가장 최근의 질문들 5개를 출력하게 합니다 </p><p>질문들은 날짜별로 , 으로 구분되게 합니다 </p><br><p>index() 뷰를 아래와 같이 수정해 줍니다  </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    lastest_question_list = Question.obejcts.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>] </span><br><span class="line">    output = <span class="string">', '</span>.join([q.question_text <span class="keyword">for</span> q <span class="keyword">in</span> latest_question_list]) </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(output) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 다른 view 들 (detail, results, vote) 는 수정하지 않습니다. </span></span><br><span class="line"><span class="comment"># [q.question_text for q in latest_question_list] 는 list comprehension </span></span><br><span class="line"><span class="comment"># ', '.join 으로 list comprehension 안에 값들을 콤마로 구분 합니다</span></span><br></pre></td></tr></table></figure><br><br><p>파트 2에서, Question.objects.all() API 를 둘러보았었는데, </p><p><br>이번에는, <code>Question.objects.order_by(&#39;-pub_date&#39;)[:5]</code> 가 나왔습니다. </p><br><blockquote><p>Question 에 있는 객체 중, </p><p>가장 최근의 pub_date 순으로 5개를 조회 하는 쿼리를 실행  </p><p>Question.objects.order_by(‘-pub_date’)[:5]</p><br><p>Question에 있는 모든 객체 조회 쿼리, </p><p>Question.objects.all() </p></blockquote><br><br><p>근데 여기에, 문제가 좀 있습니다. </p><p><br>뷰에 있는 HttpResponse 값은 하드코드가 된 페이지 디자인 입니다. 페이지의 모양을 바꾸고 싶으면, </p><p><br>이 파이썬 코드를 매번 바꿔줘야 합니다. 코드가 짧을때는 상관 없겠지만, 페이지가 길면, 더 큰 문제가 될수 있고. </p><p><br>무엇보다, 디자인이 예쁘지 않습니다. </p><br><br><blockquote><p>따라서, </p><p>Django의 템플릿 시스템을 사용하여 디자인과 파이썬 코드를 분리합니다 </p><p>view 가 사용할수 있는 템플릿을 생성해서 사용합니다. </p></blockquote><br><h2 id="Template-생성하기"><a href="#Template-생성하기" class="headerlink" title="Template 생성하기"></a>Template 생성하기</h2><br><br><h3 id="index-html-파일-생성하기"><a href="#index-html-파일-생성하기" class="headerlink" title="index.html 파일 생성하기"></a>index.html 파일 생성하기</h3><br><p>polls 폴더내에, templates 라는 폴더를 생성합니다. </p><p><br>Django 는 기본적으로 App 폴더안에 있는 Templates 폴더를 찾아서, Template 파일을 확인하고, 그것을 본 뒤에, 브라우저에 출력을 해줍니다. </p><br><p>polls 앱에서 사용하는 templates 는 polls/templates/ 폴더 안에 있는 파일들이겠죠? </p><br><blockquote><p>생성한 templates 폴더안에, index.html 파일을 생성합니다 </p><p>polls/templates/polls/index.html </p></blockquote><br><img src="/2020/04/27/Writing-your-first-Django-app-part3-3%ED%8E%B8/image1.png" class=""><br><br><blockquote><p><strong>템플릿 이름 공간</strong></p><p>장고는 이름과 일치하는 첫번째 템플릿을 선택할 것이고, </p><p>다른 응용 프로그램에 같은 이름의 템플릿이 있다면, 장고는 그것을 구별할수 없습니다. </p><br><p>우리는 장고가 올바른 템플릿을 찾게 만들어줘야 하고, </p><p>이것을 확실히 하기 위한 가장 좋은 방법은, 그들의 이름을 붙여주는것입니다. </p><br><p>즉, 어플리케이션 자체를 위해 명명된 템플릿 폴더안에, </p><p>다시한번, 어플리케이션 이름을 가진 폴더를 생성하여 </p><p><code>(polls/templates/polls/index.html)</code></p><p>다른 이름공간에 존재하는 템플릿을 구분하게 만들어 주는 것입니다.  </p></blockquote><br><br><h3 id="index-html-파일-내용-추가"><a href="#index-html-파일-내용-추가" class="headerlink" title="index.html 파일 내용 추가"></a>index.html 파일 내용 추가</h3><br><p><code>polls/templates/polls/index.html</code> 파일에 아래 내용을 추가해줍니다. </p><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/polls/&#123;&#123; question.id &#125;&#125;/"</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>No polls are available.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p><br><br></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"># </span><span class="template-tag">&#123;% %&#125;</span><span class="xml"> 안에 들어 있는 내용들은 템플릿 언어 입니다. 로직 혹은 구문들을 사용할수 있습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="xml"># </span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="xml"> 안에 들어 있는 내용도 템플릿 언어 인데, 변수들을 표시할수 있습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="xml"># html 에서 이 템플릿 언어를 사용하여, 해당 데이터들을 다룰수 있습니다.</span></span><br></pre></td></tr></table></figure><br><h3 id="View-에서-index-html-파일을-템플릿으로-사용"><a href="#View-에서-index-html-파일을-템플릿으로-사용" class="headerlink" title="View 에서 index.html 파일을 템플릿으로 사용"></a>View 에서 index.html 파일을 템플릿으로 사용</h3><p><br><br></p><p>polls/views.py 파일을 아래와 같이 수정해 줍니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader    <span class="comment"># 템플릿 파일을 불러오기 위한 loader 모듈 가져오기 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">    template = loader.get_template(<span class="string">'polls/index.html'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># template 에 전달할 객체 latest_question_list 를 사전 형태로 저장 </span></span><br><span class="line"></span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">'latest_question_list'</span>: latest_question_list,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(template.render(context, request))</span><br><span class="line">    <span class="comment"># render 를 사용하여, template에서 사용할 객체 latest_question_list 를 template 에 출력해줌</span></span><br></pre></td></tr></table></figure><p><br><br></p><p>해당 코드는 polls/index.html 템플릿 파일을 읽어오고, 거기에 context 를 전달합니다. </p><p><br>context 는 사전형태로, 메핑된 파이썬 객체에 할당된 템플릿 변수 이름들입니다. <br><br></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"># 이 템플릿 변수가 html 에 전달이 되면, </span></span><br><span class="line"><span class="xml"># 위에 나온 `</span><span class="template-tag">&#123;% %&#125;</span><span class="xml">` 나 `</span><span class="template-variable">&#123;&#123; &#125;&#125;</span><span class="xml">` 같은 템플릿 언어를 사용하여, 데이터들을 다룰수 있습니다.</span></span><br></pre></td></tr></table></figure><br><blockquote><p>브라우저에 접속해서, </p><p><a href="http://127.0.0.1:8000/polls/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/</a> 에 접속합니다.</p><p>part2 에서 입력하였던, What’s up? 질문이 화면에 표시됩니다. </p></blockquote><br><img src="/2020/04/27/Writing-your-first-Django-app-part3-3%ED%8E%B8/image2.png" class=""><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>처음에 굉장히 헷갈리는 개념입니다. </p><p>view 를 어떻게 작성해야 할지, <br></p><p>어떻게 URL에 연결해줘야 할지, <br></p><p>어떤 Template 을 끄집어내서 사용할지,,, <br><br></p><p>계속 아래 그림을 생각하면서, view 가 어떤 역할을 하는지 이해하려 하고 넘어갑니다. <br></p><img src="/2020/04/27/Writing-your-first-Django-app-part3-3%ED%8E%B8/image3.png" class="">]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/27/Writing-your-first-Django-app-part3-3%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Writing your first Django app, part3 - 2편</title>
      <link>http://djangojeng-e.github.io/2020/04/26/Writing-your-first-Django-app-part3-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/26/Writing-your-first-Django-app-part3-2%ED%8E%B8/</guid>
      <pubDate>Sun, 26 Apr 2020 03:41:35 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;더-많은-view-쓰기&quot;&gt;&lt;a href=&quot;#더-많은-view-쓰기&quot; class=&quot;headerlink&quot; title=&quot;더 많은 view 쓰기&quot;&gt;&lt;/a&gt;더 많은 view 쓰기&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;지난 포스팅에서 짧게 polls 앱에 필요한 views를 둘러보았습니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;이제 몇개의 view 들을 polls/views.py 에 더 써줄겁니다. 추가될 view 들은 좀 다릅니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;추가되는 view 들은 인수를 가집니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; django.shortcuts &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; render&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; django.http &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; HttpResponse&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Create your views here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(request)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; HttpResponse(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world. You&#39;re at the polls index.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;detail&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(request, question_id)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; HttpResponse(&lt;span class=&quot;string&quot;&gt;&quot;You&#39;re looking at question %s.&quot;&lt;/span&gt; % question_id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(request, question_id)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    response = &lt;span class=&quot;string&quot;&gt;&quot;You&#39;re looking at the results of question %s.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; HttpResponse(response % question_id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;vote&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(request, question_id)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; HttpResponse(&lt;span class=&quot;string&quot;&gt;&quot;You&#39;re voting on question %s.&quot;&lt;/span&gt; % question_id)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="더-많은-view-쓰기"><a href="#더-많은-view-쓰기" class="headerlink" title="더 많은 view 쓰기"></a>더 많은 view 쓰기</h2><br><br><p>지난 포스팅에서 짧게 polls 앱에 필요한 views를 둘러보았습니다. </p><p><br>이제 몇개의 view 들을 polls/views.py 에 더 써줄겁니다. 추가될 view 들은 좀 다릅니다. </p><p><br>추가되는 view 들은 인수를 가집니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"Hello, world. You're at the polls index."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"You're looking at question %s."</span> % question_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    response = <span class="string">"You're looking at the results of question %s."</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response % question_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"You're voting on question %s."</span> % question_id)</span><br></pre></td></tr></table></figure><br><a id="more"></a><br><blockquote><p>새로 추가된 view 들을 URL과 연결해 줍니다 </p><p>polls/urls.py 에 아래와 같이 각 view 들을 URL 과 연결해 줍니다 .</p></blockquote><br><br><h2 id="HttpResponse"><a href="#HttpResponse" class="headerlink" title="HttpResponse"></a>HttpResponse</h2><p><br><br></p><p>참고로, <code>HttpResponse</code> 함수는, 단순히 괄호안에 들어간 값을 브라우저에 출력해 줍니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views         <span class="comment"># polls/views.py 를 가져옴</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 예: /polls/</span></span><br><span class="line">    <span class="comment"># http://127.0.0.1:8000/polls/ 로 접속시, views 에 있는 index 함수 호출후 실행 </span></span><br><span class="line">    path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 예: /polls/5/</span></span><br><span class="line">    <span class="comment"># http://127.0.0.1:8000/polls/5/ 로 접속시, views 에 있는 detail 함수 호출후 실행 </span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/'</span>, views.detail, name=<span class="string">'detail'</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 예: /polls/5/results/</span></span><br><span class="line">    <span class="comment"># http://127.0.0.1:8000/polls/5/results/ 로 접속시, view 에 있는 results 함수 호출후 실행 </span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/results/'</span>, views.results, name=<span class="string">'results'</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 예: /polls/5/vote/</span></span><br><span class="line">    <span class="comment"># http://127.0.0.1:8000/polls/5/vote/ 로 접속시, view 에 있는 vote 함수 호출후 실행  </span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br><br><p><a href="http://127.0.0.1:8000/polls/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls</a>/34 도 브라우저에서 실행 해서 한번 봅니다. 이렇게 하면, views 에 있는 detail() 메서드가 실행되고, URL에 포함되어 있는 어떤 ID 값을 인수로 받아서 화면에 결과값이 출력됩니다. </p> <br><p><a href="http://127.0.0.1:8000/polls/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls</a>/34/results <br></p><p><a href="http://127.0.0.1:8000/polls/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls</a>/34/vote 도 실행 해 보세요. </p><br><p><strong>HttpResponse 함수가 실행되고, 단순히 괄호안에  들어간 값을 브라우저에 출력해 줍니다.</strong><br><br></p><blockquote><p>누군가가 웹사이트에 있는 페이지를 요청 하면, </p><p>예를들어, <a href="http://127.0.0.1:8000/polls/34/" target="_blank" rel="noopener">http://127.0.0.1:8000/polls/34/</a></p><br><p>Django 는 RootURL 설정으로인해 mysite/urls.py 파이썬 모듈을 읽어 들입니다. </p><p>루트 URL 설정으로 경로가, </p><p><code>path(&#39;polls&#39;, include(&#39;polls.urls&#39;))</code>로 설정되어 있기 때문에, </p><p>polls/urls.py 에 있는 url 설정이 불러져서 작동합니다. </p></blockquote><p><br><br></p><h2 id="lt-int-question-id-gt-는-인자"><a href="#lt-int-question-id-gt-는-인자" class="headerlink" title="&lt;int:question_id&gt;는 인자"></a><code>&lt;int:question_id&gt;</code>는 인자</h2><br><p>polls/ 가 URL 경로에 매칭이되고, polls.urls 로 넘어가는데. </p><p>polls/34/  라는 URL 경로에 들어가면, 34 가 <code>&lt;int:question_id&gt;</code> 와 매칭이 됩니다, 따라서 detail() 뷰를 호출할때. 이것을 인자로 넘겨줍니다.</p><p><br><br></p><blockquote><p>URL 의 확장자는 붙여줄 필요는 없지만, </p><p>원한다면 붙여주어도 괜찮습니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'polls/latest.html'</span>, views.index),</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p>아직도 좀 헷갈리는 부분이긴 한데. </p><p>url 을 통해서 요청을 받고, 그 요청을 view 에서 처리한다는 개념을 다시 복습하고 갑니다. </p><p>url 을 통해서 요청을 받을때, 그 요청에 인수까지 받아서 view 에 있는 함수에 전달해 줄수 있다. </p><p>이런식으로 개념을 잡고 넘어갑니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/26/Writing-your-first-Django-app-part3-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
