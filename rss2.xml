<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>장고쟁이</title>
    <link>http://djangojeng-e.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>장고쟁이의 Python, Django 공부 노트</description>
    <pubDate>Wed, 08 Apr 2020 06:50:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>PEP8 Programming Recommendations - 2편</title>
      <link>http://djangojeng-e.github.io/2020/04/08/PEP8-Programming-Recommendations-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/08/PEP8-Programming-Recommendations-2%ED%8E%B8/</guid>
      <pubDate>Wed, 08 Apr 2020 06:19:47 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;PEP8-프로그래밍-권장사항들-2편&quot;&gt;&lt;a href=&quot;#PEP8-프로그래밍-권장사항들-2편&quot; class=&quot;headerlink&quot; title=&quot;PEP8 프로그래밍 권장사항들 - 2편&quot;&gt;&lt;/a&gt;PEP8 프로그래밍 권장사항들 - 2편&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;BaseException이-아닌-Exception&quot;&gt;&lt;a href=&quot;#BaseException이-아닌-Exception&quot; class=&quot;headerlink&quot; title=&quot;BaseException이 아닌 Exception&quot;&gt;&lt;/a&gt;BaseException이 아닌 Exception&lt;/h2&gt;&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;BaseException 이 아닌 &lt;/p&gt;
&lt;p&gt;Exception 에서 예외를 파생 시킵니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;BaseException에서 직접 상속은 예외를 잡는것이 틀린일인 예외를 위해 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;예외를 잡아내는 코드가 필요한 곳과, 예외가 발생하는곳을 잘 구분해서. 예외의 상하관계를 디자인 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;“문제가 발생했습니다” 라는 단순한 얘기보다. 프로그래밍적으로 “무엇이 잘못됬지?” 라는 질문을 답하도록 목표합니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;예외가 오류인 경우 예외 클래스에 접미사 &lt;code&gt;Error&lt;/code&gt;를 추가해야 합니다만, 클래스 이름 지정 규칙이 여기에 적용됩니다.  &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="PEP8-프로그래밍-권장사항들-2편"><a href="#PEP8-프로그래밍-권장사항들-2편" class="headerlink" title="PEP8 프로그래밍 권장사항들 - 2편"></a>PEP8 프로그래밍 권장사항들 - 2편</h2><p><br><br></p><h2 id="BaseException이-아닌-Exception"><a href="#BaseException이-아닌-Exception" class="headerlink" title="BaseException이 아닌 Exception"></a>BaseException이 아닌 Exception</h2><br><blockquote><p>BaseException 이 아닌 </p><p>Exception 에서 예외를 파생 시킵니다. </p></blockquote><br><p>BaseException에서 직접 상속은 예외를 잡는것이 틀린일인 예외를 위해 있습니다. </p><br><p>예외를 잡아내는 코드가 필요한 곳과, 예외가 발생하는곳을 잘 구분해서. 예외의 상하관계를 디자인 합니다. </p><br><p>“문제가 발생했습니다” 라는 단순한 얘기보다. 프로그래밍적으로 “무엇이 잘못됬지?” 라는 질문을 답하도록 목표합니다. </p><br><br><p>예외가 오류인 경우 예외 클래스에 접미사 <code>Error</code>를 추가해야 합니다만, 클래스 이름 지정 규칙이 여기에 적용됩니다.  </p><br><br><a id="more"></a><br><h2 id="예외연계"><a href="#예외연계" class="headerlink" title="예외연계"></a>예외연계</h2><br><p>파이썬3 에서는 “raise X form Y” 라는 형태의 예외 연계를 적절하게 써줘야 합니다. 이렇게 하면, 본래의 <code>traceback</code>을 잃지 않고, 명시적으로 교체를 해줄수 있습니다. </p><br><p>내부 예외를 교체할때는 (파이썬2 에서는 <code>raise X</code>, 파이썬 3.3부터는 <code>raise X from None</code>), 연관이 있는 세부사항들이 새로운 예외로 전송되어야 합니다. 연관이 있는 세부사항들에 대한 예를 들자면, 속성명이나, 원조 예외의 메시지 등을 예로 들수 있습니다. </p><br><br><h2 id="raiseValueError-39-message-39"><a href="#raiseValueError-39-message-39" class="headerlink" title="raiseValueError(&#39;message&#39;)"></a><code>raiseValueError(&#39;message&#39;)</code></h2><br><p><code>raiseValueError(&#39;message&#39;)</code> 형태는 옛날 스타일로, 파이썬3에서는 허용되지 않습니다. </p><br><br><h2 id="예외를-잡아낼때는-bare-except-절의-사용을-피합니다"><a href="#예외를-잡아낼때는-bare-except-절의-사용을-피합니다" class="headerlink" title="예외를 잡아낼때는, bare except:절의 사용을 피합니다"></a>예외를 잡아낼때는, <code>bare except:</code>절의 사용을 피합니다</h2><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> platform_speicific_module </span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    platform_specific_module = <span class="literal">None</span></span><br></pre></td></tr></table></figure><br><br><p><code>bare except:</code>    절은 <code>SystemExit</code> 하고 <code>KeyboardInterrupt</code> 예외를 잡아낼것이고, <code>Ctrl + C</code> 로 방해하기 어렵고, 다른 문제들을 야기시킬수 있습니다. </p><br><p>만약 프로그램 에러 신호를 보내는 모든 예외들을 잡고 싶다면, <code>except Exception:</code>을 사용합니다. </p><br><p>가장 좋은 방법은 <code>bare except:</code>절의 사용을 두가지 경우로 제한하는겁니다. </p><br><ol><li>예외 처리기가 traceback을 인쇄하거나 기록하는 경우, 사용자는 최소한 오류가 발생했음을 알게 됩니다 </li><li>코드가 정리 작업을 수행해야 할때, 예외가 발생하면 예외가 위쪽으로도 영향을 미칠수 있습니다. <code>try, finally</code> 를 쓰는것이 이런것을 다룰때 좋습니다. </li></ol><br><br><h2 id="잡은-예외를-이름에-묶어두고-싶을때"><a href="#잡은-예외를-이름에-묶어두고-싶을때" class="headerlink" title="잡은 예외를 이름에 묶어두고 싶을때"></a>잡은 예외를 이름에 묶어두고 싶을때</h2><br><br><p>파이썬2.6 에 추가된 명시적인 이름 묶기 syntax 를 사용합니다 </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    process_data()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">    <span class="keyword">raise</span> DataProcessingFailedError(str(exc))</span><br></pre></td></tr></table></figure><br><p>이것은 파이썬 3에서만 지원됩니다. 오래된 스타일의 콤마가 들어가는 syntax 를 사용해서 혼란스러운 문제들은 피해야 합니다. </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>프로그래밍 권장사항 내용이 길어지네요. </p><p>대부분의 경우에는 아직까지 이해가 잘 안가고. 원문을 읽어봐도 이해가 잘 안갑니다 ㅠㅠ </p><br><p>근데 이게, 아직 제가 프로그래밍 레벨이 낮아서 이해가 안가는거 같습니다. <br></p><p>나중엔 좀 더 이해가 빠르겟죠? ㅎ</p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/08/PEP8-Programming-Recommendations-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Programming Recommendations - 1편</title>
      <link>http://djangojeng-e.github.io/2020/04/08/PEP8-Programming-Recommendations-1%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/08/PEP8-Programming-Recommendations-1%ED%8E%B8/</guid>
      <pubDate>Tue, 07 Apr 2020 17:32:08 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;PEP8-Programming-Recommendations-1편&quot;&gt;&lt;a href=&quot;#PEP8-Programming-Recommendations-1편&quot; class=&quot;headerlink&quot; title=&quot;PEP8 Programming Recommendations - 1편&quot;&gt;&lt;/a&gt;PEP8 Programming Recommendations - 1편&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;프로그래밍 권장 사항들 - 1편입니다&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;다른-파이썬-라이브러리의-구현&quot;&gt;&lt;a href=&quot;#다른-파이썬-라이브러리의-구현&quot; class=&quot;headerlink&quot; title=&quot;다른 파이썬 라이브러리의 구현&quot;&gt;&lt;/a&gt;다른 파이썬 라이브러리의 구현&lt;br&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;코드는 다른 파이썬 구현에 불리하지 않은 방식으로 작성되어야 합니다. &lt;/p&gt;
&lt;p&gt;다른 파이썬의 구현체들 (PyPy, Jython, IronPython, Cython, Pysco 등등) &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;예를들면, CPython에서 &lt;code&gt;a += b&lt;/code&gt; 혹은 &lt;code&gt;a = a + b&lt;/code&gt; 형태의 문자열 연결은 효율적인 구현체 이지만. &lt;br&gt;&lt;/p&gt;
&lt;p&gt;이 형태조차, CPython 에서도 특정 타입에만 통하고, 모든 구현에 나오지 않습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;따라서, CPython의 효율적인 내부 문자열 연결 구현에 너무 의존하는것은 좋지 않습니다&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;퍼포먼스가 중요한 라이브러리에서는, &lt;code&gt;&amp;#39;&amp;#39;.join()&lt;/code&gt; 형태가 대신 사용되어야 합니다 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="PEP8-Programming-Recommendations-1편"><a href="#PEP8-Programming-Recommendations-1편" class="headerlink" title="PEP8 Programming Recommendations - 1편"></a>PEP8 Programming Recommendations - 1편</h2><br><br><p><strong>프로그래밍 권장 사항들 - 1편입니다</strong></p><br><br><h2 id="다른-파이썬-라이브러리의-구현"><a href="#다른-파이썬-라이브러리의-구현" class="headerlink" title="다른 파이썬 라이브러리의 구현"></a>다른 파이썬 라이브러리의 구현<br></h2><p><br><br></p><p>코드는 다른 파이썬 구현에 불리하지 않은 방식으로 작성되어야 합니다. </p><p>다른 파이썬의 구현체들 (PyPy, Jython, IronPython, Cython, Pysco 등등) </p><br><p>예를들면, CPython에서 <code>a += b</code> 혹은 <code>a = a + b</code> 형태의 문자열 연결은 효율적인 구현체 이지만. <br></p><p>이 형태조차, CPython 에서도 특정 타입에만 통하고, 모든 구현에 나오지 않습니다. </p><br><p>따라서, CPython의 효율적인 내부 문자열 연결 구현에 너무 의존하는것은 좋지 않습니다<br></p><p><br><br></p><blockquote><p>퍼포먼스가 중요한 라이브러리에서는, <code>&#39;&#39;.join()</code> 형태가 대신 사용되어야 합니다 </p></blockquote><p><br><br></p><a id="more"></a><br><h2 id="Singletons-에-대한-비교"><a href="#Singletons-에-대한-비교" class="headerlink" title="Singletons 에 대한 비교 "></a>Singletons 에 대한 비교 <br></h2><br><p>None 같은 singletons에 대한 비교는 항상 <code>is</code> 혹은 <code>is not</code> 을 사용합니다. 절대 <code>=</code>를 사용하지 않습니다. </p><br><blockquote><p>파이썬에서 singletons 는 </p><p>창의적인 디자인 패턴으로, 같은 종류의 객체만 존재하고 </p><p>다른 코드에게 단일 엑세스 지점을 제공합니다. </p><br><p>singletons 는 전역 변수들과 같은 장점과 단점을 가지고 있습니다. </p><p>굉장히 유용하지만, 코드의 모듈화를 떨어트립니다. </p></blockquote><br><p>if 를 사용할때 if x 가 진짜 if x is not None 일것임을 알고 써야합니다<br><br> (예를들어, 하나의 변수 혹은 인자가 기본값이 None 으로 다른 값에 설정이 되어 있을때. 컨테이너 같은 값들은 이미 타입을 가지고 있을수 있습니다. 이럴경우, 정확한 불리언 값을 얻을수가 없게 됩니다. 따라서, 불리언으로 테스트 하면 False 가 나옵니다.  )</p><p><br><br></p><h2 id="is-not-연산자를-not-…-is-대신-사용합니다"><a href="#is-not-연산자를-not-…-is-대신-사용합니다" class="headerlink" title="is not 연산자를 not … is 대신 사용합니다."></a>is not 연산자를 not … is 대신 사용합니다.</h2><p><br><br></p><p>두가지 표현 모두 기능적으로 똑같지만, 전자가 더 가독서이 좋아서 선호됩니다.<br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"><span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> foo <span class="keyword">is</span> <span class="literal">None</span>:</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="6가지-비교연산"><a href="#6가지-비교연산" class="headerlink" title="6가지 비교연산"></a>6가지 비교연산</h2><br><br><p>특정 비교연산을 하기 위해서 다른 코드를 의존하기 보다는, </p><p>6가지의 모든 연산을 구현하는게 좋습니다 </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__eq__</span><br><span class="line">__ne__</span><br><span class="line">__lt__</span><br><span class="line">__le__</span><br><span class="line">__gt__</span><br><span class="line">__ge__</span><br></pre></td></tr></table></figure><br><br><p><code>funtools.total_ordering()</code>데코레이터는 현재 놓치고 있는 비교 방법을 생성하는 툴을 제공합니다<br></p><br><blockquote><p>PEP207을 참조하면, 파이썬 인터프리터에는 반사 규칙이 존재합니다<br></p></blockquote><p>반사규칙에 의해서, 인터프리터는 아래의 형태로 값을 바꿀수 있습니다. </p><br><p><code>y &gt; x</code>를 <code>x &lt; y</code> 로 </p><p><code>y &gt;= x</code> 를 <code>x &lt;= y</code> 로 </p><p><code>x == y</code> 그리고 <code>x != y</code>같은 인자들을 바꿀수 있습니다. </p><br><p><code>sort()</code>함수와 <code>min()</code> 연산들은 <code>&lt;</code>  을 사용하고, <code>max()</code>함수는 <code>&gt;</code>를 사용합니다. </p><p><br>그렇지만, 모든 6개의 연산을 사용하여, 최대한 혼란을 일으키지 않게 하는것이 제일 좋습니다. </p><br><br><h2 id="lambda-를-사용한-수식보다는-def구문을-사용합니다"><a href="#lambda-를-사용한-수식보다는-def구문을-사용합니다" class="headerlink" title="lambda 를 사용한 수식보다는 def구문을 사용합니다"></a><code>lambda</code> 를 사용한 수식보다는 <code>def</code>구문을 사용합니다</h2><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">2</span>*x</span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..<br></h2><br><p>프로그래밍에 대한 권장 사항들인데. </p><p><br>컨셉이 상당히 깊게 느껴집니다. <br>위 내용을 모두 알아들을 만큼의 레벨까지 프로그래밍 공부가 완료되지 않았기 때문에. </p><br><p>어떤것은 이해가 전혀 가지 않기도 하고, 표현도 어색합니다<br></p><br><p>몇번이나 다짐하지만, 좀더 깊게 공부를 한 다음에 다시 봐야 할것 같습니다. </p><br><br><p><br><br><br><br><br><br><br><br><br><br><br></p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/08/PEP8-Programming-Recommendations-1%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Naming Conventions - 4편</title>
      <link>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-4%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-4%ED%8E%B8/</guid>
      <pubDate>Tue, 07 Apr 2020 09:38:46 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;파이썬-Naming-Convention-4편&quot;&gt;&lt;a href=&quot;#파이썬-Naming-Convention-4편&quot; class=&quot;headerlink&quot; title=&quot;파이썬 Naming Convention - 4편&quot;&gt;&lt;/a&gt;파이썬 Naming Convention - 4편&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;Public-and-Internal-Interface&quot;&gt;&lt;a href=&quot;#Public-and-Internal-Interface&quot; class=&quot;headerlink&quot; title=&quot;Public and Internal Interface&quot;&gt;&lt;/a&gt;Public and Internal Interface&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;이전 버전과 호환성을 보장하는것은 &lt;/p&gt;
&lt;p&gt;오직 퍼블릭 인터페이스에만 적용됩니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;따라서, 사용자들은 퍼블릭 인터페이스와 내부 인터페이스를 잘 구분하는것이 중요합니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;public interface (공용 인터페이스)&lt;/strong&gt;는 독립적인 소프트웨어 엔티티가 상호 작용하는 논리적 지점입니다. 엔티니는 단일 컴퓨터, 네트워크 또는 다양한 토폴로지에서 서로 상호 작용할수 있습니다. 상호 작용을 계속 하려면, 퍼블릭 이너페이스가 안정적이여야 하고, 향후 변경 및 개선 및 사용중단을 지원하도록 잘 설계되어야 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="파이썬-Naming-Convention-4편"><a href="#파이썬-Naming-Convention-4편" class="headerlink" title="파이썬 Naming Convention - 4편"></a>파이썬 Naming Convention - 4편</h2><br><br><h2 id="Public-and-Internal-Interface"><a href="#Public-and-Internal-Interface" class="headerlink" title="Public and Internal Interface"></a>Public and Internal Interface</h2><br><br><blockquote><p>이전 버전과 호환성을 보장하는것은 </p><p>오직 퍼블릭 인터페이스에만 적용됩니다. </p></blockquote><br><br><p>따라서, 사용자들은 퍼블릭 인터페이스와 내부 인터페이스를 잘 구분하는것이 중요합니다. </p><br><br><p><strong>public interface (공용 인터페이스)</strong>는 독립적인 소프트웨어 엔티티가 상호 작용하는 논리적 지점입니다. 엔티니는 단일 컴퓨터, 네트워크 또는 다양한 토폴로지에서 서로 상호 작용할수 있습니다. 상호 작용을 계속 하려면, 퍼블릭 이너페이스가 안정적이여야 하고, 향후 변경 및 개선 및 사용중단을 지원하도록 잘 설계되어야 합니다. </p><br><br><a id="more"></a><h2 id="문서화가-되어-있는-인터페이스"><a href="#문서화가-되어-있는-인터페이스" class="headerlink" title="문서화가 되어 있는 인터페이스"></a>문서화가 되어 있는 인터페이스</h2><br><br><p>보통 문서화가 되어 있는 인터페이스는 퍼블릭 인터페이스라고 봅니다. </p><br><p>만약, 문서에 명시적으로 인터페이스가 이전 버전과 호환성을 고려하지 않아도 되는 잠정적 혹은 내부 인터페이스라고 선언이 되어 있는 경우에는 퍼블릭 인터페이스라고 보지 않습니다. </p><br><br><p>모든 문서화 되지 않은 인터페이스들은 내부 인터페이스인것으로 추정합니다. </p><br><br><h2 id="all-속성"><a href="#all-속성" class="headerlink" title="__all__ 속성"></a><code>__all__</code> 속성</h2><br><br><p>모듈은 <code>__all__</code>을 사용하여, 명시적으로 퍼블릭 API 안에 이름을 선언합니다. </p><p><br><code>__all__</code>을 비어있는 리스트에 설정함으로써, 모듈이 퍼블릭 API 를 가지고 있지 않다고 표시합니다. </p><p><br>만약 어떤 네임공간의 사용이 내부적으로 사용으로 보일때는, 인터페이스도 internal interface로 간주합니다. </p><br><br><h2 id="Imported-Names"><a href="#Imported-Names" class="headerlink" title="Imported Names"></a>Imported Names</h2><br><br><p>가져온 이름들은 구현할때 세부 사항으로 간주되어야 합니다<br></p><p>다른 모듈들은 포함된 모듈의 API 에서 명시적으로 문서화 되어 있는 부분이 아닌 이상, </p><p>가져온 이름에 대한 간접 엑세스에 의존해서는 안됩니다. </p><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><br><p>아직 public interface 와 internal interface  를 고려할만큼, 공부 수준이 높지 않아서. </p><p>Interface 관련 내용은 봐도 잘 모르겠군요. </p><br><p>나중에 수준이 좀 더 올르면, 그때 다시 볼 예정입니다.<br></p><br><br><br><p><br><br></p><br><br><br><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-4%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Naming Conventions -3편</title>
      <link>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-3%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-3%ED%8E%B8/</guid>
      <pubDate>Tue, 07 Apr 2020 06:37:50 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;파이썬-Naming-Convention-3-편&quot;&gt;&lt;a href=&quot;#파이썬-Naming-Convention-3-편&quot; class=&quot;headerlink&quot; title=&quot;파이썬 Naming Convention - 3 편&quot;&gt;&lt;/a&gt;파이썬 Naming Convention - 3 편&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;Presriptive-Naming-Convention-Cont&quot;&gt;&lt;a href=&quot;#Presriptive-Naming-Convention-Cont&quot; class=&quot;headerlink&quot; title=&quot;Presriptive: Naming Convention (Cont.)&quot;&gt;&lt;/a&gt;Presriptive: Naming Convention (Cont.)&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;지난 포스팅에 이어, Prescriptive Naming Convention 을 이어갑니다 &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;Desigining-for-Interface&quot;&gt;&lt;a href=&quot;#Desigining-for-Interface&quot; class=&quot;headerlink&quot; title=&quot;Desigining for Interface&quot;&gt;&lt;/a&gt;Desigining for Interface&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;인터페이스를 위한 설계에 대한 내용입니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;언제나&lt;/p&gt;
&lt;p&gt;클래스의 메써드와 인스턴스 변수들이&lt;/p&gt;
&lt;p&gt;퍼블릭값일지 아닐지에 대한 결정을 해야합니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;결정하기가 쉽지 않다면, &lt;code&gt;non-public&lt;/code&gt; 값을 선택 합니다. &lt;br&gt;&lt;/p&gt;
&lt;p&gt;나중에 &lt;code&gt;non-public&lt;/code&gt;을 &lt;code&gt;public&lt;/code&gt;으로 바꾸는게, &lt;code&gt;public&lt;/code&gt;을 &lt;code&gt;non-public&lt;/code&gt;으로 지정하는것보다 쉽습니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;Public-vs-Non-Public-Attributes&quot;&gt;&lt;a href=&quot;#Public-vs-Non-Public-Attributes&quot; class=&quot;headerlink&quot; title=&quot;Public vs Non-Public Attributes&quot;&gt;&lt;/a&gt;Public vs Non-Public Attributes&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;Public attributs&lt;/code&gt; (퍼블릭 속성)&lt;/strong&gt;은 대외적으로 여러분들과 관계없는 클라이언트들이 클래스를 사용할것이 예상될때 사용합니다.&lt;/p&gt;
&lt;br&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;Non-ublic attributs&lt;/code&gt; (논 퍼블릭 속성)&lt;/strong&gt;은 제 3자에 의해서 사용되지 않을때 사용하는 속성들입니다. &lt;code&gt;non-public&lt;/code&gt;속성들은 나중에 수정되거나 삭제될수 있고. 수정이나 삭제에가 되지 않는다는 보장은 없습니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="파이썬-Naming-Convention-3-편"><a href="#파이썬-Naming-Convention-3-편" class="headerlink" title="파이썬 Naming Convention - 3 편"></a>파이썬 Naming Convention - 3 편</h2><br><br><h2 id="Presriptive-Naming-Convention-Cont"><a href="#Presriptive-Naming-Convention-Cont" class="headerlink" title="Presriptive: Naming Convention (Cont.)"></a>Presriptive: Naming Convention (Cont.)</h2><br><br><p>지난 포스팅에 이어, Prescriptive Naming Convention 을 이어갑니다 </p><br><br><h2 id="Desigining-for-Interface"><a href="#Desigining-for-Interface" class="headerlink" title="Desigining for Interface"></a>Desigining for Interface</h2><br><br><p>인터페이스를 위한 설계에 대한 내용입니다. </p><br><blockquote><p>언제나</p><p>클래스의 메써드와 인스턴스 변수들이</p><p>퍼블릭값일지 아닐지에 대한 결정을 해야합니다. </p></blockquote><br><p>결정하기가 쉽지 않다면, <code>non-public</code> 값을 선택 합니다. <br></p><p>나중에 <code>non-public</code>을 <code>public</code>으로 바꾸는게, <code>public</code>을 <code>non-public</code>으로 지정하는것보다 쉽습니다. </p><br><br><h2 id="Public-vs-Non-Public-Attributes"><a href="#Public-vs-Non-Public-Attributes" class="headerlink" title="Public vs Non-Public Attributes"></a>Public vs Non-Public Attributes</h2><br><br><p><strong><code>Public attributs</code> (퍼블릭 속성)</strong>은 대외적으로 여러분들과 관계없는 클라이언트들이 클래스를 사용할것이 예상될때 사용합니다.</p><br><p><strong><code>Non-ublic attributs</code> (논 퍼블릭 속성)</strong>은 제 3자에 의해서 사용되지 않을때 사용하는 속성들입니다. <code>non-public</code>속성들은 나중에 수정되거나 삭제될수 있고. 수정이나 삭제에가 되지 않는다는 보장은 없습니다. </p><br><br><a id="more"></a><blockquote><p>Public 의 반대말인 Private 이라는 단어는 쓰지 않습니다.</p><p>왜냐하면, 파이썬에서는 사실 어떤 속성도 private 속성을 가질수가 없습니다. </p></blockquote><br><br><p>public 과 non-public 외에 또다른 속성 카테고리는 서브클래스 API (주로 <code>protected</code> 보호된속성) 입니다.</p><br><br><p><strong>어떤 클래스들은 상속 혹은 확장 혹은 클래스의 동작이 수정되게끔 설계되어 있습니다</strong><br></p><p><strong>이런 클래스들을 설계할때는, 아래 사항들을 명시적으로 결정해야 합니다.</strong></p><br><ul><li>어떤 속성들을 public 으로 지정할지 </li><li>어떤 부분들이 서브클래스 API 가 될것인지 </li><li>어떤게 실질적으로 베이스 클래스로 사용될지 </li></ul><br><br><h2 id="파이써닉한-스타일-가이드라인"><a href="#파이써닉한-스타일-가이드라인" class="headerlink" title="파이써닉한 스타일 가이드라인"></a>파이써닉한 스타일 가이드라인</h2><p><br><br></p><p><strong>이런점을 염두에 두고, 파이써닉한 가이드라인은 아래와 같습니다</strong></p><br><br><ul><li>public attributes (퍼블릭 속성)들은 맨앞에 언더스코어를 가지면 안됩니다.</li><li>만일 public attribute 이름이 예약된 키워드와 충돌할때는, 속성이름 뒤에 하나의 언더스코어를 붙입니다. </li><li>단순한 퍼블릭 데이터 속성들은, 속성 이름을 노출하는게 제일 좋습니다</li><li>만일, 당신의 클래스가 서브클래스가 될 의도가 있고, 사용하지 않게 하고 싶은 속성들이 있다면, 이름을 지을때 언더스코어 2개를 앞에 붙이고, 뒤에는 붙여주지 않습니다 (name mangling 참조) </li></ul><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><br><p>아직까지는 subclass, public 혹은 private 속성들을 생각하게 될만큼 복잡한 코드를 다루지 않아서. <br></p><p>위의 가이드라인이 이해가 잘 가지 않습니다. </p><br><p>나중에 복잡한 클래스를 설계하게 되면, 그때 다시와서 봐야 할것 같네요.</p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-3%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Naming Conventions - 2편</title>
      <link>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-2%ED%8E%B8/</guid>
      <pubDate>Tue, 07 Apr 2020 04:18:04 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;파이썬-Naming-Convention-2편&quot;&gt;&lt;a href=&quot;#파이썬-Naming-Convention-2편&quot; class=&quot;headerlink&quot; title=&quot;파이썬 Naming Convention - 2편&quot;&gt;&lt;/a&gt;파이썬 Naming Convention - 2편&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;Prescriptive: Naming Conventions&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;타이틀이 prescriptive: Naming Conventions 인데. Prescriptive 의 뜻은 규범 혹은 처방등의 의미로 쓰입니다.&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이름짓기에 관한 처방 혹은 규범이라는 뜻이 되겠네요.&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;Names-to-Avoid-피해야할-이름들&quot;&gt;&lt;a href=&quot;#Names-to-Avoid-피해야할-이름들&quot; class=&quot;headerlink&quot; title=&quot;Names to Avoid (피해야할 이름들)&quot;&gt;&lt;/a&gt;Names to Avoid (피해야할 이름들)&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;절대로 피해야 할 변수명은, 아래와 같습니다.  &lt;/p&gt;
&lt;br&gt;

&lt;ul&gt;
&lt;li&gt;소문자 엘&lt;code&gt;l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;대문자 오 &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;대문자 아이 &lt;code&gt;I&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;l (엘), O(오), I(아이)&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이 문자들은, 숫자 1과 0 하고 구분이 잘 안가기 때문에 사용하는것을 피해야 합니다.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;h2 id=&quot;ASCII-호환&quot;&gt;&lt;a href=&quot;#ASCII-호환&quot; class=&quot;headerlink&quot; title=&quot;ASCII 호환&quot;&gt;&lt;/a&gt;ASCII 호환&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;파이썬 스탠다드 라이브러리에서 사용되는 식별자들은 ASCII 호환이 되어야 합니다. &lt;br&gt;&lt;/p&gt;
&lt;p&gt;이 부분은, PEP3131에 나와있습니다.&lt;br&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="파이썬-Naming-Convention-2편"><a href="#파이썬-Naming-Convention-2편" class="headerlink" title="파이썬 Naming Convention - 2편"></a>파이썬 Naming Convention - 2편</h2><br><br><p><strong>Prescriptive: Naming Conventions</strong><br><br><br></p><p>타이틀이 prescriptive: Naming Conventions 인데. Prescriptive 의 뜻은 규범 혹은 처방등의 의미로 쓰입니다.<br><br></p><p>이름짓기에 관한 처방 혹은 규범이라는 뜻이 되겠네요.<br><br></p><h2 id="Names-to-Avoid-피해야할-이름들"><a href="#Names-to-Avoid-피해야할-이름들" class="headerlink" title="Names to Avoid (피해야할 이름들)"></a>Names to Avoid (피해야할 이름들)</h2><br><p>절대로 피해야 할 변수명은, 아래와 같습니다.  </p><br><ul><li>소문자 엘<code>l</code></li><li>대문자 오 <code>O</code></li><li>대문자 아이 <code>I</code></li></ul><br><blockquote><p>l (엘), O(오), I(아이)<br></p><p>이 문자들은, 숫자 1과 0 하고 구분이 잘 안가기 때문에 사용하는것을 피해야 합니다.<br></p></blockquote><br><h2 id="ASCII-호환"><a href="#ASCII-호환" class="headerlink" title="ASCII 호환"></a>ASCII 호환</h2><br><p>파이썬 스탠다드 라이브러리에서 사용되는 식별자들은 ASCII 호환이 되어야 합니다. <br></p><p>이 부분은, PEP3131에 나와있습니다.<br><br></p><a id="more"></a><br><br><h2 id="Package-and-Module-Names-패키지와-모듈-이름"><a href="#Package-and-Module-Names-패키지와-모듈-이름" class="headerlink" title="Package and Module Names(패키지와 모듈 이름)"></a>Package and Module Names(패키지와 모듈 이름)</h2><br><p>모듈명은 짧아야 하고, 모든 문자가 소문자여야 합니다. </p><br><p>가독성이 향상될수 있을 경우, 모듈 이름에 언더스코어를 붙여도 됩니다.</p><br><p>파이썬 패키지 이름도 짧아야 하는건 마찬가지이고, 모든 문자가 소문자여야 하지만<br></p><p>패키지에는 언더스코어의 사용은 권장되지 않습니다. </p><p><br><br></p><p>C나 C++ 로 쓰여져 있는 확장 모듈이 파이썬 모듈과 같이 동작하여 고급의 인터페이스를 제공할때에는, <br></p><p>C / C++ 모듈 맨앞에 언더스코어를 붙입니다 (예, _socket)<br><br></p><br><h2 id="Class-Names-클래스명"><a href="#Class-Names-클래스명" class="headerlink" title="Class Names(클래스명)"></a>Class Names(클래스명)</h2><p><br><br></p><blockquote><p>클래스의 이름을 지을때는 보통 <code>CapWords</code> 원칙을 따릅니다</p></blockquote><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CapWords 의 예시 </span></span><br><span class="line"><span class="comment"># class 이름에서 각 용어의 첫문자만 대문자로 표시 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentPackage</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeBenefits</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">salary_remuneration</span><span class="params">()</span>:</span> </span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><br><br><p>인터페이스가 문서화되어 있고 클래스가 호출용도로만 사용될 경우에는, 함수명을 짓는 방법과 동일하게 사용되어도 괜찮습니다. <br><br><br></p><p>빌트인 (예, 내장함수, 내장클래스, 내장모듈) 이름들을 짓는데에는 별도의 규칙이 존재합니다.<br></p><p>대부분의 빌트인 이름들은, 하나의 단어로 되어 있습니다. <br>한가지 이상의 단어가 사용되는 예외가 생길때에는, 기본적으로 <code>CapWords</code> 규칙을 따릅니다. <br><br><br></p><h2 id="Type-Variable-Names-타입-변수-이름"><a href="#Type-Variable-Names-타입-변수-이름" class="headerlink" title="Type Variable Names (타입 변수 이름)"></a>Type Variable Names (타입 변수 이름)</h2><p><br><br></p><p>type variables (타입변수)의 이름은 PEP484에 소개되어 있습니다. </p><br><p>보통 CapWords 규칙을 사용하고, 짧은이름으로 짓는게 권장됩니다<br><br><br></p><p>covariant(공변) 과 contravariant(반변) 동작을 선언할때에는, 변수에 접미사를 붙이는게 권장됩니다. <br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar </span><br><span class="line"></span><br><span class="line">VT_co = TypeVar(<span class="string">'VT_co'</span>, covariant=<span class="literal">True</span>)</span><br><span class="line">KT_contra = TypeVar(<span class="string">'KT_contra'</span>, contravariant=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="Exception-Names-예외-이름"><a href="#Exception-Names-예외-이름" class="headerlink" title="Exception Names (예외 이름)"></a>Exception Names (예외 이름)</h2><p><br><br></p><p>예외처리 상황에서, 예외사항은 하나의 클래스 형태가 됩니다. </p><p><br>따라서, 클래스명을 짓는 원칙이 여기에 적용됩니다. <code>예외명</code>뒤에 <code>Error</code> 라는 접미사를 예외명에 붙여야 합니다<br><br></p><h2 id="Global-Variable-Names-전역변수명"><a href="#Global-Variable-Names-전역변수명" class="headerlink" title="Global Variable Names (전역변수명)"></a>Global Variable Names (전역변수명)</h2><p><br><br></p><p>전역변수가 하나의 모듈 안에서만 사용된다고 가정할때, 전역 변수명을 짓는 방법은 함수명을 짓는것과 동일합니다<br></p><p><code>import</code> 함수를 사용하여 가져가야 하는 모듈들은 <code>__all__</code> 을 사용해서, 전역변수를 가져가는것을 막을수 있습니다. 혹은, 언더스코어를 접두사에 붙여서 전역변수가 공유값이 아니라는것을 표시할수 있습니다. <br><br><br></p><h2 id="Function-and-Variable-Names"><a href="#Function-and-Variable-Names" class="headerlink" title="Function and Variable Names"></a>Function and Variable Names</h2><p><br><br></p><p>함수명은 소문자로 되어 있어야 하고, 함수명에 쓰이는 단어들은 가독성의 향상을 위해 언더스코어로 분리되어 있어야 합니다. <br></p><br><p>변수명을 지을때도 함수명을 짓는것과 동일한 방식으로 짓습니다 <br><br></p><blockquote><p>함수이름은, </p><p>소문자로만 이루어져 있고, 가독성을 위해 각 단어들을 언더스코어로 분리합니다<br></p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">love_python</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 변수명 </span></span><br><span class="line"><span class="comment"># 소문자로만 이루어져 있고, 각 단어들을 _로 구분해 줍니다 </span></span><br><span class="line"></span><br><span class="line">top_student_number = <span class="number">1548</span></span><br></pre></td></tr></table></figure><br><p>함수명이나 변수명을 지을때 위 방식과 다르게 <code>mixedCase</code> 가 사용될수도 있습니다만, </p><br><p><code>mixedCase</code>사용은 해당 스타일이 이미 적용된 코드에서만 사용합니다 (예, threading.py) </p><br><br><h2 id="Method-Names-and-Instance-Variables"><a href="#Method-Names-and-Instance-Variables" class="headerlink" title="Method Names and Instance Variables"></a>Method Names and Instance Variables</h2><br><br><p>메써드 이름과 인스턴스 변수들도 함수명을 짓는 방식과 동일합니다. </p><p>소문자로 짓고, 각 단어들은 <code>_</code>로 분리해 줍니다. </p><br><p>퍼블릭 값이 아닌 메써드와 인스턴스 변수들은 맨앞에 언더스코어 하나를 붙여줍니다 </p><br><p>서브클래스들과 이름들이 충돌하는것을 피하기 위해서는, </p><br><p>파이썬의 <code>name mangling</code> 룰에 따라서, 맨앞에 두개의 언더스코어를 붙여줍니다. </p><br><br><h2 id="Constants-상수"><a href="#Constants-상수" class="headerlink" title="Constants (상수)"></a>Constants (상수)</h2><br><br><blockquote><p>constants (상수) 이름은, </p><p>모든 문자가 대문자로 되어 있고, 각 단어들은 언더스코어를 사용해 분리합니다.</p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Constants </span></span><br><span class="line"></span><br><span class="line">MAX_OVERFLOW = <span class="number">10</span> </span><br><span class="line">TOTAL = <span class="number">500</span></span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p><br><br></p><p>Naming Convention 의 내용이 좀 깁니다. <br></p> <br><blockquote><p>변수명, 함수명, 클래스명 들의 이름을 잘 짓는건 굉장히 중요합니다. </p><p>내가 정의한 이름들이 다른 사람들이 봤을때 </p><p>읽기 편하고 의도를 파악하기 쉽게 지어야 합니다. </p></blockquote><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/07/PEP8-Naming-Conventions-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Naming Conventions - 1편</title>
      <link>http://djangojeng-e.github.io/2020/04/06/PEP8-Naming-Conventions-1%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/06/PEP8-Naming-Conventions-1%ED%8E%B8/</guid>
      <pubDate>Mon, 06 Apr 2020 05:38:37 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;파이썬-Naming-Convention&quot;&gt;&lt;a href=&quot;#파이썬-Naming-Convention&quot; class=&quot;headerlink&quot; title=&quot;파이썬 Naming Convention&quot;&gt;&lt;/a&gt;파이썬 Naming Convention&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;파이썬에서의 이름짓기 규칙은 조금 지저분합니다. 따라서, 우리는 이름짓기를 완벽하게 일반화하여 일관성있게 할수가 없습니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;그렇지만, PEP8 에서는 현재 권장되는 이름짓기 규칙과 naming standard 를 제시합니다&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;새로운 모듈과 패키지들은&lt;/p&gt;
&lt;p&gt;PEP8에 나와있는 naming convention 대로 이름이 지어져야 합니다. &lt;/p&gt;
&lt;p&gt;하지만&lt;/p&gt;
&lt;p&gt;존재하고 있는 라이브러리들은 이미 다른 스타일들을 가지고 있기 때문에, &lt;/p&gt;
&lt;p&gt;내부적으로 일관성을 정하여 이름을 사용합니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="파이썬-Naming-Convention"><a href="#파이썬-Naming-Convention" class="headerlink" title="파이썬 Naming Convention"></a>파이썬 Naming Convention</h2><br><br><p>파이썬에서의 이름짓기 규칙은 조금 지저분합니다. 따라서, 우리는 이름짓기를 완벽하게 일반화하여 일관성있게 할수가 없습니다. </p><br><br><p><strong>그렇지만, PEP8 에서는 현재 권장되는 이름짓기 규칙과 naming standard 를 제시합니다</strong></p><br><br><blockquote><p>새로운 모듈과 패키지들은</p><p>PEP8에 나와있는 naming convention 대로 이름이 지어져야 합니다. </p><p>하지만</p><p>존재하고 있는 라이브러리들은 이미 다른 스타일들을 가지고 있기 때문에, </p><p>내부적으로 일관성을 정하여 이름을 사용합니다. </p></blockquote><br><a id="more"></a><br><h2 id="Overriding-Principle"><a href="#Overriding-Principle" class="headerlink" title="Overriding Principle"></a>Overriding Principle<br></h2><br><p>퍼블릭 API 에서 사용자에게 보이는 이름들은 실행과 이행에 따라 지어진 이름보다. 사용처에 따라서 이름을 지어줍니다. </p><br><h2 id="Descriptive-Naming-Styles"><a href="#Descriptive-Naming-Styles" class="headerlink" title="Descriptive: Naming Styles"></a>Descriptive: Naming Styles</h2><br><br><p>우리가 코드로 이름을 써줄때, 굉장히 많은 스타일들이 존재합니다. </p><p>함수, 변수, 클래스, 매써드들의 이름을 적을때 쓰이는 스타일들은 여러가지가 존재합니다 </p><br><p><strong>아래 테이블로 정리 해봤습니다</strong></p><br><br><table><thead><tr><th><strong>Naming Style</strong></th><th>비고</th></tr></thead><tbody><tr><td>b (single lowercase letter)</td><td>소문자 1글자</td></tr><tr><td>B (single Uppercase letter)</td><td>대문자 1글자</td></tr><tr><td>lowercase</td><td>소문자로만 이루어진 이름</td></tr><tr><td>lower_case_with_underscore</td><td>소문자와 언더스코어가 조합된 이름</td></tr><tr><td>UPPERCASE</td><td>대문자로만 이루어진 이름</td></tr><tr><td>UPPER_CASE_WITH_UNDERSCORES</td><td>대문자와 언더스코어로 조합된 이름</td></tr><tr><td>CapitalizedWords</td><td>단어의 첫글자들을 대문자로 표시하는 이름 (Carmel Case)</td></tr><tr><td>mixedCase</td><td>첫번째단어는 소문자로, 뒤에 오는 단어들은 대문자로 표시</td></tr><tr><td>Captialized_Words_With_Underscores</td><td>단어의 첫글자들만 대문자로 표시하고 언더스코어로 이어지는 이름 (못생김!)</td></tr></tbody></table><br><br><p>추가로, 파이썬에는 많이 존재 하진 않지만 짧고 고유한 prefix 를 소속 그룹과 관련하여 이름에 붙이는 방식도 있습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.start()</span><br><span class="line"><span class="comment"># os.start() 함수는 튜플을 반환하는데 </span></span><br><span class="line"><span class="comment"># 튜플에 들어있는 이름들이 prefix (접두사) 를 포함하고 있습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 예) st_mode, st_size, st_mtime</span></span><br></pre></td></tr></table></figure><br><br><p>X11 라이브러리는 모든 퍼블릭 함수 앞에 <code>X</code>를 붙입니다. 파이썬에서는 보통 이런 스타일을 불필요하게 생각합니다. <br>왜냐하면, 모든 속성과 메써드들의 이름들은 객체와 함께 접두사가 붙고,<br>함수 이름은 모듈 이름으로 접두사가 붙기 때문입니다. </p><br><br><h2 id="언더스코어를-사용하는-특수한-형태"><a href="#언더스코어를-사용하는-특수한-형태" class="headerlink" title="언더스코어를 사용하는 특수한 형태"></a>언더스코어를 사용하는 특수한 형태</h2><br><br><table><thead><tr><th>Speical form</th><th>사용목적</th><th>예시</th></tr></thead><tbody><tr><td><code>_single_leading_underscore</code></td><td>내부적으로 사용</td><td><code>import *</code>을 실행시, <code>_</code>로 시작하는 객체는 가져오지 않습니다.</td></tr><tr><td><code>single_trailing_underscore_</code></td><td>파이썬 키워드와 겹치지 않기 위해 사용</td><td><code>Tkinter.Toplevel(master,class_&lt;br /&gt;=&#39;ClassName&#39;)</code></td></tr><tr><td><code>__double_leading_underscore</code></td><td>클래스 속성과 네임 멩글링</td><td>아래 <code>class Car</code> 예시 참조</td></tr><tr><td><code>__double_leading_and_trailing__</code></td><td>매직 메서드 혹은 속성</td><td><code>__init__</code>, <code>__import__</code> , <code>__file__</code></td></tr></tbody></table><br><blockquote><p>자세한 설명은 아래 코드를 참조</p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _ 하나가 맨앞에 붙는 경우 </span></span><br><span class="line"><span class="comment"># 내부적으로 사용할때 사용</span></span><br><span class="line">_single_leading </span><br><span class="line"></span><br><span class="line"><span class="comment"># import * 를 하면, _로 시작하는 객체는 가져오지 않음. </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># _ 하나가 맨뒤에 붙는 경우 </span></span><br><span class="line"><span class="comment"># 파이썬 키워드와 겹치는것을 피하기 위해 사용 </span></span><br><span class="line">single_trailing_underscore_ </span><br><span class="line"></span><br><span class="line">Tkinter.Toplevel(master, class_=<span class="string">'ClassName'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># __ 두개가 맨앞에 붙는 경우 </span></span><br><span class="line"><span class="comment"># 클래스 속성과 name mangling </span></span><br><span class="line"></span><br><span class="line">__double_leading_underscore</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__canDrive = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">car = Car() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __ 두개가 앞뒤로 붙는경우 </span></span><br><span class="line"><span class="comment"># 메직메써드로 사용자가 제어하는 이름공간안에 사용</span></span><br><span class="line">__double_leading_and_trailing_underscore__ </span><br><span class="line"></span><br><span class="line">__init__</span><br><span class="line">__import__</span><br><span class="line">__file__</span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><br><p>아직까지는 이름 지을일이 많이 없고, 특수 케이스가 별로 없어서. </p><p><br>우선 이런게 있다는것을 잘 알고 넘어가면 되겠습니다. </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/06/PEP8-Naming-Conventions-1%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Comments</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-Comments/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-Comments/</guid>
      <pubDate>Sun, 05 Apr 2020 10:39:14 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Comments-주석&quot;&gt;&lt;a href=&quot;#Comments-주석&quot; class=&quot;headerlink&quot; title=&quot;Comments (주석)&quot;&gt;&lt;/a&gt;Comments (주석)&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;파이썬에서 주석에 관한 스타일 가이드 입니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;코드와 모순된 주석은 &lt;/p&gt;
&lt;p&gt;주석이 없는것보다 나쁩니다 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;코드와 모순된 주석을 달바에는 아예 달지 않는게 낫다는 얘기지요 ㅎㅎ &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;주석이 코드와 모순되지 않게 하기 위해서, &lt;Br&gt;코드가 바뀔때 주석도 같이 수정사항에 맞게 업데이트 해줘야 합니다.&lt;/strong&gt; &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;주석에 쓰이는 문장은 완성된 문장이여야 하고, 소문자로 시작하는 식별자들을 제외하곤 첫번째 단어는 대문자로 써줍니다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Comments-주석"><a href="#Comments-주석" class="headerlink" title="Comments (주석)"></a>Comments (주석)</h2><br><br><p>파이썬에서 주석에 관한 스타일 가이드 입니다. </p><br><blockquote><p>코드와 모순된 주석은 </p><p>주석이 없는것보다 나쁩니다 </p></blockquote><br><br><p>코드와 모순된 주석을 달바에는 아예 달지 않는게 낫다는 얘기지요 ㅎㅎ </p><br><br><p><strong>주석이 코드와 모순되지 않게 하기 위해서, <Br>코드가 바뀔때 주석도 같이 수정사항에 맞게 업데이트 해줘야 합니다.</strong> </p><br><p>주석에 쓰이는 문장은 완성된 문장이여야 하고, 소문자로 시작하는 식별자들을 제외하곤 첫번째 단어는 대문자로 써줍니다. </p><a id="more"></a><br><br><h2 id="Strunk-and-White-Rule"><a href="#Strunk-and-White-Rule" class="headerlink" title="Strunk and White Rule"></a>Strunk and White Rule</h2><br><br><blockquote><p>영문으로 코드를 작성할때는 Strunk and White 룰을 따릅니다.</p></blockquote><br><br><p><code>Strunk and White</code>는 영문으로 문장을 작성하시는분들이 많이 보시는건데. 아래 사이트 참고 부탁 드립니다. </p><br><p><a href="https://whatis.techtarget.com/definition/Strunks-rules" target="_blank" rel="noopener">https://whatis.techtarget.com/definition/Strunks-rules</a></p><br><br><blockquote><p>비영어권 국가에서 오신 파이썬 코더들도 </p><p>부디 주석을 영문으로 달아주세요. </p></blockquote><br><p>본인이 본인의 언어로 작성한 코드와 주석은, 대부분의 경우, <br></p><p>본인의 언어를 사용하지 않는 사람이 읽게 될 확률이 높습니다.  </p><p><br>예) 한국어로 작성된 코드와 주석은 보통, 영어를 사용하는 사람이 읽게 될 확률이 높습니다. </p><br><br><br><h2 id="Block-Comment"><a href="#Block-Comment" class="headerlink" title="Block Comment"></a>Block Comment</h2><br><br><p>보통 하나 혹은 하나 이상의 문단으로 완성된 문장들로 이루어져 있습니다. 각 문장들은 마침표로 끝납니다. </p><br><br><p>블록 커멘트는 특정 혹은 전체 코드에 적용될수 있습니다. </p><p>코드와 같은 레벨에 들여쓰기 되어 있습니다. </p><br><p>각 주석은 <code>#</code>으로 시작하고, 한칸 띄고 주석 내용이 시작합니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 이것은 주석입니다</span></span><br></pre></td></tr></table></figure><br><br><p>블록 커멘트 안에 있는 문단들은 하나의 <code>#</code>을 포함하고 있는 빈줄로 분리가 됩니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To Learn any language you must follow the below rules. </span></span><br><span class="line"><span class="comment"># 1. Know the basic syntax, data types, control structures and conditional statements.</span></span><br><span class="line"><span class="comment"># 2. Learn error handling and file I/O. </span></span><br><span class="line"><span class="comment"># 3. Read about advanced data structures. </span></span><br><span class="line"><span class="comment"># 4. Write functions and follow OOPs concepts. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To Learn Python, LEVEL 0: The Beginnings. </span></span><br><span class="line"><span class="comment"># 1. Variables. </span></span><br><span class="line"><span class="comment"># 2. Data Types. </span></span><br><span class="line"><span class="comment"># 3. Operations. </span></span><br><span class="line"><span class="comment"># 4. Conditionals.</span></span><br><span class="line"><span class="comment"># 5. Functions. </span></span><br><span class="line"><span class="comment"># 6. Step1: Learn the concepts of OOP. </span></span><br><span class="line"><span class="comment"># 7. Step2: Learn about Python's Classes and Objects. </span></span><br><span class="line"><span class="comment"># 8. Step3: Solve Python problems using OOP.</span></span><br></pre></td></tr></table></figure><br><br><h2 id="Inline-Comment"><a href="#Inline-Comment" class="headerlink" title="Inline Comment"></a>Inline Comment</h2><p><br><br></p><p>인라인 주석은 드물게 사용합니다. <br><br></p><blockquote><p>인라인 커멘트는 코드와 같은 줄에 달아주는 주석입니다. </p><p>주석을 달을 코드와 최소 2 빈공간 이상 분리되어 있어야 합니다. </p></blockquote><p><br><br></p><p><code>#</code> 을 써주고, 한칸 띄고 시작합니다. </p><br><br><p>너무 명확한 코드에는 인라인 주석을 다는것이 불필요 합니다.<br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 너무 명확한 것을 주석으로 다는 예 </span></span><br><span class="line">x = x + <span class="number">1</span><span class="comment"># Increment X </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 인라인 커멘트가 유용하게 쓰이는 예 </span></span><br><span class="line"><span class="comment"># 위의 increment 코드가 어떤 목적으로 사용하는지에 대한 주석 </span></span><br><span class="line"></span><br><span class="line">x = x + <span class="number">1</span> <span class="comment"># Compensate for border</span></span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="Document-string-Docstring"><a href="#Document-string-Docstring" class="headerlink" title="Document string (Docstring)"></a>Document string (Docstring)</h2><p><br><br></p><p>좋은 <code>docstring</code>을 작성하는 방법은 PEP257 을 참조하시면 됩니다<br><br><br></p><p>함수에 주석을 달고 싶을때 쓰는 Document String 혹은 줄여서 docstring 에 대한 내용은 아래와 같습니다<br><br></p><ul><li>모든 퍼블릭 모듈, 함수, 클래스 그리고 메써드들에는 <code>docstring</code>을 달아줍니다.</li><li>퍼블릭 메서드에는 docstring을 달아줄 필요가 없을지 모르지만, 메서드가 무엇을 하는지에 대한 주석은 달아야 합니다. (해당 주석은 def 줄 다음줄에 달아줍니다)</li></ul><br><br><p>PEP257은 좋은 docstring 의 관용적인 사용법을 다루고 있습니다.<br></p><br><blockquote><p>다수의 문장이 들어간 docstring 이 끝나는 줄에는 <code>&quot;&quot;&quot;</code>만 넣어줍니다.<br></p><p>하나의 문장만 들어간 docstring 은 docstring 의 끝에 <code>&quot;&quot;&quot;</code>를 같은줄에 넣어줍니다.<br></p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 다수의 문장으로 이루어진 docstring </span></span><br><span class="line"><span class="string">"""Return a foobang</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Optional plots says to fronbicate the bizbaz first.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 하나의 문장으로 이루어진 docstring </span></span><br><span class="line"><span class="string">"""This calculates the sum """</span></span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p><br><br></p><p>주석에 관한것을 알아보았습니다.<br></p><p>저는 사실 인라인으로 주석을 다는것을 좋아했는데.. 이점은 좀 피해야 겠네요;;; </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-Comments/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 When to Use Trailing Commas</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-When-to-Use-Trailing-Commas/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-When-to-Use-Trailing-Commas/</guid>
      <pubDate>Sun, 05 Apr 2020 10:28:40 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;언제-콤마를-뒤에-붙여야-하는가&quot;&gt;&lt;a href=&quot;#언제-콤마를-뒤에-붙여야-하는가&quot; class=&quot;headerlink&quot; title=&quot;언제 콤마를 뒤에 붙여야 하는가&quot;&gt;&lt;/a&gt;언제 콤마를 뒤에 붙여야 하는가&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;이번 포스팅은 언제 코드끝에 콤마를 붙여야 하는가에 대한 내용입니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;튜플처럼 의무화 되어 있는 콤마를 제외하고는 &lt;/p&gt;
&lt;p&gt;보통은 끝에 콤마를 붙이는것은 선택 사항입니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 좋은예 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FILES = (&lt;span class=&quot;string&quot;&gt;&#39;setup.cfg&#39;&lt;/span&gt;,)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 나쁜예 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 괄호가 없는데 뒤에 콤마를 붙이는 경우 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FILES = &lt;span class=&quot;string&quot;&gt;&#39;setup.cfg&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;

&lt;p&gt;콤마는 버전관리 시스템이 사용될때도 도움이 됩니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;그리고, 값들이 리스트 안에 들어가 있는데, 그 안에 인자나 가져올 아이템이 나중에 확장될지 모를때 도움이 됩니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;&lt;strong&gt;코드를 보면서 이해하자면&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="언제-콤마를-뒤에-붙여야-하는가"><a href="#언제-콤마를-뒤에-붙여야-하는가" class="headerlink" title="언제 콤마를 뒤에 붙여야 하는가"></a>언제 콤마를 뒤에 붙여야 하는가</h2><br><br><p>이번 포스팅은 언제 코드끝에 콤마를 붙여야 하는가에 대한 내용입니다. </p><br><br><blockquote><p>튜플처럼 의무화 되어 있는 콤마를 제외하고는 </p><p>보통은 끝에 콤마를 붙이는것은 선택 사항입니다. </p></blockquote><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line">FILES = (<span class="string">'setup.cfg'</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"><span class="comment"># 괄호가 없는데 뒤에 콤마를 붙이는 경우 </span></span><br><span class="line">FILES = <span class="string">'setup.cfg'</span>,</span><br></pre></td></tr></table></figure><br><p>콤마는 버전관리 시스템이 사용될때도 도움이 됩니다. </p><p><br>그리고, 값들이 리스트 안에 들어가 있는데, 그 안에 인자나 가져올 아이템이 나중에 확장될지 모를때 도움이 됩니다. </p><br><p><strong>코드를 보면서 이해하자면</strong></p><br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"><span class="comment"># 각각의 값이나 파일들 뒤에 콤마를 붙이고 다음줄로 넘어갑니다 </span></span><br><span class="line"><span class="comment"># 더이상 값이 없을때는, 바로 괄호를 닫지 않고. 다음줄에서 닫습니다. </span></span><br><span class="line"></span><br><span class="line">FILES = [</span><br><span class="line">    <span class="string">'setup.cfg'</span>,</span><br><span class="line">    <span class="string">'tox.ini'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나중에 값이나 파일이 추가될때는</span></span><br><span class="line"><span class="comment"># 다음줄에 값을 넣고 뒤에 콤마를 붙여줍니다. </span></span><br><span class="line"><span class="comment"># 그리고 다음줄에 괄호를 닫아줍니다. </span></span><br><span class="line"></span><br><span class="line">initialize(FILES,</span><br><span class="line">          error=<span class="literal">True</span>,</span><br><span class="line">          )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"><span class="comment"># 줄바꿈을 한뒤에 콤마를 넣지 않고. 끝에 나오는 콤마까지 합쳐서 한줄에 넣은 경우 </span></span><br><span class="line"></span><br><span class="line">FILES = [<span class="string">'setup.cfg'</span>, <span class="string">'tox.ini'</span>,]</span><br><span class="line">initalize(FILES, error=<span class="literal">True</span>,)</span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>콤마를 잘 붙이면, </p><p><br>인자나, 가져오는 파일들을 구분할때 시각적으로 많은 도움이 될것 같습니다. </p><br><br><p>들어가는 값이 너무 많아질때는 각각의 줄로 나누고 콤마를 붙여줍니다. </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-When-to-Use-Trailing-Commas/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Whitespace in Expressions and Statements - 2편</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-Whitespace-in-Expressions-and-Statements-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-Whitespace-in-Expressions-and-Statements-2%ED%8E%B8/</guid>
      <pubDate>Sun, 05 Apr 2020 07:26:36 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;수식과-구문안에서-빈공간-기타-권장-사항들&quot;&gt;&lt;a href=&quot;#수식과-구문안에서-빈공간-기타-권장-사항들&quot; class=&quot;headerlink&quot; title=&quot;수식과 구문안에서 빈공간 - 기타 권장 사항들&quot;&gt;&lt;/a&gt;수식과 구문안에서 빈공간 - 기타 권장 사항들&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;수식과 구문 안에 공백들에 대한 기타 권장 사항들입니다. &lt;br&gt;&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;뒤에오는-빈공간은-언제나-피해야-합니다&quot;&gt;&lt;a href=&quot;#뒤에오는-빈공간은-언제나-피해야-합니다&quot; class=&quot;headerlink&quot; title=&quot;뒤에오는 빈공간은 언제나 피해야 합니다&quot;&gt;&lt;/a&gt;뒤에오는 빈공간은 언제나 피해야 합니다&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;공백들은 보이지 않기 때문에 혼란 스러울수 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 빈공간 후에 \ 를 사용 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m the best&quot;&lt;/span&gt;  \)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m the best&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;      \&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;      &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;# 빈공간이 계속되는 줄로 세어지지 않을때, &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;# 아래 print 문에서 두번째줄은 계속되는 줄로 세어지지 않습니다. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;# 이어지는 줄이 아닌데도 괜히 사용하면, 시각적으로나 논리적으로 혼란만 초래합니다. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;      &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;print(&quot;&lt;/span&gt;I&lt;span class=&quot;string&quot;&gt;&#39;m the best&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;     &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;     &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;Binary-Operator-양쪽-사이드&quot;&gt;&lt;a href=&quot;#Binary-Operator-양쪽-사이드&quot; class=&quot;headerlink&quot; title=&quot;Binary Operator 양쪽 사이드&quot;&gt;&lt;/a&gt;Binary Operator 양쪽 사이드&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;이항 연산자 양쪽 사이드에는 항상 하나의 공백을 넣어줍니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="수식과-구문안에서-빈공간-기타-권장-사항들"><a href="#수식과-구문안에서-빈공간-기타-권장-사항들" class="headerlink" title="수식과 구문안에서 빈공간 - 기타 권장 사항들"></a>수식과 구문안에서 빈공간 - 기타 권장 사항들</h2><br><br><p>수식과 구문 안에 공백들에 대한 기타 권장 사항들입니다. <br></p><br><br><h2 id="뒤에오는-빈공간은-언제나-피해야-합니다"><a href="#뒤에오는-빈공간은-언제나-피해야-합니다" class="headerlink" title="뒤에오는 빈공간은 언제나 피해야 합니다"></a>뒤에오는 빈공간은 언제나 피해야 합니다</h2><br><br><p>공백들은 보이지 않기 때문에 혼란 스러울수 있습니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 빈공간 후에 \ 를 사용 </span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"I'm the best"</span>  \)</span><br><span class="line">print(<span class="string">"I'm the best</span></span><br><span class="line"><span class="string">      \")</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string"># 빈공간이 계속되는 줄로 세어지지 않을때, </span></span><br><span class="line"><span class="string"># 아래 print 문에서 두번째줄은 계속되는 줄로 세어지지 않습니다. </span></span><br><span class="line"><span class="string"># 이어지는 줄이 아닌데도 괜히 사용하면, 시각적으로나 논리적으로 혼란만 초래합니다. </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">print("</span>I<span class="string">'m the best"</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><br><br><h2 id="Binary-Operator-양쪽-사이드"><a href="#Binary-Operator-양쪽-사이드" class="headerlink" title="Binary Operator 양쪽 사이드"></a>Binary Operator 양쪽 사이드</h2><br><br><p>이항 연산자 양쪽 사이드에는 항상 하나의 공백을 넣어줍니다. </p><p><br><a id="more"></a></p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 연산자 앞뒤로 빈공간이 있는걸 확인 할수 있습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a = b: </span><br><span class="line"><span class="keyword">if</span> a == b: </span><br><span class="line"><span class="keyword">if</span> a &gt; b: </span><br><span class="line"><span class="keyword">if</span> a &lt; b: </span><br><span class="line"><span class="keyword">if</span> a != b: </span><br><span class="line"><span class="keyword">if</span> a &lt;= b: </span><br><span class="line"><span class="keyword">if</span> a &gt;= b:</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">in</span> b: </span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">not</span> b: </span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> b: </span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">and</span> b: </span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b:</span><br><span class="line">a += b </span><br><span class="line">a -= b</span><br></pre></td></tr></table></figure><br><br><h2 id="우선순위가-다른-연산이-사용되는-경우"><a href="#우선순위가-다른-연산이-사용되는-경우" class="headerlink" title="우선순위가 다른 연산이 사용되는 경우"></a>우선순위가 다른 연산이 사용되는 경우</h2><br><br><p>우선순위가 낮은 연산에 공백을 추가해 줍니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line">i = i + <span class="number">1</span> </span><br><span class="line">submitted += <span class="number">1</span> </span><br><span class="line">x = x*<span class="number">2</span> - <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># x*2 가 우선순위가 더 높은 연산이므로 공백을 추가해주지 않습니다. </span></span><br><span class="line"><span class="comment"># 하지만 - 연산에는 앞뒤로 공백을 추가해 줍니다. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hypot2 = x*x + y*y </span><br><span class="line">c = (a+b) * (a-b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 곱하기와 더하기가 같이 존재할때 곱셈이 덧셈보다 우선순위가 높습니다. 따라서, *에는 공백을 안줍니다. </span></span><br><span class="line"><span class="comment"># () 안에 있는 연산이 우선순위가 더 높습니다. 따라서 괄호안에 있는 + - 에는 공백을 안줍니다.</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 연산자 뒤에 공백이 하나도 없습니다. </span></span><br><span class="line">i=i+<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 연산자 주변에 공백이 양쪽에 적용되지 않았습니다. </span></span><br><span class="line">submitted +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 우선순위가 높은 연산에 공백을 잘못 적용했습니다. </span></span><br><span class="line"></span><br><span class="line">x = x * <span class="number">2</span> - <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">hypot2 = x * x + y * y </span><br><span class="line">c = ( a + b ) * ( a - b )</span><br></pre></td></tr></table></figure><br><br><h2 id="함수의-annotation"><a href="#함수의-annotation" class="headerlink" title="함수의 annotation"></a>함수의 annotation</h2><br><br><p>함수의 annotation 에서는 콜론에 대한 보통 방식을 따르고</p><p><code>-&gt;</code> 주위에 빈공간을 넣어줍니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(input: AnyStr)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">()</span> -&gt; PosInt:</span> </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(input:AnyStr)</span>:</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">()</span>-&gt;PosInt:</span></span><br></pre></td></tr></table></figure><br><br><h2 id="키워드-인자-주위의-공백"><a href="#키워드-인자-주위의-공백" class="headerlink" title="키워드 인자 주위의 공백"></a>키워드 인자 주위의 공백</h2><br><br><p>키워드 인자를 표시할때 사용되는 <code>=</code> 주위에 공백을 넣지 않습니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag=<span class="number">0.0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> magic(r=real, i=imag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag = <span class="number">0.0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> magic(r = real, i = imag)</span><br></pre></td></tr></table></figure><br><blockquote><p>그렇지만, 기본값을 가지는 인자 annotation 을 합칠때에는 </p><p><code>=</code>주위에 공백을 넣어줍니다.</p></blockquote><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 좋은예 </span><br><span class="line">def munge(sep: AnyStr &#x3D; None): ...  </span><br><span class="line">def munge(input: AnyStr, sep: AnyStr &#x3D; None, limit&#x3D;1000): ... </span><br><span class="line"></span><br><span class="line"># 나쁜예 </span><br><span class="line">def munge(input: AnyStr&#x3D;None): ... </span><br><span class="line">def munge(input: AnyStr, limit &#x3D; 1000): ...</span><br></pre></td></tr></table></figure><br><br><h2 id="같은줄에-여러개의-statement"><a href="#같은줄에-여러개의-statement" class="headerlink" title="같은줄에 여러개의 statement"></a>같은줄에 여러개의 statement</h2><br><br><p>같은줄에 여러개의 statement 를 가지는것은 권장 되지 않습니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>:</span><br><span class="line">    do_blah_thing()</span><br><span class="line">do_one()</span><br><span class="line">do_two()</span><br><span class="line">do_three()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>:do_blah_thing()</span><br><span class="line">do_one(); do_two(); do_three()</span><br></pre></td></tr></table></figure><br><br><h2 id="조건이-많은-구문에서-if-for-while"><a href="#조건이-많은-구문에서-if-for-while" class="headerlink" title="조건이 많은 구문에서 if/for/while"></a>조건이 많은 구문에서 if/for/while</h2><br><br><p>이따금씩,  if/for/while 을 같은줄에 넣는것은 괜찮습니다. 하지만, 절대로 조항이 많은 구문에서는 그렇게 쓰면 안됩니다. </p><br><p>또한, 긴줄을 지나치게 접는것도 피해야합니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>: do_blah_thing()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">1</span>st: total += x </span><br><span class="line"><span class="keyword">while</span> t&lt; <span class="number">10</span>: t = delay() </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 위 나쁜예를 고치면, 아래와 같이 고쳐집니다. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>:</span><br><span class="line">    do_blah_thing()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">1</span>st:</span><br><span class="line">    total += x </span><br><span class="line"><span class="keyword">while</span> t &lt; <span class="number">10</span>:</span><br><span class="line">    t = delay()</span><br></pre></td></tr></table></figure><br><br><h2 id="PEP에서-권장하지-않는-코드"><a href="#PEP에서-권장하지-않는-코드" class="headerlink" title="PEP에서 권장하지 않는 코드"></a>PEP에서 권장하지 않는 코드</h2><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 틀린예 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>: do_blah_thing() </span><br><span class="line"><span class="keyword">else</span>: do_non_blah_thing() </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: something() </span><br><span class="line"><span class="keyword">finally</span>: cleanup() </span><br><span class="line"></span><br><span class="line">do_one(); do_two(); do_three(long, argument, list, like, this) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>: one(); two(); three()</span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>공백에 대한 기타 권장사항들을 알아보았습니다. </p><p>공백을 권장사항에 따라 적절하게 적용해서, 더 깔끔하게 코드를 써봅시다~ </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-Whitespace-in-Expressions-and-Statements-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Whitespace in Expressions and Statements - PET PEEVES</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-Whitespace-in-Expressions-and-Statements-PET-PEEVES/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-Whitespace-in-Expressions-and-Statements-PET-PEEVES/</guid>
      <pubDate>Sun, 05 Apr 2020 06:53:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;수식과-구문안에서-빈공간&quot;&gt;&lt;a href=&quot;#수식과-구문안에서-빈공간&quot; class=&quot;headerlink&quot; title=&quot;수식과 구문안에서 빈공간&quot;&gt;&lt;/a&gt;수식과 구문안에서 빈공간&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;이번토픽은 PEP8에서 다루는 공백에 대한 포스트입니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;포스팅을 시작하기 전에, 프로그래밍언어 안에서 쓰이는 &lt;code&gt;expressions&lt;/code&gt; 이라는 단어와 &lt;code&gt;Statements&lt;/code&gt;에 대한 뜻을 먼저 알고 시작하겠습니다. &lt;/p&gt;
&lt;br&gt;

&lt;h2 id=&quot;Expressions-와-Statements&quot;&gt;&lt;a href=&quot;#Expressions-와-Statements&quot; class=&quot;headerlink&quot; title=&quot;Expressions 와 Statements&quot;&gt;&lt;/a&gt;Expressions 와 Statements&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;영어에서는 &lt;code&gt;expressions&lt;/code&gt;은 표현, &lt;code&gt;statements&lt;/code&gt;는 진술서 라는 의미로 쓰이는게 많은데. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로그래밍 세계에서 의미하는 바는 조금 다른것 같아. 아래와 같이 요약합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Expressions&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;수식, 연산식 &lt;/p&gt;
&lt;p&gt;예) 1 + 1 = 0 혹은 a = 3 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Statements&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;실행 가능한 (executable) 코드 조각. &lt;/p&gt;
&lt;p&gt;보통 여러개의 expressions 로 이루어져 있습니다. &lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 함수안에 실행 가능한 구문이 Statements 입니다. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 여러개의 Expressions 로 이루어져 있는걸 확인 할수 있습니다. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a + b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><br><br></p><h2 id="수식과-구문안에서-빈공간"><a href="#수식과-구문안에서-빈공간" class="headerlink" title="수식과 구문안에서 빈공간"></a>수식과 구문안에서 빈공간</h2><br><br><p>이번토픽은 PEP8에서 다루는 공백에 대한 포스트입니다. </p><br><br><p>포스팅을 시작하기 전에, 프로그래밍언어 안에서 쓰이는 <code>expressions</code> 이라는 단어와 <code>Statements</code>에 대한 뜻을 먼저 알고 시작하겠습니다. </p><br><h2 id="Expressions-와-Statements"><a href="#Expressions-와-Statements" class="headerlink" title="Expressions 와 Statements"></a>Expressions 와 Statements</h2><br><p>영어에서는 <code>expressions</code>은 표현, <code>statements</code>는 진술서 라는 의미로 쓰이는게 많은데. </p><p><br><br></p><p><strong>프로그래밍 세계에서 의미하는 바는 조금 다른것 같아. 아래와 같이 요약합니다.</strong></p><br><br><blockquote><p><strong>Expressions</strong></p><p>수식, 연산식 </p><p>예) 1 + 1 = 0 혹은 a = 3 </p></blockquote><br><br><blockquote><p><strong>Statements</strong></p><p>실행 가능한 (executable) 코드 조각. </p><p>보통 여러개의 expressions 로 이루어져 있습니다. <br></p></blockquote><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수안에 실행 가능한 구문이 Statements 입니다. </span></span><br><span class="line"><span class="comment"># 여러개의 Expressions 로 이루어져 있는걸 확인 할수 있습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span> </span><br><span class="line">    b = <span class="number">2</span> </span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><a id="more"></a> <br><br><br><h2 id="PET-PEEVES"><a href="#PET-PEEVES" class="headerlink" title="PET PEEVES"></a>PET PEEVES</h2><br><br><p>PET PEEVES의 뜻도 짚어보고 넘어갑니다. </p><p>PET PEEVES 는 특별히 짜증나게 느끼는것들을 얘기하는데. 예를 들면 아래와 같습니다. </p><br><br><blockquote><p>우리 어머니의 PET PEEVE 는 내가 방청소를 안하는겁니다..<br></p><p>여자친구의 PET PEEVE 는 내가 연락을 잘 안하는겁니다.. <br></p><p>제 PET PEEVE 는 약속시간에 늦는겁니다. </p></blockquote><br><p>어머니를 짜증나게 하는것은 내가 방청소를 안하는것이고, 여자친구가 짜증나 하는거는 내가 연락을 잘 안하는것이고. 저를 짜증나게 하는것은 약속시간을 지키지 않는것입니다. </p><br><br><p>PEP8 에서는 짜증나는것들은 피하면서 코드를 쓰라고, 이번 타이틀을 이렇게 적은것 같습니다 ㅎㅎ </p><br><br><h2 id="과도하거나-적절하지-못한-공백은-피해야-합니다"><a href="#과도하거나-적절하지-못한-공백은-피해야-합니다" class="headerlink" title="과도하거나 적절하지 못한 공백은 피해야 합니다"></a>과도하거나 적절하지 못한 공백은 피해야 합니다</h2><br><br><p>PEP8 에서는 아래 상황들에 대해서 다룹니다. 예를들면서 넘어가겠습니다. </p><br><br><h3 id="소괄호-중괄호-대괄호-바로-안쪽"><a href="#소괄호-중괄호-대괄호-바로-안쪽" class="headerlink" title="소괄호, 중괄호, 대괄호 바로 안쪽"></a>소괄호, 중괄호, 대괄호 바로 안쪽</h3><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"></span><br><span class="line">spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"><span class="comment"># 괄호가 시작하고 바로 띄어쓰기가 나오고, </span></span><br><span class="line"><span class="comment"># 괄호가 닫히기 전에 띄어쓰기가 한번 더 되었습니다</span></span><br><span class="line"><span class="comment"># 너무 과도한 공백 사용의 예 </span></span><br><span class="line"></span><br><span class="line">spam( ham [ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125; )</span><br></pre></td></tr></table></figure><br><br><h3 id="뒤에-붙는-콤마와-괄호가-닫히는-사이-공간"><a href="#뒤에-붙는-콤마와-괄호가-닫히는-사이-공간" class="headerlink" title="뒤에 붙는 콤마와 괄호가 닫히는 사이 공간"></a>뒤에 붙는 콤마와 괄호가 닫히는 사이 공간</h3><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"></span><br><span class="line">foo = (<span class="number">0</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"><span class="comment"># 0 과 닫히는 괄호 사이에 의미없는 띄어쓰기가 있습니다. </span></span><br><span class="line"></span><br><span class="line">bar = (<span class="number">0</span>, )</span><br></pre></td></tr></table></figure><br><br><h3 id="콤마-세미콜론-콜론-바로-전-공간"><a href="#콤마-세미콜론-콜론-바로-전-공간" class="headerlink" title="콤마, 세미콜론, 콜론 바로 전 공간"></a>콤마, 세미콜론, 콜론 바로 전 공간</h3><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">4</span>: <span class="keyword">print</span> x, y; x, y = y, x </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 나쁜예</span></span><br><span class="line"><span class="comment"># 콜론, 세미콜론, 콤마 전후에 너무 많은 공백이 있습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">4</span> : <span class="keyword">print</span> x , y ; x , y = y , x</span><br></pre></td></tr></table></figure><br><br><h3 id="슬라이싱에-사용되는-콜론은-이항-연산자-역할을-합니다"><a href="#슬라이싱에-사용되는-콜론은-이항-연산자-역할을-합니다" class="headerlink" title="슬라이싱에 사용되는 콜론은 이항 연산자 역할을 합니다"></a>슬라이싱에 사용되는 콜론은 이항 연산자 역할을 합니다</h3><br><br><p>논리적 연산자 역할을 하는 콜론이 사용될때 (슬라이싱)에 대한 공백 가이드 라인 입니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"></span><br><span class="line">ham[<span class="number">1</span>:<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span>:<span class="number">3</span>], ham[:<span class="number">9</span>:<span class="number">3</span>], ham[<span class="number">1</span>::<span class="number">3</span>], ham[<span class="number">1</span>:<span class="number">9</span>:]</span><br><span class="line">ham[lower:upper], ham[lower:uper:], ham[lower::step]</span><br><span class="line">ham[lower+offset : upper+offset]</span><br><span class="line">ham[: upper_fn(x) : step_fn(x), ham[:: step_fn(x)]]</span><br><span class="line">ham[lower + offset : upper + offset]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 콜론을 사이에 두고 양쪽에 같은 공백이 적용 되어 있지 않습니다. </span></span><br><span class="line"></span><br><span class="line">ham[lower + offset:upper + offset]    <span class="comment"># 수정 예시 ham[lower+offset : upper+offset]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 슬리이싱이라 콜론 사이에 공백을 넣을 필요가 없는 경우 </span></span><br><span class="line"></span><br><span class="line">ham[<span class="number">1</span>: <span class="number">9</span>], ham[<span class="number">1</span> :<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span> :<span class="number">3</span>] </span><br><span class="line"><span class="comment"># 수정 예시 ham[1:9], ham[1:9:3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># extended slicing, :: 가 나오는 경우 공백 없이 써줘야 합니다.</span></span><br><span class="line"></span><br><span class="line">ham[lower : : upper]  </span><br><span class="line"><span class="comment"># 수정 예시 ham[lower::upper]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 콜론이 이항 연산자와 같은 역할을 하므로, 공백이 없어야 합니다. </span></span><br><span class="line"></span><br><span class="line">ham[ : upper] </span><br><span class="line"><span class="comment"># 수정 예시 ham[:upper]</span></span><br></pre></td></tr></table></figure><br><br><h3 id="함수를-호출할때-인자가-들어가는-바로-앞자리"><a href="#함수를-호출할때-인자가-들어가는-바로-앞자리" class="headerlink" title="함수를 호출할때 인자가 들어가는 바로 앞자리"></a>함수를 호출할때 인자가 들어가는 바로 앞자리</h3><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"></span><br><span class="line">spam (<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br><br><h3 id="인덱스와-슬라이싱을-하는-괄호-바로-앞자리"><a href="#인덱스와-슬라이싱을-하는-괄호-바로-앞자리" class="headerlink" title="인덱스와 슬라이싱을 하는 괄호 바로 앞자리"></a>인덱스와 슬라이싱을 하는 괄호 바로 앞자리</h3><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line">dct[<span class="string">'key'</span>] = <span class="number">1</span>st[index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line">dct [<span class="string">'key'</span>] = <span class="number">1</span>st [index]</span><br></pre></td></tr></table></figure><br><br><h3 id="변수-할당시-다른줄과-줄을-맞추기-위한-공백"><a href="#변수-할당시-다른줄과-줄을-맞추기-위한-공백" class="headerlink" title="변수 할당시 다른줄과 줄을 맞추기 위한 공백"></a>변수 할당시 다른줄과 줄을 맞추기 위한 공백</h3><br><p>변수를 할당하거나 선언할때, 연산자 주변에 다른 줄에 있는 연산기호와 줄을 맞추기 위해서 </p><p>공백을 너무 많이 주면 안됩니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span> </span><br><span class="line">y = <span class="number">2</span> </span><br><span class="line">long_variable = <span class="number">3</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"></span><br><span class="line">x   = <span class="number">1</span> </span><br><span class="line">y  = <span class="number">2</span> </span><br><span class="line">long_variable = <span class="number">3</span></span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p><br><br></p><p>너무 과도하거나 불필요하거나 적절하지 못한 공백의 사용은, 코드의 가독성을 떨어트리는것 같습니다. </p><br><p>적절한 곳에 공백을 두어서 코드의 가독성을 높이고. </p><br><p>논리적으로나 시각적으로나 더 간결한 코드를 작성하면 좋겠습니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-Whitespace-in-Expressions-and-Statements-PET-PEEVES/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - String Quotes</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-String-Quotes/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-String-Quotes/</guid>
      <pubDate>Sun, 05 Apr 2020 05:18:02 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;String-Quotes-문자열-따옴표&quot;&gt;&lt;a href=&quot;#String-Quotes-문자열-따옴표&quot; class=&quot;headerlink&quot; title=&quot;String Quotes (문자열 따옴표)&quot;&gt;&lt;/a&gt;String Quotes (문자열 따옴
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="String-Quotes-문자열-따옴표"><a href="#String-Quotes-문자열-따옴표" class="headerlink" title="String Quotes (문자열 따옴표)"></a>String Quotes (문자열 따옴표)</h1><br><br><blockquote><p>파이썬에서는, </p><p>문자열을 사용할때 작은따옴표와 큰따옴표는 똑같습니다. </p></blockquote><br><p>PEP8 에서는, 따옴표의 사용에 대한 어떠한 권장 사항이 없습니다. </p><p><br>단지 하나의 룰을 정하고, 그것을 일관되게 사용하길 바랍니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"This is string"</span> <span class="comment"># 큰 따옴표를 사용한 경우 </span></span><br><span class="line">string = <span class="string">'This is string'</span><span class="comment"># 작은 따옴표를 사용한 경우 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 두가지 방식은 같음</span></span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..<br></h2><br><p>저는 보통 작은 따옴표 <code>&#39;</code>를 사용합니다.. <code>shift</code>키를 안눌러도 되서 그런가 봅니다. </p><br><p>여러분들은 어떠신가요? <br></p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-String-Quotes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - Module Level Dunder Names</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Module-Level-Dunder-Names/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Module-Level-Dunder-Names/</guid>
      <pubDate>Sun, 05 Apr 2020 05:05:38 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Module-내에-Dunder-Names&quot;&gt;&lt;a href=&quot;#Module-내에-Dunder-Names&quot; class=&quot;headerlink&quot; title=&quot;Module 내에 Dunder Names&quot;&gt;&lt;/a&gt;Module 내에 Dunder Names&lt;/h1&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;모듈 레벨에서 Dunder Names&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;모듈 레벨에서 &lt;code&gt;__all__&lt;/code&gt;, &lt;code&gt;__author__&lt;/code&gt;, &lt;code&gt;__version__&lt;/code&gt; 같은 “dunders” 는 모듈 docstring 뒤에 그리고 &lt;code&gt;__future__&lt;/code&gt;를 제외한 모든 import 구문 앞에 붙입니다. &lt;br&gt;&lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;dunders &lt;/p&gt;
&lt;p&gt;&lt;br&gt;언더스코어 _ 두개가 붙는 메소드로 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Double UNDERscore&lt;/strong&gt; Method 를 줄여서 &lt;/p&gt;
&lt;p&gt;Dunder 메소드라고 부릅니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Module-내에-Dunder-Names"><a href="#Module-내에-Dunder-Names" class="headerlink" title="Module 내에 Dunder Names"></a>Module 내에 Dunder Names</h1><br><br><p><strong>모듈 레벨에서 Dunder Names</strong><br></p><br><br><p>모듈 레벨에서 <code>__all__</code>, <code>__author__</code>, <code>__version__</code> 같은 “dunders” 는 모듈 docstring 뒤에 그리고 <code>__future__</code>를 제외한 모든 import 구문 앞에 붙입니다. <br></p><br><br><blockquote><p>dunders </p><p><br>언더스코어 _ 두개가 붙는 메소드로 </p><p><strong>Double UNDERscore</strong> Method 를 줄여서 </p><p>Dunder 메소드라고 부릅니다. </p></blockquote><br><p><br><a id="more"></a></p><p>파이썬에서는, 아래 사항들을 의무화 합니다<br></p><br><blockquote><p><code>__future__</code> imports 는 docstring 을 제외한 어떤 코드보다 앞에 나와야 합니다.<br></p></blockquote><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""This is the example module. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This module does stuff </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> barry_as_FLUFL<span class="comment"># __future__ imports 가 docstring 다음에 위치합니다.</span></span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">__version__ = <span class="string">'0.1'</span></span><br><span class="line">__author__ = <span class="string">'Cardinal Biggles'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __future__를 제외한 Dunders 는 다른 일반 imports 구문 앞에 나옵니다.</span></span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>__ 가 붙는 imports 구문에 대한 순서를 알아보았습니다.<br></p><br><p>Docstring 이 우선으로 오고, </p><p><code>__future__</code>가 두번째로 오고<br></p><p><code>__future__</code>를 제외한 기타 다른 Dunders (e.g.<code>__all__, __version__, __author__ 등등</code>) 는 세번째로 옵니다. </p><p>그리고, 나머지 보통 라이브러리 imports (e.g. import os, import sys) 가 그 뒤에 온다고 정리하면 될것 같습니다. </p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Module-Level-Dunder-Names/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - Imports</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Imports/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Imports/</guid>
      <pubDate>Sun, 05 Apr 2020 04:44:34 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;PEP8-Code-Layout-Imports-가져오기&quot;&gt;&lt;a href=&quot;#PEP8-Code-Layout-Imports-가져오기&quot; class=&quot;headerlink&quot; title=&quot;PEP8 Code Layout - Imports (가져오기)&quot;&gt;&lt;/a&gt;PEP8 Code Layout - Imports (가져오기)&lt;/h1&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;PEP8 코드 레이아웃, &lt;code&gt;imports&lt;/code&gt;편 입니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;&lt;code&gt;imports&lt;/code&gt; 는 해당 파일에 다른 함수나 모듈을 불러올때 사용하는 명령어 입니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;표준 라이브러리 기능이나, 다른 모듈에 있는 함수, 클래스 혹은 메써드들을 가져올때 사용합니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;PEP8에 따르면, Imports 는 보통 별도의 줄로 되어 있어야 합니다. &lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 좋은예 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 나쁜예 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys, os&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;br&gt;

&lt;p&gt;하지만, 아래의 경우도 괜찮습니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 좋은예&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; subprocess &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Popen, PIPE&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="PEP8-Code-Layout-Imports-가져오기"><a href="#PEP8-Code-Layout-Imports-가져오기" class="headerlink" title="PEP8 Code Layout - Imports (가져오기)"></a>PEP8 Code Layout - Imports (가져오기)</h1><br><br><p>PEP8 코드 레이아웃, <code>imports</code>편 입니다. </p><br><p><code>imports</code> 는 해당 파일에 다른 함수나 모듈을 불러올때 사용하는 명령어 입니다. </p><p><br>표준 라이브러리 기능이나, 다른 모듈에 있는 함수, 클래스 혹은 메써드들을 가져올때 사용합니다. </p><br><blockquote><p>PEP8에 따르면, Imports 는 보통 별도의 줄로 되어 있어야 합니다. <br></p></blockquote><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예 </span></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"></span><br><span class="line"><span class="comment"># 나쁜예 </span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br></pre></td></tr></table></figure><br><p>하지만, 아래의 경우도 괜찮습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예</span></span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br></pre></td></tr></table></figure><br><a id="more"></a><blockquote><br><p>가져오기는 언제나 파일의 맨 위에 위치해야 하고, <br></p><p>모듈 주석이나 docstring 바로 뒤에 와야 합니다. <br></p><p>그리고 모듈 글로벌값들과 상수들 전에 와야 합니다. <br></p><br></blockquote><br><p><strong>가져오기는 아래 순서의 그룹으로 나뉩니다</strong><br></p><br><ol><li>스탠다드 라이브러리 imports</li><li>연관된 3자 모듈 / 라이브러리 imports</li><li>로컬 어플리케이션 / 라이브러리 imports<br></li></ol><p><br><br></p><p>이 그룹들 사이에는 빈줄을 넣어줘서 가져옵니다<br></p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 파이썬 스탠다드 라이브러리 </span></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line"><span class="comment"># 파이썬 3자 모듈/라이브러리 </span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask </span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> Api </span><br><span class="line"></span><br><span class="line"><span class="comment"># 로컬 어플리케이션 </span></span><br><span class="line"><span class="keyword">from</span> local_module <span class="keyword">import</span> local_class </span><br><span class="line"><span class="keyword">from</span> local_package <span class="keyword">import</span> local_function</span><br></pre></td></tr></table></figure><br><br><p>추천되는 import 방식은, 절대값의 imports  입니다.<br></p><br><p>절대 경로로 가져오면, </p><p>a) 코드에서 가독성이 높아집니다, b) 만약 import system 이 잘못 설정이 되어 있더라도 적어도 에러 메시지가 더 좋게 표시됩니다. </p><br><br><p><strong>명시적인 상대경로로 import 를 하는것도 허용됩니다.</strong><br></p><p>특히, 절대 경로로 import 하는것이 불필요한 복잡한 패키지 레이아웃에서는 </p><p>명시적인 상대경로로 import 를 해도 됩니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 절대값 import </span></span><br><span class="line"><span class="keyword">import</span> mypkg.sibling </span><br><span class="line"><span class="keyword">from</span> mypkg <span class="keyword">import</span> sibling </span><br><span class="line"><span class="keyword">from</span> mypkg.sibling <span class="keyword">import</span> example </span><br><span class="line"></span><br><span class="line"><span class="comment"># 명시적인 상대 import </span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> sibling </span><br><span class="line"><span class="keyword">from</span> .sibling <span class="keyword">import</span> example</span><br></pre></td></tr></table></figure><br><br><p>스탠다드 라이브러리 코드는 복잡한 패키지 레이아웃을 피해야 합니다. </p><p><br>언제나 절대 경로의 import 를 하는것이 좋고, 명시적이지 않는 상대 import 는 절대 사용되면 안됩니다. </p><br><p><br><strong>클래스를 포함하고 있는 모듈에서 클래스를 가져올땐, 보통 클래스명을 써줍니다</strong><br></p><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myclass <span class="keyword">import</span> MyClass </span><br><span class="line"><span class="keyword">from</span> foo.bar.yourclass <span class="keyword">import</span> YourClass </span><br><span class="line"></span><br><span class="line"><span class="comment"># 만약 클래스명이 로컬 이름과 충돌한다면, 명시적으로 스펠링을 해줍니다. </span></span><br><span class="line"><span class="keyword">import</span> myclass </span><br><span class="line"><span class="keyword">import</span> foo.bar.yourclass </span><br><span class="line"></span><br><span class="line"><span class="comment"># 그리고, 아래를 사용합니다 </span></span><br><span class="line">myclass.MyClass </span><br><span class="line">foo.bar.yourclass.Yourclass</span><br></pre></td></tr></table></figure><p><br><br></p><blockquote><p>Whildcard 와일드카드 가져오기를 사용하는것은 피해야 합니다. </p><p><code>from &lt;module&gt; import *</code><br></p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wildcard Imports 예시, * 은 모듈에 포함된 모든것을 의미 </span></span><br><span class="line"><span class="keyword">from</span> Flask <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><br><br><p><code>*</code>를 사용하므로써, 모듈에 포함된 모든 클래스와 함수 그리고 메써드들을 불러옵니다. </p><p>이럴경우, 어떤 이름들이 네임공간에 있는지 헷갈리게 되고, 자동화툴이나 에디터가 헷갈릴수 있습니다. <br></p><br><p>와일드카드 가져오기는 보통 내부 인터페이스를 퍼블릭 API  로 재발행 할때 사용합니다. <br></p><br><p>이 때를 제외하고는, 기본적으로 사용을 피해야 합니다. </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><p><br><br></p><p>클래스를 포함하고 있는 클래스 모듈을 가져올때 쓰는 스펠링이 이해가 잘 가지 않습니다. <br></p><p>이 부분은 조금 더 시간을 들여서 더 많은 코드를 접해본다음 이해가 갈것 같습니다. <br></p><br><p>이해를 마친뒤에 업데이트 할 예정입니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Imports/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - Source File Encoding</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Source-File-Encoding/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Source-File-Encoding/</guid>
      <pubDate>Sat, 04 Apr 2020 16:43:05 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Source-File-Encoding-소스파일-인코딩&quot;&gt;&lt;a href=&quot;#Source-File-Encoding-소스파일-인코딩&quot; class=&quot;headerlink&quot; title=&quot;Source File Encoding (소스파일 인코딩)&quot;&gt;&lt;/a&gt;Source File Encoding (소스파일 인코딩)&lt;/h1&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;이번 토픽은 소스파일 인코딩 입니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;파이썬 배포에 사용되는 코드는 항상 UTF-8 을 사용해야 합니다. &lt;/p&gt;
&lt;p&gt;파이썬2 에서는 ASCII &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;&lt;a href=&quot;https://namu.wiki/w/UTF-8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://namu.wiki/w/UTF-8&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;UTF-8 은 가장 많이 사용되는 가변길이 유니코드 인코딩이다.&lt;/p&gt;
&lt;p&gt;GO 언어를 만든 켄 톰슨과 롭 파이크가 만들었다 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;[&lt;a href=&quot;https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C?from=ASCII]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C?from=ASCII]&lt;/a&gt;(&lt;a href=&quot;https://namu.wiki/w/아스키&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://namu.wiki/w/아스키&lt;/a&gt; 코드?from=ASCII)&lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;ASCII 코드는 미국 ANSI 에서 표준화한 정보 교환용 7비트 부호체계 &lt;/p&gt;
&lt;p&gt;2 바이트 이상의 코드를 표현할수 없기 때문에. &lt;/p&gt;
&lt;p&gt;국제 표준에서는 유니코드로 넘어감.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;PEP8에 따르면, 파이썬2에서 ASCII 를 사용하는 파일들이나 혹은 파이썬3에서 UTF-8을 사용하는 파일들 모두 &lt;/p&gt;
&lt;p&gt;인코딩 선언이 되어 있지 않아야 합니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Source-File-Encoding-소스파일-인코딩"><a href="#Source-File-Encoding-소스파일-인코딩" class="headerlink" title="Source File Encoding (소스파일 인코딩)"></a>Source File Encoding (소스파일 인코딩)</h1><br><br><p>이번 토픽은 소스파일 인코딩 입니다. </p><br><br><p>파이썬 배포에 사용되는 코드는 항상 UTF-8 을 사용해야 합니다. </p><p>파이썬2 에서는 ASCII </p><br><p><a href="https://namu.wiki/w/UTF-8" target="_blank" rel="noopener">https://namu.wiki/w/UTF-8</a></p><br><blockquote><p>UTF-8 은 가장 많이 사용되는 가변길이 유니코드 인코딩이다.</p><p>GO 언어를 만든 켄 톰슨과 롭 파이크가 만들었다 </p></blockquote><br><br><p>[<a href="https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C?from=ASCII]" target="_blank" rel="noopener">https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C?from=ASCII]</a>(<a href="https://namu.wiki/w/아스키" target="_blank" rel="noopener">https://namu.wiki/w/아스키</a> 코드?from=ASCII)</p><br><blockquote><p>ASCII 코드는 미국 ANSI 에서 표준화한 정보 교환용 7비트 부호체계 </p><p>2 바이트 이상의 코드를 표현할수 없기 때문에. </p><p>국제 표준에서는 유니코드로 넘어감.</p></blockquote><br><br><p>PEP8에 따르면, 파이썬2에서 ASCII 를 사용하는 파일들이나 혹은 파이썬3에서 UTF-8을 사용하는 파일들 모두 </p><p>인코딩 선언이 되어 있지 않아야 합니다. </p><br><a id="more"></a><br><blockquote><p>*<em>참고로 *</em></p><p>encoding 선언이 되어 있지 않으면, </p><p>기본 인코딩은 UTF-8 입니다. </p><p>from Python3 공식문서 </p></blockquote><br><br><p>파이썬 표준 라이브러리에서는, 기본 인코딩이 아닌 문자는 아래의 경우만 사용합니다<br></p><br><p>a) 테스트 목적<br></p><p>b) comment 나 docstring 에서 게시자의 이름이 non-ASCII  문자를 포함하고 있을때 </p><br><br><p><strong>PEP에서는 특별히 Non-ASCII 문자가 포함되어 있는 경우가 아니면</strong><br></p><p>아래의 escapes 를 사용하여 문자열에 있는 non-ASCII 데이터를 표현하는 방식을 선호합니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\x <span class="comment"># Character with hex value e.g. \xhh</span></span><br><span class="line">\u <span class="comment"># Unicode Character with 16-bit hex value xxx e.g. u'\u004D'</span></span><br><span class="line">\U<span class="comment"># Unicode Character with 32-bit hex value xxxxxxxx e.g. u'\U0000004D'</span></span><br><span class="line">\N<span class="comment"># Character named name in the Unicode database e.g. \N&#123;name&#125;</span></span><br></pre></td></tr></table></figure><br><br><p>PEP3131 에 파이썬 3.0 과 그 이후 버전에 대한 원칙이 나와 있습니다.<br></p><br><br><p>PEP8 에서 정리하는 바는 다음과 같습니다 <br></p><br><p>1) 파이썬의 표준 라이브러리 안에 있는 모든 식별자는 ASCII-Only 식별자여야 하고. 가능하면 영문으로 씁니다.<br></p><p>2) 추가로 문자열과 주석들도 ASCII  형식으로 되어 있어야만 합니다. 이부분에 대한 예외는 아래와 같습니다. <br></p><p>  a) ASCII 방식이 아닌것을 테스트 하고자 할때. <br></p><p>  b) 게시자의 이름이 라틴 알파벳으로 되어 있지 않은 경우, Non-ASCII로 표현 되어도 됩니다. </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>저는 아직도 ASCII 와 UTF-8 인코딩 방식에 대해서 깊게 알지 못합니다. </p><p>두가지의 인코딩 방식에 대해서 정확하게 이해해야지만, PEP8 에서 이야기 하는 부분을 정확하게 이해할것 같습니다. </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Source-File-Encoding/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - Blank Lines</title>
      <link>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Blank-Lines/</link>
      <guid>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Blank-Lines/</guid>
      <pubDate>Sat, 04 Apr 2020 16:25:03 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;PEP8-Code-Layout-Blank-Lines-빈줄&quot;&gt;&lt;a href=&quot;#PEP8-Code-Layout-Blank-Lines-빈줄&quot; class=&quot;headerlink&quot; title=&quot;PEP8 Code Layout - Blank Lines (빈줄)&quot;&gt;&lt;/a&gt;PEP8 Code Layout - Blank Lines (빈줄)&lt;/h1&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;이번 토픽은, PEP8 에서 권장하는 코드내에 빈줄 공간들에 대해서 다룹니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;가장 상위의 함수와 클래스 정의는 2줄의 빈줄로 공간을 둡니다&lt;/strong&gt; &lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이것이 의미하는 바는 아래의 예제를 보면 알수 있습니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 가장 상위의 함수와 클래스들 사이의 2줄 공간 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 가장 상위의 클래스 두개끼리는 2줄의 빈공간이 있습니다. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DjangoJenge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DjangoJenge2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 가장 상위의 함수 두개끼리는 2줄의 빈공간을 둡니다. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Djangojeng&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Djangojeng&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;클래스 내의 메써드 정의는 1줄로 공간을 둡니다.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="PEP8-Code-Layout-Blank-Lines-빈줄"><a href="#PEP8-Code-Layout-Blank-Lines-빈줄" class="headerlink" title="PEP8 Code Layout - Blank Lines (빈줄)"></a>PEP8 Code Layout - Blank Lines (빈줄)</h1><br><br><p>이번 토픽은, PEP8 에서 권장하는 코드내에 빈줄 공간들에 대해서 다룹니다. </p><br><br><blockquote><p> <strong>가장 상위의 함수와 클래스 정의는 2줄의 빈줄로 공간을 둡니다</strong> <br></p></blockquote><p><br><br></p><p>이것이 의미하는 바는 아래의 예제를 보면 알수 있습니다. </p><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 가장 상위의 함수와 클래스들 사이의 2줄 공간 </span></span><br><span class="line"><span class="comment"># 가장 상위의 클래스 두개끼리는 2줄의 빈공간이 있습니다. </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DjangoJenge</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DjangoJenge2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 가장 상위의 함수 두개끼리는 2줄의 빈공간을 둡니다. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Djangojeng</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Djangojeng</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><br><blockquote><p>클래스 내의 메써드 정의는 1줄로 공간을 둡니다.<br></p></blockquote><a id="more"></a><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 클래스 내의 메써드 정의는 1줄 공간을 둡니다. </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DjangoJenge1</span><span class="params">()</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn_python</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn_python2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DjangoJeng2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn_django</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn_django2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><br><br></p><p>위 예시를 보면, 가장 상위에 위치하는 클래스들 끼리는 2줄 빈공간이 존재하고. <br></p><p>클래스 안에 있는 메서드 들 끼리는 1줄 빈공간들이 존재합니다.</p><p><br><br></p><blockquote><p>함수내에 빈줄은 드물게 사용해야 합니다.</p><p>함수내에 빈줄은 논리적 부분을 표시하기 위해서 사용 가능합니다. </p></blockquote><p><br><br></p><p>예를들면, </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수내에 논리적인 부분을 표시하기 위해서 빈줄을 함수내에서 사용합니다. </span></span><br><span class="line"><span class="comment"># 아주 드물게 사용해야 합니다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(j)</span>:</span></span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j):</span><br><span class="line">        c = c + <span class="number">1</span> </span><br><span class="line">    </span><br><span class="line">    print(c)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># for 문과 print 문 사이에 하나의 빈줄이 존재합니다.</span></span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>PEP8 안에 빈줄 (Blank Lines)에 관한 내용은 유용한 내용인데도 불구하고 <br></p><p>예시가 빈약해서 이해하기 힘들었습니다. <br></p><p><br><br></p><p>최대한 맞는 예시를 들으려 했지만 부족할수 있습니다. </p><br><p>하지만, 걱정 안하셔도 됩니다. </p><br><blockquote><p>Pycharm을 사용하면 자동으로 PEP8에 맞는 스타일을 가이드 해줍니다 </p><p>코드를 작성할때 이따금씩 노란색 밑줄이 쳐질때가 있는데, PEP8에 어긋날때 표시가 됩니다. </p><p>잘 유의해서 확인하고, PEP8 가이드라인에 맞게 코드를 작성하면 됩니다! </p></blockquote>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/05/PEP8-Code-Layout-Blank-Lines/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - Should a Line Break Before or After a Binary Operator?</title>
      <link>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Should-a-Line-Break-Before-or-After-a-Binary-Operator/</link>
      <guid>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Should-a-Line-Break-Before-or-After-a-Binary-Operator/</guid>
      <pubDate>Sat, 04 Apr 2020 10:53:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이항연산자-전후-줄바꿈&quot;&gt;&lt;a href=&quot;#이항연산자-전후-줄바꿈&quot; class=&quot;headerlink&quot; title=&quot;이항연산자 전후 줄바꿈&quot;&gt;&lt;/a&gt;이항연산자 전후 줄바꿈&lt;/h1&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;이항 연산자 전에 줄바꿈을 해야할
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="이항연산자-전후-줄바꿈"><a href="#이항연산자-전후-줄바꿈" class="headerlink" title="이항연산자 전후 줄바꿈"></a>이항연산자 전후 줄바꿈</h1><br><br><p>이항 연산자 전에 줄바꿈을 해야할까요 아니면 후에 줄바꿈을 해줘야 할까요? </p><br><blockquote><p>줄바꿈은 연산기호 전에 되어야 하는가? </p><p>아니면</p><p>줄바꿈은 연산기호 후에 되어야 하는가? </p></blockquote><br><br><p><strong>몇십년동안, 줄바꿈은 연산기호 후에 해주는것이 권장 되어 왔습니다.</strong></p><br><p>하지만, 줄바꿈을 연산기호 후에 해주면, 두가지 이유로 가독성을 떨어트립니다. </p><p><br><br> </p><p>1) 연산기호들이 스크린에 세로줄로 흐트러지고, 이전줄에 있는 피연산자들(opernand) 과 떨어지게 됩니다. </p><p>2) 시각적으로 어떤것들이 더해지고, 빼줘야 하는것인지 파악하는데에 시간을 들여야 합니다. </p><br><br><p><strong>연산기호들이 피연산자들과 멀리 떨어져 있는 경우의 예를 들어봅니다</strong></p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 연산기호들이 이전줄의 피연산자들과 떨어져 있는 경우의 코드 </span></span><br><span class="line"></span><br><span class="line">income = (gross_wages +</span><br><span class="line">         taxable_interest +</span><br><span class="line">         (dividends - qualified_dividends) -</span><br><span class="line">         ira_deduction - </span><br><span class="line">         student_loan_interest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 줄바꿈이 연산기호인 + 혹은 - 이후에 이루어진것을 확인 할수 있습니다. </span></span><br><span class="line"><span class="comment"># 코드를 읽어가면서 어떤것을 더해주고 빼주어야 하는지 눈으로 더 확인 해봐야 하는 상황이 옵니다.</span></span><br></pre></td></tr></table></figure><br><p>위 상황에서 가독성이 떨어지기 때문에, 수학자들과 퍼블리셔들은 반대의 관례를 따르기 시작합니다.</p><br><br><blockquote><p>문단안에 있는 공식들은 </p><p>언제나 연산기호 뒤에 줄바꿈을 하지만 </p><p>잘 진열된 공식들은 언제나 연산기호 전에 줄바꿈을 합니다 </p><p>Donald Knuth in “Computers and Typesetting series”</p></blockquote><br><br><p>수학적 전통을 따르면, 결과적으로 더 읽기 편한 코드가 나옵니다. 아래 예시 코드를 참조합니다. </p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 코드에서 줄바꿈을 연산기호 전에 하면</span></span><br><span class="line"><span class="comment"># 연산기호들과 피연산자들을 매칭 시키기 쉬운 코드가 됩니다. </span></span><br><span class="line"><span class="comment"># PEP8 에서 나온 좋은 예시는 아래와 같습니다. </span></span><br><span class="line"></span><br><span class="line">income = (gross_wages</span><br><span class="line">         + taxable_interest</span><br><span class="line">         + (dividends - qualified_dividens)</span><br><span class="line">         - ira_deduction</span><br><span class="line">         - student_loan_interest)</span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>파이썬 코드에서는, 줄바꿈을 연산기호 전이나 연산기호 후에 하는 두가지 방법이 모두 허용됩니다. <br></p><p>어떤 방법이던, 해당 지역의 관례와 맞는다면, 두가지 방식은 다 괜찮습니다.<br></p><br><p><strong>저는 개인적으로, 연산기호 전에 줄바꿈을 해주는것이 가독성에 좋다고 생각합니다.</strong></p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Should-a-Line-Break-Before-or-After-a-Binary-Operator/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - Maximum Line Length</title>
      <link>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Maximum-Line-Length/</link>
      <guid>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Maximum-Line-Length/</guid>
      <pubDate>Sat, 04 Apr 2020 10:29:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Maximum-Line-Length&quot;&gt;&lt;a href=&quot;#Maximum-Line-Length&quot; class=&quot;headerlink&quot; title=&quot;Maximum Line Length&quot;&gt;&lt;/a&gt;Maximum Line Length&lt;/h1&gt;&lt;br&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Maximum-Line-Length"><a href="#Maximum-Line-Length" class="headerlink" title="Maximum Line Length"></a>Maximum Line Length</h1><br><blockquote><p><code>Maximum Line Length</code> 는 한줄의 최대 길이를 의미 합니다. </p></blockquote><br><br><h2 id="모든-줄은-79자로-제한-합니다"><a href="#모든-줄은-79자로-제한-합니다" class="headerlink" title="모든 줄은 79자로 제한 합니다"></a>모든 줄은 79자로 제한 합니다</h2><br><p>네. PEP8 에서는, 파이썬 코드를 작성할때. 한줄의 최대 길이를 79자로 제한합니다. </p><br><br><p><strong>다만! <code>docstring</code>혹은 <code>comments</code> 즉 주석들은, 72자로 제한합니다.</strong> </p><br><br><blockquote><p>모든 팀원들이 동의한다는 전제하에, </p><p>특별히 코드의 긴 줄이 유지 되어야 하는 상황이거나 하면 </p><p>최대 길이는 99자까지 늘릴수 있습니다. </p></blockquote><br><h2 id="한줄이-너무-긴-코드-줄-바꾸기"><a href="#한줄이-너무-긴-코드-줄-바꾸기" class="headerlink" title="한줄이 너무 긴 코드 줄 바꾸기"></a>한줄이 너무 긴 코드 줄 바꾸기</h2><br><blockquote><p>PEP8 에서 선호하는 긴줄 처리는, </p><p>계속되는 줄의 경계를 소괄호, 중괄호, 대괄호 안에 넣고 사용하는것입니다. </p><p>이 방법이 \ 를 사용하는 방법보다 선호됩니다. </p></blockquote><br><p>제가 생각하는 예시들은 아래와 같습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 한줄이 너무 긴 코드 </span></span><br><span class="line"><span class="keyword">if</span>(this_is_one_thing <span class="keyword">or</span> that_is_another_thing <span class="keyword">or</span> everything_is_good_thing <span class="keyword">or</span> you_are_the best):</span><br><span class="line">    </span><br><span class="line"><span class="comment"># \ 백슬레쉬를 사용하지 않고, 괄호안에서 줄을 바꿔서, 한줄을 다음줄로 나눕니다. </span></span><br><span class="line"><span class="comment"># 물론 들여쓰기는 잘해주어야 하겠죠? </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(this_is_one_thing <span class="keyword">or</span></span><br><span class="line">   that-is_another_thing <span class="keyword">or</span></span><br><span class="line">   everything_is_good_thing <span class="keyword">or</span></span><br><span class="line">   you_are_the_best):</span><br></pre></td></tr></table></figure><br><p>위 방법이 선호되는것 같으나, 여전히 <code>\</code>백슬레쉬의 사용하는 방법도 괜찮습니다! </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># \ 를 사용하여 줄을 나눈 경우, \를 사용하지 않았으면, 한줄이 너무 길어 졌을것 같습니다. </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/some/file/you/want/to/read'</span>) <span class="keyword">as</span> file_1, \</span><br><span class="line">     open(<span class="string">'/path/to/some/file/being/written'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file_2:)</span><br><span class="line">     file_2.write(file_1.read())</span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>1) PEP8 에서는 한줄의 최대길이를 79자로 제한합니다. </p><p>2) docstring 이나 comments 같은 주석들은 72자로 제한합니다.</p><p>3) 한줄이 너무 길어질것 같으면, <code>\</code>나 괄호안의 문장을 다음줄로 이어갑니다 (들여쓰기는 적절히 해야하는게 필수) </p><br><p>한줄 한줄이 너무 길어서 스크린이 꽉꽉 차있으면, 일하러 가서 매일 아래와 같은 스크린을 보게 될것입니다. <br></p><img src="/2020/04/04/PEP8-Code-Layout-Maximum-Line-Length/image1.jpeg" class=""><p><br><br></p><p>그리고, 누가 그러시던데, 한줄의 길이가 79자가 된 이유중에 하나가. <br></p><p>옛날 컴퓨터의 모니터 크기 때문이라고 합니다. 지금 나오는 모니터 크기와는 다르게.<br></p><p><br> 옛날 모니터들은 가로폭이 굉장히 좁아서. 화면에 꽉차는 양이 79자 정도 였다 합니다.  <br></p><p>아래 사진을 보면,,, 충분히 그럴수도 있었겟네요? ㅎㅎ <br></p><br><img src="/2020/04/04/PEP8-Code-Layout-Maximum-Line-Length/image2.jpg" class="">]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Maximum-Line-Length/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - Tabs or Spaces?</title>
      <link>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Tabs-or-Spaces/</link>
      <guid>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Tabs-or-Spaces/</guid>
      <pubDate>Sat, 04 Apr 2020 10:14:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;PEP8-Code-Layout-Tab-혹은-Spaces&quot;&gt;&lt;a href=&quot;#PEP8-Code-Layout-Tab-혹은-Spaces&quot; class=&quot;headerlink&quot; title=&quot;PEP8 Code Layout - Tab 혹은 Spaces
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="PEP8-Code-Layout-Tab-혹은-Spaces"><a href="#PEP8-Code-Layout-Tab-혹은-Spaces" class="headerlink" title="PEP8 Code Layout - Tab 혹은 Spaces?"></a>PEP8 Code Layout - Tab 혹은 Spaces?</h1><br><blockquote><p>파이썬에서는 Tab 대신 Spaces(빈공간)을 사용하는것을 선호합니다. </p></blockquote><br><p>탭을 사용하는 경우는, 이미 코드가 <code>tab</code>으로 들여쓰기가 되어 있는 경우, </p><p><br>코드와 일관되게 <code>tab</code>을 사용합니다. </p><br><blockquote><p>Python3 에는 <code>tab</code>과 <code>spaces</code> 혼용 사용을 허락하지 않습니다. </p></blockquote><br><p><code>tab</code>과  <code>spaces</code>의 혼용으로 들여쓰기가 되어진 Python2 버전의 코드는 특별히 spaces를 사용해서 전환되어야 합니다. </p><br><p><br>Python2 커맨드 라인 인터프리터로 <code>-t</code>옵션을 사용하면, </p><p><code>tabs</code>와 <code>spaces</code>의 혼용된 코드에 대해서 경고를 줍니다. </p><br><p><code>--t</code>옵션을 사용하면, 이 경고들이 에러가 됩니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Tabs-or-Spaces/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 Code Layout - Indentation</title>
      <link>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Indentation/</link>
      <guid>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Indentation/</guid>
      <pubDate>Sat, 04 Apr 2020 09:16:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;PEP8-Code-Layout-Indentation-들여쓰기&quot;&gt;&lt;a href=&quot;#PEP8-Code-Layout-Indentation-들여쓰기&quot; class=&quot;headerlink&quot; title=&quot;PEP8 Code Layout - Indentation (들여쓰기)&quot;&gt;&lt;/a&gt;PEP8 Code Layout - Indentation (들여쓰기)&lt;/h1&gt;&lt;br&gt;

&lt;h2 id=&quot;Indentation&quot;&gt;&lt;a href=&quot;#Indentation&quot; class=&quot;headerlink&quot; title=&quot;Indentation&quot;&gt;&lt;/a&gt;Indentation&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;파이썬에서, 들여쓰기는 문법으로 의무화 되어 있습니다. &lt;br&gt;&lt;/p&gt;
&lt;p&gt;PEP8에서는 들여쓰기에 대한 코딩 스타일을 다루고 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;들여쓰기는 4칸을 사용합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;Continuation lines, 즉 이어지는 줄들은 세로로 정렬이 되어야 하는데. &lt;br&gt;&lt;/p&gt;
&lt;p&gt;1) 파이썬에서 암시적으로 이어지는 줄들을 소괄호, 중괄호, 대괄호 안에 묶거나, &lt;/p&gt;
&lt;p&gt;2) hanging indent 를 사용하여 정렬합니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;hanging indent 를 직역하면, 매달려 있는 들여쓰기로. &lt;/p&gt;
&lt;p&gt;문단의 첫번째 줄을 제외한 모든 라인이 들여쓰기가 되어 있는 스타일 입니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;&lt;strong&gt;hanging indent 의 예를 들어봅니다&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="PEP8-Code-Layout-Indentation-들여쓰기"><a href="#PEP8-Code-Layout-Indentation-들여쓰기" class="headerlink" title="PEP8 Code Layout - Indentation (들여쓰기)"></a>PEP8 Code Layout - Indentation (들여쓰기)</h1><br><h2 id="Indentation"><a href="#Indentation" class="headerlink" title="Indentation"></a>Indentation</h2><br><p>파이썬에서, 들여쓰기는 문법으로 의무화 되어 있습니다. <br></p><p>PEP8에서는 들여쓰기에 대한 코딩 스타일을 다루고 있습니다. </p><br><br><blockquote><p>들여쓰기는 4칸을 사용합니다.</p></blockquote><br><p>Continuation lines, 즉 이어지는 줄들은 세로로 정렬이 되어야 하는데. <br></p><p>1) 파이썬에서 암시적으로 이어지는 줄들을 소괄호, 중괄호, 대괄호 안에 묶거나, </p><p>2) hanging indent 를 사용하여 정렬합니다. </p><br><blockquote><p>hanging indent 를 직역하면, 매달려 있는 들여쓰기로. </p><p>문단의 첫번째 줄을 제외한 모든 라인이 들여쓰기가 되어 있는 스타일 입니다. </p></blockquote><br><p><strong>hanging indent 의 예를 들어봅니다</strong></p><br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">djangojenge = djangojenge(django, python,</span><br><span class="line">pep8, programming)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 첫번째줄은 들여쓰기가 되어 있지 않은데 </span></span><br><span class="line"><span class="comment"># 두번째줄은 들여쓰기가 되어 있습니다. 이것을 매달려있는 들여쓰기. 즉 hanging indent 라고 합니다.</span></span><br></pre></td></tr></table></figure><br><br><p><code>hanging indent</code>를 사용할때는, 아래 두가지 사항을 골려하면서 사용합니다. </p><br><ol><li>첫번째 줄에는 arguments (전달인자) 가 없어야 합니다. </li><li>이어지는 줄이라는것을 표시하기 위해 추가적인 들여쓰기가 사용되어야합니다</li></ol><br><br><h2 id="좋은예"><a href="#좋은예" class="headerlink" title="좋은예"></a>좋은예</h2><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좋은예: </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 열리는 구분자와 정렬</span></span><br><span class="line"></span><br><span class="line">foo = long_function_name(var_one, var_two, </span><br><span class="line">                         var_three, var_four)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4칸을 추가로 주어 전달인자들을 다른 로직과 구분 </span></span><br><span class="line"><span class="comment"># 추가 들여쓰기로 arguments 부분과, print 부분이 구분됩니다. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="function"><span class="params">var_four)</span>:</span></span><br><span class="line">    print(var_one)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># Hanging indents 한칸을 더 추가 합니다 </span></span><br><span class="line"><span class="comment"># 첫번째 예랑 같은데, hanging indent 로 한칸씩 추가 되어. 좀더 깔끔해 보입니다. </span></span><br><span class="line"></span><br><span class="line">foo = long_function_name(</span><br><span class="line">var_one, var_two,</span><br><span class="line">var_three, var_four)</span><br></pre></td></tr></table></figure><br><br><h2 id="나쁜예"><a href="#나쁜예" class="headerlink" title="나쁜예"></a>나쁜예</h2><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 나쁜예: </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 첫번째 전달인자들이 세로로 정렬이 되지 않은 경우</span></span><br><span class="line"></span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">      var_three, var_four)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 추가적인 들여쓰기가 필요한 경우</span></span><br><span class="line"><span class="comment"># 추가적인 들여쓰기가 없을경우, 전달인자들과 print() 와 구분이 안갑니다. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="function"><span class="params">var_four)</span>:</span></span><br><span class="line">    print(var_one)</span><br></pre></td></tr></table></figure><br><br><h2 id="선택-사항"><a href="#선택-사항" class="headerlink" title="선택 사항"></a>선택 사항</h2><br><br><p>이어지는 줄에서의 4-칸 스페이스 룰은 선택 사항입니다. 4칸 보다 더 쓸수도, 덜 쓸수도 있습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hanging indents 는 4칸 외에 공간으로 들여쓰기가 가능합니다 </span></span><br><span class="line"></span><br><span class="line">foo = long_function_name(</span><br><span class="line">  var_one, var_two, </span><br><span class="line">  var_three, var_four)</span><br></pre></td></tr></table></figure><br><h2 id="조건문이-너무-길어질때"><a href="#조건문이-너무-길어질때" class="headerlink" title="조건문이 너무 길어질때"></a>조건문이 너무 길어질때</h2><br><p><strong><code>if</code>구문의 조건 부분이 너무 길어져서 다수의 줄이 된다면,</strong> </p><br><blockquote><p><code>if</code> 다음에 한칸을 띄고 괄호를 열어줍니다.</p><p>if ():</p><p>이렇게 쓰면, 자연스럽게 다음줄부터 4칸 들여쓰기가 됩니다</p></blockquote><p><br><br></p><p>조건부분이 너무 길고, 밑에 실행 가능한 함수등과 구분짓고 싶을때 아래와 같이 써줍니다. </p><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 추가 들여쓰기가 없음</span></span><br><span class="line"><span class="comment"># do_something() 부분이 자연스럽게 들여쓰기가 됩니다. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span> </span><br><span class="line">   that_is_another_thing):</span><br><span class="line">   do_something()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 주석을 달아줘서 조건 부분과 함수 부분을 구분합니다 </span></span><br><span class="line"><span class="comment"># 주석과 코드의 색깔을 표시해주는 에디터가 많기 때문에 구분이 가능합니다. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span> </span><br><span class="line">   that_is_another_thing):</span><br><span class="line">   <span class="comment"># Since both conditions are true, we can frobncate.</span></span><br><span class="line">   do_something()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 조건문이 이어지는 줄에 추가로 들여쓰기를 넣어줍니다 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing</span><br><span class="line">   <span class="keyword">and</span> that_is_another_thing): </span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure><br><br><h2 id="여러-줄에서-닫히는-소괄호-중괄호-대괄호"><a href="#여러-줄에서-닫히는-소괄호-중괄호-대괄호" class="headerlink" title="여러 줄에서 닫히는 소괄호/중괄호/대괄호"></a>여러 줄에서 닫히는 소괄호/중괄호/대괄호</h2><br><p>맨마지막 줄 다음줄에 닫는 괄호를 넣어줍니다. 괄호를 따로 들여쓰기를 해주어야 되겠죠? ㅎㅎ<br></p><br><p><strong>코드를 보면서 이해합니다.</strong> </p><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 마지막 줄의 ] 는 추가로 들여쓰기가 되었습니다.</span></span><br><span class="line"></span><br><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 마지막 줄의 ) 는 추가로 들여쓰기가 되었습니다. </span></span><br><span class="line"></span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line"><span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>,</span><br><span class="line"><span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><p><strong>혹은, 닫히는 소괄호/중괄호/대괄호 들은 첫번째 줄의 시작점에 두어도 괜찮습니다. (밑에 코드 참조)</strong></p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 마지막 줄의 ] 는 추가로 들여쓰기가 되었습니다.</span></span><br><span class="line"></span><br><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 마지막 줄의 ) 는 추가로 들여쓰기가 되었습니다. </span></span><br><span class="line"></span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line"><span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>,</span><br><span class="line"><span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>PEP에서 들여쓰기 부분이 가장 초입인데. 뭔가 가장 헷갈렸습니다. <br></p><p>표현들이 좀 이상해서 더 애먹은것 같습니다.  세번째 쯤 보니까 이제 좀 이해가 가는듯 합니다. </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/04/PEP8-Code-Layout-Indentation/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP8 - A Foolish Consistency is the Hobgoblin of Little Minds</title>
      <link>http://djangojeng-e.github.io/2020/04/04/PEP8-A-Foolish-Consistency-is-the-Hobgoblin-of-Little-Minds/</link>
      <guid>http://djangojeng-e.github.io/2020/04/04/PEP8-A-Foolish-Consistency-is-the-Hobgoblin-of-Little-Minds/</guid>
      <pubDate>Fri, 03 Apr 2020 17:08:19 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;PEP8-A-foolish-consistency-is-the-Hobgoblin-of-Little-Minds&quot;&gt;&lt;a href=&quot;#PEP8-A-foolish-consistency-is-the-Hobgoblin-of-Little-Minds&quot; class=&quot;headerlink&quot; title=&quot;PEP8 - A foolish consistency is the Hobgoblin of Little Minds&quot;&gt;&lt;/a&gt;PEP8 - A foolish consistency is the Hobgoblin of Little Minds&lt;/h1&gt;&lt;br&gt;

&lt;p&gt;PEP8 스타일 가이드라인의 두번째 토픽입니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt; 타이틀을 직역해보면, &lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어리석은 일관성은 &lt;/p&gt;
&lt;p&gt;소심한 홉고블린이다? &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;서양에서는, 홉고블린이 사악하고, 아둔한 그런데 또 피지컬은 또 없는 그런 요괴로 취급됩니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;&lt;strong&gt;다시 말해서, 잘못된 코딩 스타일 일관성은 고블린 취급받기 쉽단 얘기겠죠?&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코드는 쓰이는것보다 읽히는 일이 많다.&lt;/p&gt;
&lt;p&gt;by 파이썬 창시자 귀도 반 로썸&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;코드는 쓰이는것보다 읽힐때가 훨씬 많습니다. &lt;br&gt;&lt;/p&gt;
&lt;p&gt;PEP8에 제시되는 가이드라인은 코드의 가독성 향상과,  파이썬 코드 전반에 걸쳐서 일관성을 만들어 가는것입니다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="PEP8-A-foolish-consistency-is-the-Hobgoblin-of-Little-Minds"><a href="#PEP8-A-foolish-consistency-is-the-Hobgoblin-of-Little-Minds" class="headerlink" title="PEP8 - A foolish consistency is the Hobgoblin of Little Minds"></a>PEP8 - A foolish consistency is the Hobgoblin of Little Minds</h1><br><p>PEP8 스타일 가이드라인의 두번째 토픽입니다. </p><p><br> 타이틀을 직역해보면, <br></p><blockquote><p>어리석은 일관성은 </p><p>소심한 홉고블린이다? </p></blockquote><br><p>서양에서는, 홉고블린이 사악하고, 아둔한 그런데 또 피지컬은 또 없는 그런 요괴로 취급됩니다. </p><br><p><strong>다시 말해서, 잘못된 코딩 스타일 일관성은 고블린 취급받기 쉽단 얘기겠죠?</strong> </p><p><br><br></p><blockquote><p>코드는 쓰이는것보다 읽히는 일이 많다.</p><p>by 파이썬 창시자 귀도 반 로썸</p></blockquote><br><p>코드는 쓰이는것보다 읽힐때가 훨씬 많습니다. <br></p><p>PEP8에 제시되는 가이드라인은 코드의 가독성 향상과,  파이썬 코드 전반에 걸쳐서 일관성을 만들어 가는것입니다.</p><a id="more"></a><br><br><h2 id="Consistency-일관성"><a href="#Consistency-일관성" class="headerlink" title="Consistency (일관성)"></a>Consistency (일관성)</h2><br><p>PEP8 스타일 가이드는 일관성에 대한 것입니다. <br></p><p>PEP8에 나와있는 스타일 가이드와 일관되게 따르는것은 중요합니다. </p><br><blockquote><p>하지만! </p><p>프로젝트내에 스타일 가이드와 일관되게 코드를 짜는것이 더욱 중요합니다.  </p></blockquote><br><p>각각의 프로젝트 마다, 코딩 스타일이 다르고. PEP8 은 프로젝트 마다의 코딩 스타일을 존중합니다. <br></p><p>PEP8은 가이드라인을 제시할뿐이지. 그 가이드라인을 의무화 하지는 않습니다. </p><br><p>따라서, 프로젝트내에 일관된 코드가 있다면, 더 좋은 코딩 스타일이 존재한다면,<br></p><p><br>그 프로젝트 내의 코딩 스타일과 일관되게 코드를 작성하는것이 좋습니다. </p><br><h2 id="일관되지-않을때를-알아야-합니다"><a href="#일관되지-않을때를-알아야-합니다" class="headerlink" title="일관되지 않을때를 알아야 합니다"></a>일관되지 않을때를 알아야 합니다</h2><br><p>위에서 언급하였듯이, PEP8 의 스타일 가이드가 프로젝트에 잘 적용 될수 없을때는.<br> 본인의 판단하에, 다른 예시들을 보고 어떤게 제일 좋게 보이는 스타일을 선택하면 됩니다.</p><br><blockquote><p>PEP를 따르기 위해서, 뒤로 퇴보하지는 않아야 합니다. </p></blockquote><br><br><p><strong>가이드라인을 무시할수 있는 사유들</strong></p><br><br><p>1) PEP를 적용했을때에 가독성이 더 떨어지는 경우 </p><p>2) 이미 PEP가 적용되지 않은 코드가 주변에 너무 많이 존재할때 (예, 너무 과거에 쓰여진 코드들)</p><p>3) 해당 코드가 이미 PEP8이 소개되기 이전인데, 해당 코드를 바꿀 이유가 별로 없을때 </p><p>4) 해당 코드가 파이썬의 이전버전과 호환하기 위해 필요한데, 가이드라인에 제시되어 있는 기능을 지원하지 않을때 </p><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>정리하자면, PEP8 은 가이드라인일 뿐이고. <br> 본인이나 팀의 판단에 따라서. 프로젝트에 적용할지 안할지를 정하면 될것 같습니다. </p><br><p>개인적으로 저는 따르는게 좋다고 생각합니다. <br></p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/04/04/PEP8-A-Foolish-Consistency-is-the-Hobgoblin-of-Little-Minds/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
