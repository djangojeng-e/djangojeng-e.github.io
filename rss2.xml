<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>장고쟁이</title>
    <link>http://djangojeng-e.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>장고쟁이의 Python, Django 공부 노트</description>
    <pubDate>Tue, 18 Aug 2020 11:11:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Django Models 19편 - Model 상속 Multi-table inheritance 2편</title>
      <link>http://djangojeng-e.github.io/2020/08/18/Django-Models-19%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Multi-table-inheritance-2%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/08/18/Django-Models-19%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Multi-table-inheritance-2%ED%8E%B8/</guid>
      <pubDate>Tue, 18 Aug 2020 11:02:05 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Multi-table-inheritance-2편&quot;&gt;&lt;a href=&quot;#Multi-table-inheritance-2편&quot; class=&quot;headerlink&quot; title=&quot;Multi-table inheritance 2편&quot;&gt;&lt;/a&gt;Multi-table inheritance 2편&lt;/h2&gt;&lt;br&gt;

&lt;h3 id=&quot;Inheritance-and-reverse-relations&quot;&gt;&lt;a href=&quot;#Inheritance-and-reverse-relations&quot; class=&quot;headerlink&quot; title=&quot;Inheritance and reverse relations&quot;&gt;&lt;/a&gt;Inheritance and reverse relations&lt;/h3&gt;&lt;br&gt;

&lt;p&gt;multi-table 상속은 암시적으로, OneToOneField 를 사용하여 자식 클래스와 부모 클래스를 연결해 주기 때문에, 부모 클래스에서 자식 클래스로 이동이 가능해 집니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;하지만, 이는 ForeignKey 와 ManyToManyField 관계들을 위한 기본 related_name 값을 사용합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;만일 우리가, ForeignKey 나 ManyToManyField 관게들을 부모의 서브클래스에 넣어준다면, 각 필드에 related_name 속성들을 지정해 주어야 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;각 필드에 이 relate_name 속성을 지정해 주지 않는다면, Django는 유효성 에러를 발생 시킬겁니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Multi-table-inheritance-2편"><a href="#Multi-table-inheritance-2편" class="headerlink" title="Multi-table inheritance 2편"></a>Multi-table inheritance 2편</h2><br><h3 id="Inheritance-and-reverse-relations"><a href="#Inheritance-and-reverse-relations" class="headerlink" title="Inheritance and reverse relations"></a>Inheritance and reverse relations</h3><br><p>multi-table 상속은 암시적으로, OneToOneField 를 사용하여 자식 클래스와 부모 클래스를 연결해 주기 때문에, 부모 클래스에서 자식 클래스로 이동이 가능해 집니다. </p><br><p>하지만, 이는 ForeignKey 와 ManyToManyField 관계들을 위한 기본 related_name 값을 사용합니다. </p><br><p>만일 우리가, ForeignKey 나 ManyToManyField 관게들을 부모의 서브클래스에 넣어준다면, 각 필드에 related_name 속성들을 지정해 주어야 합니다. </p><br><p>각 필드에 이 relate_name 속성을 지정해 주지 않는다면, Django는 유효성 에러를 발생 시킬겁니다. </p><br><br><a id="more"></a><br><p>예시를 들면, </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Place</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">80</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(Place)</span>:</span></span><br><span class="line">    serves_hot_dogs = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    serves_pizza = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 새로운 서브 클래스 추가 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Supplier</span><span class="params">(Place)</span>:</span></span><br><span class="line">    customers = models.ManyToManyField(Place)</span><br></pre></td></tr></table></figure><br><p>이렇게 코드를 짜면, 에러를 발생 시킵니다. </p><p><br>새로운 클래스를 추가하고, python manage.py makemigraitons 를 실행하면, 아래와 같은 에러가 출력 됩니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(django-tutorial)  dhkang  ~/django_tutorial/django_docs master python manage.py makemigrations</span><br><span class="line">SystemCheckError: System check identified some issues:</span><br><span class="line"></span><br><span class="line">ERRORS:</span><br><span class="line">multitableinheritance.Supplier.customers: (fields.E305) Reverse query name </span><br><span class="line">for 'Supplier.customers' clashes with reverse query name for 'Supplier.place_ptr'.</span><br><span class="line">        HINT: Add or change a related_name argument to the definition for </span><br><span class="line">'Supplier.customers' or 'Supplier.place_ptr'.</span><br></pre></td></tr></table></figure><br><br><blockquote><p>related_name 을 아래와 같이 customers 필드에 추가를 하면, 에러가 해결됩니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Place</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">80</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(Place)</span>:</span></span><br><span class="line">    serves_hot_dogs = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    serves_pizza = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 새로운 서브 클래스 추가 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Supplier</span><span class="params">(Place)</span>:</span></span><br><span class="line">    customers = models.ManyToManyField(Place, related_name=<span class="string">'provider'</span>)</span><br><span class="line">    <span class="comment"># related_name='provider' 라고 지정을 해줌</span></span><br></pre></td></tr></table></figure><br><p><code>related_name</code> 을 지정해주고, python manage.py makemigrations 를 실행해주면, migrations 가 생성됩니다.<br><br></p><h3 id="Specifying-the-parent-link-field"><a href="#Specifying-the-parent-link-field" class="headerlink" title="Specifying the parent link field"></a>Specifying the parent link field</h3><br><p>이전에도 언급되었듯이, django 는 자동적으로 OneToONeField 를 사용하여, 자식 클래스를 Abstract base 클래스가 아닌 부모 클래스 모델에 연결해 줍니다. 만약 부모와 연결되는 속성들의 이름을 제어하고 싶다면, 스스로 OneToOneField 를 생성하고, parent_link = True 로 설정하여, 당신의 필드가 부모 클래스에 뒤쪽으로 연결 된다는것을 표시할수 있습니다.<br><br></p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/18/Django-Models-19%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Multi-table-inheritance-2%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 19편 - Model 상속 Multi-table inheritance 1편</title>
      <link>http://djangojeng-e.github.io/2020/08/17/Django-Models-19%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Multi-table-inheritance-1%ED%8E%B8/</link>
      <guid>http://djangojeng-e.github.io/2020/08/17/Django-Models-19%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Multi-table-inheritance-1%ED%8E%B8/</guid>
      <pubDate>Mon, 17 Aug 2020 07:11:53 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Model-상속-Multi-table-inheritance&quot;&gt;&lt;a href=&quot;#Model-상속-Multi-table-inheritance&quot; class=&quot;headerlink&quot; title=&quot;Model 상속 (Multi-table inheritance )&quot;&gt;&lt;/a&gt;Model 상속 (Multi-table inheritance )&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;Django 모델을 상속 받는데에 있어서 3가지 스타일이 존재합니다. &lt;/p&gt;
&lt;br&gt;

&lt;ol&gt;
&lt;li&gt;Abstract base classes &lt;/li&gt;
&lt;li&gt;Multi-table inheritance&lt;/li&gt;
&lt;li&gt;Proxy Models &lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;h3 id=&quot;Multi-table-inheritance&quot;&gt;&lt;a href=&quot;#Multi-table-inheritance&quot; class=&quot;headerlink&quot; title=&quot;Multi-table inheritance&quot;&gt;&lt;/a&gt;Multi-table inheritance&lt;/h3&gt;&lt;br&gt;

&lt;p&gt;Django 모델에서 지원하는 두번째 모델 상속 방식은, Multi-table inheritance 입니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;각 모델이 계층구조에서, 자체적으로 모델일 경우 입니다. &lt;/p&gt;
&lt;p&gt;각 모델은 각자의 데이터베이스 테이블에 해당 되고, 각각 쿼리문을 보내거나 생성될수 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;상속 관계는, 자식 모델과 부모 모델의 연결고리를 만들어 놓습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;예를들면,
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Model-상속-Multi-table-inheritance"><a href="#Model-상속-Multi-table-inheritance" class="headerlink" title="Model 상속 (Multi-table inheritance )"></a>Model 상속 (Multi-table inheritance )</h2><br><p>Django 모델을 상속 받는데에 있어서 3가지 스타일이 존재합니다. </p><br><ol><li>Abstract base classes </li><li>Multi-table inheritance</li><li>Proxy Models </li></ol><br><h3 id="Multi-table-inheritance"><a href="#Multi-table-inheritance" class="headerlink" title="Multi-table inheritance"></a>Multi-table inheritance</h3><br><p>Django 모델에서 지원하는 두번째 모델 상속 방식은, Multi-table inheritance 입니다. </p><p><br>각 모델이 계층구조에서, 자체적으로 모델일 경우 입니다. </p><p>각 모델은 각자의 데이터베이스 테이블에 해당 되고, 각각 쿼리문을 보내거나 생성될수 있습니다. </p><br><p>상속 관계는, 자식 모델과 부모 모델의 연결고리를 만들어 놓습니다. </p><br><p>예를들면, <a id="more"></a></p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Place</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">80</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(Place)</span>:</span></span><br><span class="line">    serves_hot_dogs = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    serves_pizza = models.BooleanField(default=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><br><p>Place 의 모든 필드들은, Restaurant 에서도 사용할수 있습니다. </p><p><br>하지만, 데이터는 다른 데이터베이스 테이블에 존재하게 됩니다. 따라서, 아래 상황들 둘다 가능합니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Place.objects.filter(name=<span class="string">"Bob's Cafe"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Restaurant.objects.filter(name=<span class="string">"Bob's Cafe"</span>)</span></span><br><span class="line"></span><br><span class="line">In [1]: bobscafe = Place.objects.create(name="Bob's Cafe", address="Bob ba di rara")                                                                                      </span><br><span class="line"></span><br><span class="line">In [2]: Place.objects.filter(name="Bob's Cafe")                                                                                                                           </span><br><span class="line">Out[2]: &lt;QuerySet [&lt;Place: Place object (1)&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [3]: Restaurant.objects.filter(name="Bob's Cafe")                                                                                                                      </span><br><span class="line">Out[3]: &lt;QuerySet []&gt;</span><br></pre></td></tr></table></figure><br><p>만약 Place 이면서, Restaurant 인 경우, </p><p><br>Place 객체에서 Restaurant 객체를 얻을수 있는데, 모델 이름의 소문자 형태를 사용하여 얻을수 있습니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [4]: p = Restaurant.objects.create(name="pizza hut", address="789 Hume Highway", serves_hot_dogs=False, serves_pizza=True)                                             </span><br><span class="line"></span><br><span class="line">In [5]: Place.objects.all()                                                                                                                                               </span><br><span class="line">Out[5]: &lt;QuerySet [&lt;Place: Place object (1)&gt;, &lt;Place: Place object (2)&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [7]: Restaurant.objects.all()                                                                                                                                          </span><br><span class="line">Out[7]: &lt;QuerySet [&lt;Restaurant: Restaurant object (2)&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [8]: p = Place.objects.get(id=2)    # p 가 Restaurant 객체 일때, 자식 클래스를 제공한다                                                                                                                                    </span><br><span class="line"></span><br><span class="line">In [10]: p.restaurant                                                                                                                                                     </span><br><span class="line">Out[10]: &lt;Restaurant: Restaurant object (2)&gt;</span><br></pre></td></tr></table></figure><br><p>하지만, 위 예제에서, p  라는 인스턴스가 Restaurant 이 아니라, Place 객체로 직접 생성 되었다면, </p><p><code>p.restaurant</code> 은 Restaurant DoesNotExist 예외를 발생 시켰을 겁니다. </p><p><br> Restaurant 을 Place 에 연결해 주는, 자동 생성된 OneToOneField 는 아래와 같이 생겼습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Place_ptr = models.OneToOneField(</span><br><span class="line">    Place, on_delete=models.CASCADE, </span><br><span class="line">    parent_link = <span class="literal">True</span>, </span><br><span class="line">    primary_key = <span class="literal">True</span>, </span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><p>Restaurant 에서 OneToOneField 의 paraent_link=True 로 설정해 줌으로써, 필드를 오버라이드 할수 있습니다. </p><br><h3 id="Meta-and-Multi-table-inheritance"><a href="#Meta-and-Multi-table-inheritance" class="headerlink" title="Meta and Multi-table inheritance"></a>Meta and Multi-table inheritance</h3><br><p>multi-table 상속 상황속에서는, 자식 클래스가 부모의 Meta 클래스를 상속 받는게 있을수 없는 일입니다. </p><p><br>모든 Meta 옵션들은 이미 부모 클래스에 적용 되어 있고, 이것을 다시 적용 한다는것은 단지 모순된 동작으로 이어지게 할 뿐입니다. </p><br><p>따라서, 자식 모델은, 부모의 Meta 클래스에 접근할수 없습니다. 그렇지만, 자식 모델이 부모 모델의 동작을 상속받는 몇가지 제한적 경우가 있습니다. </p><br><blockquote><p>만약, </p><p>자식 모델이 ordering 속성 혹은 get_latest_by 속성을 지정하고 있지 않다면, </p><p>이 속성들을 부모 클래스에서 상속 받을수 있습니다. </p></blockquote><br><p>만약 부모 모델이  ordering 을 가지고 있고, 자식 모델이 자연스러운 ordering 을 가지게 하고 싶으면, </p><p><br>명시적으로 비활성화를 시켜주면 됩니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildModel</span><span class="params">(ParentModel)</span>:</span></span><br><span class="line">    <span class="comment"># ... </span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 부모 모델의 ordering 을 제거 해주기 </span></span><br><span class="line">        ordering = []</span><br></pre></td></tr></table></figure><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/17/Django-Models-19%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Multi-table-inheritance-1%ED%8E%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 18편 - Model 상속 related_name, related_query_name</title>
      <link>http://djangojeng-e.github.io/2020/08/16/Django-Models-18%ED%8E%B8-Model-%EC%83%81%EC%86%8D-related-name-related-query-name/</link>
      <guid>http://djangojeng-e.github.io/2020/08/16/Django-Models-18%ED%8E%B8-Model-%EC%83%81%EC%86%8D-related-name-related-query-name/</guid>
      <pubDate>Sun, 16 Aug 2020 08:44:39 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Be-careful-with-related-name-and-related-query-name&quot;&gt;&lt;a href=&quot;#Be-careful-with-related-name-and-related-query-name&quot; class=&quot;headerlink&quot; title=&quot;Be careful with related_name and related_query_name&quot;&gt;&lt;/a&gt;Be careful with related_name and related_query_name&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;만약 우리가 ForeginKey 나 ManyToManyField 에 related_name 혹은 related_query_name 을 사용하고 있다면, 우리는 언제나 고유한 reverse name 과 query name 들을 해당 필드에 지정해 주어야 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;이 related_name 과 related_query_name 부분에 대해서, 아주 심도있게 clarification 한 곳이 없으므로. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;예시만 보고 지나갑니다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Be-careful-with-related-name-and-related-query-name"><a href="#Be-careful-with-related-name-and-related-query-name" class="headerlink" title="Be careful with related_name and related_query_name"></a>Be careful with related_name and related_query_name</h2><br><p>만약 우리가 ForeginKey 나 ManyToManyField 에 related_name 혹은 related_query_name 을 사용하고 있다면, 우리는 언제나 고유한 reverse name 과 query name 들을 해당 필드에 지정해 주어야 합니다. </p><br><p>이 related_name 과 related_query_name 부분에 대해서, 아주 심도있게 clarification 한 곳이 없으므로. </p><br><p>예시만 보고 지나갑니다. </p><a id="more"></a><br><p>common/models.py </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    m2m = models.ManyToManyField(</span><br><span class="line">    OtherModel, </span><br><span class="line">    related_name = <span class="string">"%(app_label)s_%(class)s_related"</span>,</span><br><span class="line">    related_query_name = <span class="string">"%(app_label)s_%(class)ss"</span>,</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span> </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChilA</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line">class ChildB(Base);</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><br><p>다른 앱도 같이 주어 집니다 rare/models.py </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> common.models <span class="keyword">import</span> Base</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildB</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><br><blockquote><p>common.ChilA.m2m 필드의 역방향 이름은, </p><p>common_childa_related 이고, </p><p>역방향 쿼리 이름은, common_childas 가 될것입니다. </p><br><p>common.ChildB.m2m  필드의 역방향 이름은, </p><p>common_childb_related 이고, </p><p>역방향 쿼리 이름은, common_childbs 가 될것입니다. </p><br><p>마지막으로, </p><br><p>rare.childB.m2m 의 역방향 이름은, rare_childb_related 가 되고, </p><p>역방향 쿼리 이름은, rare_childbs 가 될것입니다. </p></blockquote><br><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/16/Django-Models-18%ED%8E%B8-Model-%EC%83%81%EC%86%8D-related-name-related-query-name/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 17편 - Model 상속 (Abstract Base Class) 2</title>
      <link>http://djangojeng-e.github.io/2020/08/15/Django-Models-17%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Abstract-Base-Class-2/</link>
      <guid>http://djangojeng-e.github.io/2020/08/15/Django-Models-17%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Abstract-Base-Class-2/</guid>
      <pubDate>Sat, 15 Aug 2020 05:40:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Meta-Inheritance&quot;&gt;&lt;a href=&quot;#Meta-Inheritance&quot; class=&quot;headerlink&quot; title=&quot;Meta Inheritance&quot;&gt;&lt;/a&gt;Meta Inheritance&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;&lt;code&gt;ab
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Meta-Inheritance"><a href="#Meta-Inheritance" class="headerlink" title="Meta Inheritance"></a>Meta Inheritance</h2><br><p><code>abstract base class</code>가 생성될때에, django 는 base class 안에 선언된 Meta 클래스를 속성으로 만들어 줍니다. 만약 하나의 자식 클래스안에, 해당 자식 클래스를 위한 Meta class 가 정의되어 있지 않다면, 부모의 Meta 를 상속 받을것 입니다. </p><br><blockquote><p>만약 자식 클래스가, 부모의 Meta 클래스를 확장하고 싶다면, </p><p>자식  클래스는, 부모의 Meta 클래스를 자식 클래스 내에 있는 Meta 에서 상속 받으면 됩니다. </p></blockquote><br><p>코드 예시를 들자면, </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.PositiveIntegerField()</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span> </span><br><span class="line">        ordering = [<span class="string">'name'</span>]</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(CommonInfo)</span>:</span></span><br><span class="line">    home_group = models.CharField(max_length=<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(CommonInfo.Meta)</span>:</span></span><br><span class="line">        db_table = <span class="string">'student_info'</span></span><br></pre></td></tr></table></figure><br><p>Django 는 기본적으로, abstract base 클래스의 Meta class 에 대한 조정사항을 가집니다. Meta 속성을 설치하기 이전에, abstract=False 로 지정합니다. </p><br><p>이것이 의미하는바는, <br></p><p>abstract 클래스의 자녀들은 자동으로 그리고 스스로는 abstract 클래스가 되지 않는다는것을 의미합니다.</p><br><p>물론, 다른 abstract 클래스를 상속받는 Abstract 클래스를 만드는것도 가능합니다. </p><p>단지 만들때마다, 명시적으로, abstract=True 를 지정해주는것만이 필요할 뿐입니다. </p><br><p>어떠한 속성들은 Abstract base class 의 Meta 안에 포함되는것이 이상해 보일때가 있습니다. </p><p><br>예를들면, db_table 을 포함한다면, 모든 자식 클래스들이 같은 데이터베이스 테이블을 사용하게 된다는 의미가 됩니다. 이렇게 설정하면, 매우 일이 이상해 집니다. </p><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>자식 클래스에 있는 Meta Class 도 부모 클래스에 있는 Meta 클래스를 상속 받을수 있습니다. </p><br><p>연습도 해볼겸, 인스턴스 생성후, 속성값들을 확인해 봅니다. </p><br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">1</span>]: colin = Student.objects.create(name=<span class="string">"Colin Firth"</span>, age=<span class="number">60</span>, home_group=<span class="string">"king"</span>)                                                                                     </span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">2</span>]: colin.Meta                                                                                                                                                        </span><br><span class="line">Out[<span class="number">2</span>]: abstractbaseclasses.models.CommonInfo.Meta</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">4</span>]: colin.name                                                                                                                                                        </span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">'Colin Firth'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">5</span>]: colin.age                                                                                                                                                         </span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">60</span></span><br></pre></td></tr></table></figure><br><p>Student class 안에 Meta 클래스에 db_table 이 데이터베이스 테이블 명이 된것을 확인할수 있습니다. </p><br><p>CommonInfo 클래스 안에 존재하는 Meta 클래스에, 이 db_table 속성을 넣어두면, </p><p>CommonInfo 클래스를 상속하는 모든 자식 클래스들의 데이터베이스 테이블명이 모두 하나로 동일하게 될겁니다. 그렇게 되면, 조금 이상한 일이 될겁니다. </p><br><br><br><br><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/15/Django-Models-17%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Abstract-Base-Class-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 17편 - Model 상속 (Abstract Base Class) 1</title>
      <link>http://djangojeng-e.github.io/2020/08/14/Django-Models-17%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Abstract-Base-Class-1/</link>
      <guid>http://djangojeng-e.github.io/2020/08/14/Django-Models-17%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Abstract-Base-Class-1/</guid>
      <pubDate>Fri, 14 Aug 2020 08:41:36 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Model-Inheritance-Abstract-Base-Classes&quot;&gt;&lt;a href=&quot;#Model-Inheritance-Abstract-Base-Classes&quot; class=&quot;headerlink&quot; title=&quot;Model Inheritance (Abstract Base Classes)&quot;&gt;&lt;/a&gt;Model Inheritance (Abstract Base Classes)&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;&lt;code&gt;Abstract Base classes&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;

&lt;p&gt;Abstract base 클래스들은, 여러분들이 어떠한 공통된 정보들을, 다른 모델들에 넣고 싶을때에 유용하게 쓸수 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;Base 클래스를 작성한다음, &lt;code&gt;Meta class&lt;/code&gt; 에다가, &lt;code&gt;abstract=True&lt;/code&gt;  로 설정합니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;그러면, 해당 모델은, 데이터베이스를 생성하는데에 사용되지 않습니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;다른 모델들의 Base 클래스로 사용될때에는, &lt;/p&gt;
&lt;p&gt;Base 클래스의 필드들이 자식 클래스들에 추가 됩니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;예시를 들자면, &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Model-Inheritance-Abstract-Base-Classes"><a href="#Model-Inheritance-Abstract-Base-Classes" class="headerlink" title="Model Inheritance (Abstract Base Classes)"></a>Model Inheritance (Abstract Base Classes)</h2><br><p><code>Abstract Base classes</code></p><br><p>Abstract base 클래스들은, 여러분들이 어떠한 공통된 정보들을, 다른 모델들에 넣고 싶을때에 유용하게 쓸수 있습니다. </p><br><p>Base 클래스를 작성한다음, <code>Meta class</code> 에다가, <code>abstract=True</code>  로 설정합니다. </p><p><br>그러면, 해당 모델은, 데이터베이스를 생성하는데에 사용되지 않습니다. </p><br><blockquote><p>다른 모델들의 Base 클래스로 사용될때에는, </p><p>Base 클래스의 필드들이 자식 클래스들에 추가 됩니다. </p></blockquote><br><p>예시를 들자면, </p><br><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.PositiveIntegerField()</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span> </span><br><span class="line">        <span class="comment"># class Meta 를 선언함으로써, 다른 모델들이 상속 받을수 있는 모델이 됨 </span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(CommonInfo)</span>:</span></span><br><span class="line">    <span class="comment"># 공통된 정보를 가지고 있는 CommonInfo 클래스를 상속받는 Student 클래스 모델 </span></span><br><span class="line">    home_group = models.CharField(max_length=<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(CommonInfo)</span>:</span></span><br><span class="line">    <span class="comment"># 공통된 정보를 가지고 있는 CommonInfo 클래스를 상속받는 Teacher 클래스 모델 </span></span><br><span class="line">    teaching_subject = models.CharField(max_length=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><br><p>위의 예시에서, CommonInfo 클래스에 있는 name 과 age 필드는, </p><p>Student 모델과, Teacher 모델이 상속받는 필드입니다. </p><br><p>따라서, Student 모델은 3가지 필드들을 갖게 됩니다. name, age 그리고 home_group. </p><p>비슷한 의미로, Teacher 모델은 name, age 그리고 teaching_subject 필드를 갖게 됩니다. </p><br><blockquote><p>CommonInfo 모델은 abstract base 클래스 이기 때문에, </p><p>CommonInfo 모델은 일반 Django 모델로 사용될수 없습니다. </p><br><p>CommonInfo 모델은 데이터베이스 테이블을 생성하지도 않고, manager 도 갖지 않습니다 (object  메서드를 가지지 않습니다). 그리고, 직접적인 인스턴스 생성과 저장도 되지 않습니다. </p></blockquote><br><p>abstract base class 에서 상속받은 필드들은 다른 필드 혹은 값으로 override 될수 있습니다. </p><p><br>혹은, None 으로 제거 될수 있습니다. </p><br><p><code>abstract base</code> 클래스 상속 방식은, 공통된 정보를 파이썬 레벨에 두고, </p><p>각각의 자식 모델마다 한개의 데이터베이스 테이블을 데이터베이스에 생성합니다. </p><br><p>실제로 위의 예시에서 CommonInfo 클래스로 Shell 에 들어가서, 몇가지 명령어를 실행해보면, 에러가 납니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [1]: common = CommonInfo.objects.create(name="django", age=22)                                                                                                         </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-1-8d6637697465&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta">----&gt;</span><span class="bash"> 1 common = CommonInfo.objects.create(name=<span class="string">"django"</span>, age=22)</span></span><br><span class="line"></span><br><span class="line">NameError: name 'CommonInfo' is not defined</span><br><span class="line"></span><br><span class="line">In [2]: CommonInfo.objects.all()                                                                                                                                          </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-2-fc35ec638311&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta">----&gt;</span><span class="bash"> 1 CommonInfo.objects.all()</span></span><br><span class="line"></span><br><span class="line">NameError: name 'CommonInfo' is not defined</span><br><span class="line"></span><br><span class="line">In [3]: c = CommonInfo()                                                                                                                                                  </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-3-2542378fc97f&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta">----&gt;</span><span class="bash"> 1 c = CommonInfo()</span></span><br><span class="line"></span><br><span class="line">NameError: name 'CommonInfo' is not defined</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/14/Django-Models-17%ED%8E%B8-Model-%EC%83%81%EC%86%8D-Abstract-Base-Class-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 16편 - Model Inheritance</title>
      <link>http://djangojeng-e.github.io/2020/08/13/Django-Models-16%ED%8E%B8-Model-Inheritance/</link>
      <guid>http://djangojeng-e.github.io/2020/08/13/Django-Models-16%ED%8E%B8-Model-Inheritance/</guid>
      <pubDate>Thu, 13 Aug 2020 14:08:09 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Model-Inheritance-모델-상속&quot;&gt;&lt;a href=&quot;#Model-Inheritance-모델-상속&quot; class=&quot;headerlink&quot; title=&quot;Model Inheritance (모델 상속)&quot;&gt;&lt;/a&gt;Model Inheritance (모델 상속)&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;Django 에서 모델 상속은, 파이썬에서 일반적인 클래스 상속을 하는것과 거의 비슷하게 작동합니다.  &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;다만, django 의 기본에는 충실해야 합니다. 이것이 의미하는것은, Django 모델 클래스들은 &lt;code&gt;django.db.models.Model&lt;/code&gt; 의 서브 클래스가 되어야 한다는 이야기 입니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;여러분들이 결정해야 할 사항은 아래와 같습니다. &lt;/p&gt;
&lt;br&gt;

&lt;ol&gt;
&lt;li&gt;부모 모델이 자신의 모델이 될지 &lt;/li&gt;
&lt;li&gt;부모 모델은 단지 공통된 정보를 가지고, 자식 모델들을 통해서만 정보가 보이게 하게 할지 &lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;p&gt;이 개념을 쉽게 이해하기 위해서는, 파이썬에서 클래스의 상속 개념을 잘 알고 있어야 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;Django 에서는 상속에 대한 3가지 스타일들이 존재 합니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;ol&gt;
&lt;li&gt;보통은, 자식 모델들의 필드에 대해서 타이핑 하기 싫을때, 부모 클래스가 정보만 가지게끔 사용할수 있습니다. 이 클래스는 절대로 분리되서 사용될수 없습니다. 따라서, &lt;code&gt;Abstract base classes&lt;/code&gt; 들이 당신이 원하는것이 될겁니다. &lt;/li&gt;
&lt;li&gt;이미 존재하는 모델 (다른 어플리케이션에 있는 모델)을 상속을 받고 있고, 각 모델이 각자의 데이터베이스 테이블을 가지고 있다면, &lt;code&gt;Multi-table inheritance&lt;/code&gt; 를 사용할수 있습니다.&lt;/li&gt;
&lt;li&gt;모델 필드의 수정 없이, 모델의 파이썬 레벨 동작을 고치고 싶다면, &lt;code&gt;proxy models&lt;/code&gt; 를 사용하면 됩니다.  &lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Model-Inheritance-모델-상속"><a href="#Model-Inheritance-모델-상속" class="headerlink" title="Model Inheritance (모델 상속)"></a>Model Inheritance (모델 상속)</h2><br><p>Django 에서 모델 상속은, 파이썬에서 일반적인 클래스 상속을 하는것과 거의 비슷하게 작동합니다.  </p><br><p>다만, django 의 기본에는 충실해야 합니다. 이것이 의미하는것은, Django 모델 클래스들은 <code>django.db.models.Model</code> 의 서브 클래스가 되어야 한다는 이야기 입니다. </p><br><p>여러분들이 결정해야 할 사항은 아래와 같습니다. </p><br><ol><li>부모 모델이 자신의 모델이 될지 </li><li>부모 모델은 단지 공통된 정보를 가지고, 자식 모델들을 통해서만 정보가 보이게 하게 할지 </li></ol><br><p>이 개념을 쉽게 이해하기 위해서는, 파이썬에서 클래스의 상속 개념을 잘 알고 있어야 합니다. </p><br><br><blockquote><p>Django 에서는 상속에 대한 3가지 스타일들이 존재 합니다. </p></blockquote><br><ol><li>보통은, 자식 모델들의 필드에 대해서 타이핑 하기 싫을때, 부모 클래스가 정보만 가지게끔 사용할수 있습니다. 이 클래스는 절대로 분리되서 사용될수 없습니다. 따라서, <code>Abstract base classes</code> 들이 당신이 원하는것이 될겁니다. </li><li>이미 존재하는 모델 (다른 어플리케이션에 있는 모델)을 상속을 받고 있고, 각 모델이 각자의 데이터베이스 테이블을 가지고 있다면, <code>Multi-table inheritance</code> 를 사용할수 있습니다.</li><li>모델 필드의 수정 없이, 모델의 파이썬 레벨 동작을 고치고 싶다면, <code>proxy models</code> 를 사용하면 됩니다.  </li></ol><br><a id="more"></a><br><p>정리하자면, </p><br><blockquote><p>Django 에서 모델 상속에 대해, 아래 3가지 스타일이 존재합니다. </p><br><p>1) Abstract base classes </p><p>2) Multi-table inheritance </p><p>3) Proxy models </p></blockquote><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/13/Django-Models-16%ED%8E%B8-Model-Inheritance/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 15편 - 이미 정의된 모델 메서드 오버라이드 하기</title>
      <link>http://djangojeng-e.github.io/2020/08/12/Django-Models-15%ED%8E%B8-%EC%9D%B4%EB%AF%B8-%EC%A0%95%EC%9D%98%EB%90%9C-%EB%AA%A8%EB%8D%B8-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%93%9C-%ED%95%98%EA%B8%B0/</link>
      <guid>http://djangojeng-e.github.io/2020/08/12/Django-Models-15%ED%8E%B8-%EC%9D%B4%EB%AF%B8-%EC%A0%95%EC%9D%98%EB%90%9C-%EB%AA%A8%EB%8D%B8-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%93%9C-%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Wed, 12 Aug 2020 03:17:33 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Overriding-predefined-model-methods&quot;&gt;&lt;a href=&quot;#Overriding-predefined-model-methods&quot; class=&quot;headerlink&quot; title=&quot;Overriding predefined model methods&quot;&gt;&lt;/a&gt;Overriding predefined model methods&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;여러분들이 커스터마이즈 하고 싶은 데이터베이스의 동작을 캡슐화 해주는 모델 메서드들도 존재 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;특히 우리는 종종 &lt;code&gt;save()&lt;/code&gt; 와 &lt;code&gt;delete()&lt;/code&gt; 의 동작 방식을 바꾸고 싶어 집니다.  &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;save() 나 delete() 같은 메서드들을 override 해서 동작 방식을 바꾸는것도 가능하고,&lt;/p&gt;
&lt;p&gt;다른 어떤 모델 메서드들을 override 해서 사용하는것도 가능합니다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;내장된 메서드, &lt;code&gt;save()&lt;/code&gt; 같은 메서드를 override 하여 사용하는 고전적인 예시는, &lt;/p&gt;
&lt;p&gt;&lt;br&gt;하나의 객체를 저장할때마다 다른 무언가를 발생시키고 싶을 때입니다.&lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Overriding-predefined-model-methods"><a href="#Overriding-predefined-model-methods" class="headerlink" title="Overriding predefined model methods"></a>Overriding predefined model methods</h2><br><p>여러분들이 커스터마이즈 하고 싶은 데이터베이스의 동작을 캡슐화 해주는 모델 메서드들도 존재 합니다. </p><br><p>특히 우리는 종종 <code>save()</code> 와 <code>delete()</code> 의 동작 방식을 바꾸고 싶어 집니다.  </p><br><blockquote><p>save() 나 delete() 같은 메서드들을 override 해서 동작 방식을 바꾸는것도 가능하고,</p><p>다른 어떤 모델 메서드들을 override 해서 사용하는것도 가능합니다.  </p></blockquote><br><p>내장된 메서드, <code>save()</code> 같은 메서드를 override 하여 사용하는 고전적인 예시는, </p><p><br>하나의 객체를 저장할때마다 다른 무언가를 발생시키고 싶을 때입니다.</p><br><a id="more"></a><br><h2 id="Method-override-예시"><a href="#Method-override-예시" class="headerlink" title="Method override 예시"></a>Method override 예시</h2><br><p>예시 코드를 둘러봅니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        do_something()</span><br><span class="line">        super().save(*args, **kwargs)  <span class="comment"># 실제 save() 를 호출 </span></span><br><span class="line">        do_something_else()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># save()를 호출할때, do_something() 부분에 어떠한 작업을 하는 코드를 써주면, </span></span><br><span class="line"><span class="comment"># 실제 save() 가 동작하기 전에, do_something() 을 수행합니다 </span></span><br><span class="line"><span class="comment"># 그리고, save()가 호출 되고 나서는, do_something_else() 부분에 있는 또다른 </span></span><br><span class="line"><span class="comment"># 작업을 해줄수 있습니다.</span></span><br></pre></td></tr></table></figure><br><p><code>def save(self, *args, **kwargs)</code> 를 사용하여, 평범하게 객체를 저장하기 보다는, 다른 작업을 실행하고 저장할수 있는 기능을 가질수 있습니다.  </p><br><blockquote><p>저장하는것을 방지할수도 있습니다 </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    tagline = models.TextField() </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.name == <span class="string">"Yoko One's blog"</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 블로그 이름이 "Yoko One's blog" 이면, save 가 호출 되지 않고 </span></span><br><span class="line">        <span class="comment"># 비어있는값이 return 됩니다 </span></span><br><span class="line">        <span class="comment"># "Yoko One's blog" 가 제목이 아닐경우, else 로 넘어갑니다. </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().save(*args, **kwargs)<span class="comment"># 실제 save()를 호출해서 save() 진행</span></span><br></pre></td></tr></table></figure><br><br><h2 id="super-save-args-kwargs"><a href="#super-save-args-kwargs" class="headerlink" title="super().save(*args, **kwargs)"></a><code>super().save(*args, **kwargs)</code></h2><br><p>처음에는 생소해 보일지 모르지만, </p><br><blockquote><p><code>super().save(*args, **kwargs)</code> 를 통해서, </p><p>superclass 의 메서드를 호출하는것이 중요합니다. </p><p>이것을 호출하여, 객체가 여전히 데이터베이스에 저장되게 하는것이 중요합니다. </p></blockquote><br><p>superclass 메서드를 호출하지 않는다면, 기본적인 저장 동작이 일어나지 않을것이고. </p><p><br>이는 데이터베이스를 건들지 않습니다. </p><br><p>또한, 모델 메서드에 전달된 인자들을 전달하는것도 중요합니다. </p><p><br><code>*args, **kwargs</code> 부분이 이 역할을 수행합니다. <br></p><p>Django 는 때때로, 내장 모델 메서드들의 능력을 확장하고, 새로운 인자들을 추가해줄수 있습니다. </p><br><blockquote><p>정의된 모델안에서, <code>*args</code> 와 <code>**kwargs</code> 를 사용하면, </p><p>인자들이 추가 되었을때, 코드가 자동으로 해당 인자들을 지원합니다.</p></blockquote><br><h2 id="Quick-Note"><a href="#Quick-Note" class="headerlink" title="Quick Note"></a>Quick Note</h2><br><blockquote><p>override 된 모델 메서드들은, 대량으로 운영되는 상황에서는 호출되지 않습니다. </p><br><p>객체를 위한, <code>delete()</code> 메서드는 쿼리셋을 이용해서 대량으로 객체를 지울때에는 호출 되지 않습니다. 혹은, cascading delete 일때도 호출되지 않습니다. </p><br><p>사용자 정의 delete 로직의 실행을 확실시 하고 싶으면, </p><p>pre_delete 그리고/혹은 post_delete 신호를 사용합니다.</p><br><p>안타깝게도, 객체를 대량으로 creating 혹은 updating 하는 작업은 존재하지 않습니다. </p><p>save(), pre_save() 그리고 post_save()  들이 대량으로 작업해야 하는 상황에서는 호출되지 않기 때문입니다.  </p></blockquote><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/12/Django-Models-15%ED%8E%B8-%EC%9D%B4%EB%AF%B8-%EC%A0%95%EC%9D%98%EB%90%9C-%EB%AA%A8%EB%8D%B8-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%93%9C-%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 14편 - Model Methods</title>
      <link>http://djangojeng-e.github.io/2020/08/11/Django-Models-14%ED%8E%B8-Model-Methods/</link>
      <guid>http://djangojeng-e.github.io/2020/08/11/Django-Models-14%ED%8E%B8-Model-Methods/</guid>
      <pubDate>Tue, 11 Aug 2020 07:49:40 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Model-Methods&quot;&gt;&lt;a href=&quot;#Model-Methods&quot; class=&quot;headerlink&quot; title=&quot;Model Methods&quot;&gt;&lt;/a&gt;Model Methods&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;모델 클래스에는,  사용자 정의 메서드를 추가할수 있습니다. (row-level, 즉, 줄 단위)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;Manager 메서드 (objects) 는, table 전체에 적용되고. 모델 메서드들은, 특정한 모델 인스턴스에 적용됩니다.  &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;해당 모델의 인스턴스에 대해서, 특별한 비지니스 로직을 동작하고 싶을때에, 이런 모델 메서드를 사용해서. 하나의 모델에 모아놓고 사용할수 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;아래 예시에는, 몇가지 사용자 정의 메서드가 정의되어 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; models &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    first_name = models.CharField(max_length=&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    last_name = models.CharField(max_length=&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    birth_date = models.DateField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;baby_boomer_status&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# &quot;Returns the person&#39;s baby-boomer status. &quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 해당 사람이, baby_boomer 세대인지 아닌지 판단합니다. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; datetime &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self.birth_date &amp;lt; datetime.datetime(&lt;span class=&quot;number&quot;&gt;1945&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Pre-boomer&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; self.birth_date &amp;lt; datetime.datetime(&lt;span class=&quot;number&quot;&gt;1965&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Baby boomer&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Post-boomer&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @property &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;full_name&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# &quot;Returns the person&#39;s full name&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 해당 사람의 이름을 리턴합니다 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;%s %s&#39;&lt;/span&gt; % (self.first_name, self.last_name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;

&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Model-Methods"><a href="#Model-Methods" class="headerlink" title="Model Methods"></a>Model Methods</h2><br><p>모델 클래스에는,  사용자 정의 메서드를 추가할수 있습니다. (row-level, 즉, 줄 단위)</p><p><br>Manager 메서드 (objects) 는, table 전체에 적용되고. 모델 메서드들은, 특정한 모델 인스턴스에 적용됩니다.  </p><br><p>해당 모델의 인스턴스에 대해서, 특별한 비지니스 로직을 동작하고 싶을때에, 이런 모델 메서드를 사용해서. 하나의 모델에 모아놓고 사용할수 있습니다. </p><br><p>아래 예시에는, 몇가지 사용자 정의 메서드가 정의되어 있습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    birth_date = models.DateField()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">baby_boomer_status</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># "Returns the person's baby-boomer status. "</span></span><br><span class="line">        <span class="comment"># 해당 사람이, baby_boomer 세대인지 아닌지 판단합니다. </span></span><br><span class="line">        <span class="keyword">import</span> datetime </span><br><span class="line">        <span class="keyword">if</span> self.birth_date &lt; datetime.datetime(<span class="number">1945</span>, <span class="number">8</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Pre-boomer"</span></span><br><span class="line">        <span class="keyword">elif</span> self.birth_date &lt; datetime.datetime(<span class="number">1965</span>, <span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Baby boomer"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Post-boomer"</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">full_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># "Returns the person's full name"</span></span><br><span class="line">        <span class="comment"># 해당 사람의 이름을 리턴합니다 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s %s'</span> % (self.first_name, self.last_name)</span><br></pre></td></tr></table></figure><br><br><a id="more"></a><br><p>예시에서, 마지막으로 작성된 <code>def full_name(self)</code> 메서드는, property 입니다. </p><br><p>모델 인스턴스는 자동으로 각 모델에 부여된 메서드의 목록을 가지고 있고. </p><p><br>아래 예시에서 보면, colin 이라는 인스턴스가 모델에 정의된 메서드들을 사용할수 있다는것을 확인합니다. <br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">colin = Person.objects.create(first_name="colin", last_name="firth", birth_date="1961-10-07")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> colin 이라는 객체를 가져옴 </span></span><br><span class="line">colin = Person.objects.get(first_name="colin")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> colin 이라는 인스턴스의 baby_boomer_status 메서드를 호출 </span></span><br><span class="line">colin.baby_boomer_status </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> colin 이라는 인스턴스의 full_name 메서드를 호출 </span></span><br><span class="line">colin.full_name</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="str-메서드"><a href="#str-메서드" class="headerlink" title="__str__() 메서드"></a><code>__str__()</code> 메서드</h2><br><p>객체의 문자열 표시를 반환하는 파이썬 <code>magic method</code> (매직 메서드) 입니다. 이 메서드는 파이썬과 장고가 언제든 모델 인스턴스가 순수한 문자열로 표시되길 원할때에 사용됩니다. </p><br><blockquote><p> <code>__str__()</code> 메서드를 사용하면, 해당 모델 인스턴스를 문자열로 표시해서 반환할수 있습니다. </p></blockquote><br><p>이 메서드는 아주 많이, 많이, 많이, 그리고 자주, 사용되는 메서드입니다.  </p><br><h2 id="get-absolute-url"><a href="#get-absolute-url" class="headerlink" title="get_absolute_url()"></a><code>get_absolute_url()</code></h2><br><p>이 메서드는 Django 에게 어떻게 객체에 대한 URL 을 계산해야 하는지 얘기해 줍니다. </p><p><br>Django 는 이 메서드를 어드민 인터페이스에서 사용합니다. 또는 언제든 객체의 URL 을 알아내야 할때 사용합니다. </p><br><p>어떤 객체든 고유한 URL 이 식별하는 객체일때, 이 메서드로 정의 합니다. </p><br><h2 id="Model-Method-연습"><a href="#Model-Method-연습" class="headerlink" title="Model Method 연습"></a>Model Method 연습</h2><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import datetime                                                                                                                                                   </span><br><span class="line"></span><br><span class="line">In [2]: colin = Person.objects.create(first_name="Colin", </span><br><span class="line">                                      last_name="Firth", </span><br><span class="line">                                      birth_date=datetime.date(1960, 9, 10))                                                       </span><br><span class="line"></span><br><span class="line">In [3]: colin.first_name                                                                                                                                                  </span><br><span class="line">Out[3]: 'Colin'</span><br><span class="line"></span><br><span class="line">In [4]: colin.last_name                                                                                                                                                   </span><br><span class="line">Out[4]: 'Firth'</span><br><span class="line"></span><br><span class="line">In [5]: colin.birth_date                                                                                                                                                  </span><br><span class="line">Out[5]: datetime.date(1960, 9, 10)</span><br><span class="line"></span><br><span class="line">In [6]: colin.baby_boomer_status                                                                                                                                          </span><br><span class="line">Out[6]: &lt;bound method Person.baby_boomer_status of &lt;Person: Person object (4)&gt;&gt;</span><br><span class="line"></span><br><span class="line">In [7]: colin.full_name                                                                                                                                                   </span><br><span class="line">Out[7]: 'Colin Firth'</span><br></pre></td></tr></table></figure><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/11/Django-Models-14%ED%8E%B8-Model-Methods/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 13편 - Model Attributes</title>
      <link>http://djangojeng-e.github.io/2020/08/10/Django-Models-13%ED%8E%B8-Model-Attributes/</link>
      <guid>http://djangojeng-e.github.io/2020/08/10/Django-Models-13%ED%8E%B8-Model-Attributes/</guid>
      <pubDate>Mon, 10 Aug 2020 06:41:50 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Model-Attributes&quot;&gt;&lt;a href=&quot;#Model-Attributes&quot; class=&quot;headerlink&quot; title=&quot;Model Attributes&quot;&gt;&lt;/a&gt;Model Attributes&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;모델의 가장 중요한 속성은 Manager 입니다. &lt;/p&gt;
&lt;br&gt;



&lt;blockquote&gt;
&lt;p&gt;Manager 는 &lt;/p&gt;
&lt;p&gt;Django 데이터베이스 쿼리 운영을 제공 하는 인터페이스로, &lt;/p&gt;
&lt;p&gt;데이터베이스에서 인스턴스들을 검색할때 사용 됩니다. &lt;br&gt;&lt;/p&gt;
&lt;p&gt;만약, 사용자 정의 Manager 가 정의되어 있지 않다면, 기본값으로, Manager 의 이름은 objects 입니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;Manager 는 모델 클래스들을 통해서만 접근 가능합니다. 모델 인스턴스로는 접근이 가능하지 않습니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Model-Attributes"><a href="#Model-Attributes" class="headerlink" title="Model Attributes"></a>Model Attributes</h2><br><p>모델의 가장 중요한 속성은 Manager 입니다. </p><br><blockquote><p>Manager 는 </p><p>Django 데이터베이스 쿼리 운영을 제공 하는 인터페이스로, </p><p>데이터베이스에서 인스턴스들을 검색할때 사용 됩니다. <br></p><p>만약, 사용자 정의 Manager 가 정의되어 있지 않다면, 기본값으로, Manager 의 이름은 objects 입니다. </p></blockquote><br><p>Manager 는 모델 클래스들을 통해서만 접근 가능합니다. 모델 인스턴스로는 접근이 가능하지 않습니다. </p><br><a id="more"></a><h2 id="Manager-의-사용"><a href="#Manager-의-사용" class="headerlink" title="Manager 의 사용"></a>Manager 의 사용</h2><br><p>우리가 Django 에서 해당 모델의 데이터베이스 모든 데이터를 조회할때에는, 아래와 같이 ORM 을 작성합니다. </p><p><br>이때 사용되는, objects 가 Manager의 기본 이름입니다. <br></p><p><code>&lt;model명&gt;.objects.all()</code></p><br><p>예시를 들어보자면, </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>, verbose_name=<span class="string">'학생 이름'</span>)</span><br></pre></td></tr></table></figure><br><p>위의 Student 모델이 있다고 가정할때에, 해당 모델의 데이터베이스를 조회하는 명령어들은 아래와 같습니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.all()   # Student 의 모든 객체를 조회 </span><br><span class="line">Student.objects.get(name='장고쟁이') # 이름이 장고쟁이인 Student 를 찾음</span><br></pre></td></tr></table></figure><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/10/Django-Models-13%ED%8E%B8-Model-Attributes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 12편 - Meta Options</title>
      <link>http://djangojeng-e.github.io/2020/08/09/Django-Models-12%ED%8E%B8-Meta-Options/</link>
      <guid>http://djangojeng-e.github.io/2020/08/09/Django-Models-12%ED%8E%B8-Meta-Options/</guid>
      <pubDate>Sun, 09 Aug 2020 02:46:31 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Models-Meta-Options&quot;&gt;&lt;a href=&quot;#Models-Meta-Options&quot; class=&quot;headerlink&quot; title=&quot;Models - Meta Options&quot;&gt;&lt;/a&gt;Models - Meta Options&lt;/h2&gt;&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;Metadata &lt;/p&gt;
&lt;p&gt;데이터의 집합체로 다른 데이터에 대한 설명과 정보를 제공합니다 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;모델에 metadata 를 부여할수 있습니다. 클래스 안에 Meta 클래스를 사용해서 부여할수 있습니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;아래 예시와 같이 모델 클래스 안에 부가적으로, Meta 클래스를 넣어서 metadata 를 넣을수 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; models &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Ox&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    horn_length = models.IntegerField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 아래와 같이 Ox 모델 클래스 안쪽에 Meta 클래스를 넣어서 metadata 를 부여 할수 있습니다 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Meta&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ordering = [&lt;span class=&quot;string&quot;&gt;&quot;horn_length&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        verbose_name_plural = &lt;span class=&quot;string&quot;&gt;&quot;oxen&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;

&lt;p&gt;필드가 아닌 무엇이든, 모델의 메타데이터가 될수 있습니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;필드는, 메타 데이터가 될수 없습니. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Models-Meta-Options"><a href="#Models-Meta-Options" class="headerlink" title="Models - Meta Options"></a>Models - Meta Options</h2><br><blockquote><p>Metadata </p><p>데이터의 집합체로 다른 데이터에 대한 설명과 정보를 제공합니다 </p></blockquote><br><p>모델에 metadata 를 부여할수 있습니다. 클래스 안에 Meta 클래스를 사용해서 부여할수 있습니다. </p><p><br>아래 예시와 같이 모델 클래스 안에 부가적으로, Meta 클래스를 넣어서 metadata 를 넣을수 있습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ox</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    horn_length = models.IntegerField()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 아래와 같이 Ox 모델 클래스 안쪽에 Meta 클래스를 넣어서 metadata 를 부여 할수 있습니다 </span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">"horn_length"</span>]</span><br><span class="line">        verbose_name_plural = <span class="string">"oxen"</span></span><br></pre></td></tr></table></figure><br><p>필드가 아닌 무엇이든, 모델의 메타데이터가 될수 있습니다. </p><p><br>필드는, 메타 데이터가 될수 없습니. </p><br><a id="more"></a><br><blockquote><p>정렬 옵션인 ordering, </p><p>데이터 베이스 테이블명,  db_table </p><p>혹은 사람이 읽기 편한 단수와 복수 이름들인, verbose_name, verbose_name_plural </p><p>이런것들이 Meta 클래스안에 정의 될수 있습니다. </p></blockquote><br><p>모델에 대한 class Meta 적용은 전적으로 선택 사항입니다. </p><br><p>Meta Option 에 가능한 모든 옵션들에 대해서는,  model option reference 문서에서 보면 됩니다. </p><br><h2 id="Meta-option-리스트"><a href="#Meta-option-리스트" class="headerlink" title="Meta option 리스트"></a>Meta option 리스트</h2><br><p>메타 옵션에는 아래와 같은 항목들이 존재합니다. </p><p>모든 리스트를 확인하고 싶다면, <a href="https://docs.djangoproject.com/en/3.0/ref/models/options/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.0/ref/models/options/</a></p><p><br>링크를 확인 하면 됩니다. </p><table><thead><tr><th>Meta Options</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td>abstract</td><td>모델이 abstract base class 가 됩니다</td><td><code>abstract = True</code></td></tr><tr><td>app_label</td><td>모델이 INSTALLED_APPS 밖에 있는 어플리케이션에 존재할때에 선언합니다</td><td><code>app_label = myapp</code></td></tr><tr><td>base_manager_name</td><td>메니저의 속성 이름을 지정합니다. 예를들면, objects</td><td></td></tr><tr><td>db_table</td><td>해당 모델을 위한 데이터베이스 테이블 명을 지정합니다</td><td><code>db_table = &#39;music_album&#39;</code></td></tr><tr><td>db_tablespace</td><td>데이터베이스 테이블 스페이스의 이름</td><td></td></tr><tr><td>default_manager_name</td><td>해당 모델을 위해 사용할 메니저의 이름을 지정합니다</td><td></td></tr><tr><td>default_related_name</td><td>관련된 객체에서 역으로 접근할 이름을 지정합니다.  기본값은, <code>모델명_set</code> 입니다</td><td></td></tr><tr><td>get_latest_by</td><td>보편적으로 ,DateField, DateTimeField 혹은 IntegerField 같은 모델명에 사용합니다.</td><td>get_latest_by = “order_date”, get_latest_by = [‘-priority’, ‘order_date’]</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/09/Django-Models-12%ED%8E%B8-Meta-Options/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 11편 - Fields (Field name restrictions)</title>
      <link>http://djangojeng-e.github.io/2020/08/08/Django-Models-11%ED%8E%B8-Fields-Field-name-restrictions/</link>
      <guid>http://djangojeng-e.github.io/2020/08/08/Django-Models-11%ED%8E%B8-Fields-Field-name-restrictions/</guid>
      <pubDate>Sat, 08 Aug 2020 04:16:59 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Models-Fields-Field-Name-Restrictions&quot;&gt;&lt;a href=&quot;#Models-Fields-Field-Name-Restrictions&quot; class=&quot;headerlink&quot; title=&quot;Models - Fields(Field Name Restrictions)&quot;&gt;&lt;/a&gt;Models - Fields(Field Name Restrictions)&lt;/h2&gt;&lt;br&gt;

&lt;h3 id=&quot;Field-name-restrictions&quot;&gt;&lt;a href=&quot;#Field-name-restrictions&quot; class=&quot;headerlink&quot; title=&quot;Field name restrictions&quot;&gt;&lt;/a&gt;Field name restrictions&lt;/h3&gt;&lt;br&gt;

&lt;p&gt;Django 는 모델 필드 이름들에 대한 제약이 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;필드명은 파이썬 예약어들이 될수 없습니다. 만약 사용한다면, 파이썬 문법 에러를 발생 시킵니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt; = models.IntegerField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# pass 는 파이썬에서 reversed word (예약어) 입니다 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 따라서, 모델의 필드명이 될수 없습니다&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;필드명은 하나 이상의 언더스코어를 사용할수 없습니다. Django 의 쿼리 조회문이 언더스코어를 2개 사용하기 때문에, 필드명은, &lt;code&gt;__&lt;/code&gt; 를 가질수 없습니다.  &lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	foo__bar = models.IntegerField() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# foo__bar 는 언더스코어 2개를 가지고 있습니다. 잘못된 필드명입니다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;비슷한 이유로, 언더스코어로 끝나면 안됩니다. 쿼리 구문과 겹치기 때문입니다 &lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	foobar_ = models.InegerField() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# foobar_ 처럼 언더스코어로 끝나는 필드명은 사용하면 안됩니다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Models-Fields-Field-Name-Restrictions"><a href="#Models-Fields-Field-Name-Restrictions" class="headerlink" title="Models - Fields(Field Name Restrictions)"></a>Models - Fields(Field Name Restrictions)</h2><br><h3 id="Field-name-restrictions"><a href="#Field-name-restrictions" class="headerlink" title="Field name restrictions"></a>Field name restrictions</h3><br><p>Django 는 모델 필드 이름들에 대한 제약이 있습니다. </p><br><ol><li><p>필드명은 파이썬 예약어들이 될수 없습니다. 만약 사용한다면, 파이썬 문법 에러를 발생 시킵니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"><span class="keyword">pass</span> = models.IntegerField()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pass 는 파이썬에서 reversed word (예약어) 입니다 </span></span><br><span class="line"><span class="comment"># 따라서, 모델의 필드명이 될수 없습니다</span></span><br></pre></td></tr></table></figure></li></ol><br><ol start="2"><li><p>필드명은 하나 이상의 언더스코어를 사용할수 없습니다. Django 의 쿼리 조회문이 언더스코어를 2개 사용하기 때문에, 필드명은, <code>__</code> 를 가질수 없습니다.  <br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">foo__bar = models.IntegerField() </span><br><span class="line"></span><br><span class="line"><span class="comment"># foo__bar 는 언더스코어 2개를 가지고 있습니다. 잘못된 필드명입니다.</span></span><br></pre></td></tr></table></figure></li></ol><br><ol start="3"><li><p>비슷한 이유로, 언더스코어로 끝나면 안됩니다. 쿼리 구문과 겹치기 때문입니다 <br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">foobar_ = models.InegerField() </span><br><span class="line"></span><br><span class="line"><span class="comment"># foobar_ 처럼 언더스코어로 끝나는 필드명은 사용하면 안됩니다.</span></span><br></pre></td></tr></table></figure></li></ol><br><a id="more"></a><br><p>하지만, 이런 제약들은 유도리 있게 잘 사용될수 있습니다. 필드명은 데이터베이스 컬럼명과 꼭 같지 않아도 되기 때문입니다. </p><br><p>join, where 혹은 select 같은 SQL 예약어들은 모델 필드명에 사용해도 됩니다. </p><p><br>Django 는 모든 SQL 쿼리 기반에서의 데이터베이스 테이블 이름들과 컬럼명들에서 자유롭습니다. </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/08/Django-Models-11%ED%8E%B8-Fields-Field-name-restrictions/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 10편 - Fields (Models across files)</title>
      <link>http://djangojeng-e.github.io/2020/08/07/Django-Models-10%ED%8E%B8-Fields-Models-across-files/</link>
      <guid>http://djangojeng-e.github.io/2020/08/07/Django-Models-10%ED%8E%B8-Fields-Models-across-files/</guid>
      <pubDate>Fri, 07 Aug 2020 02:14:14 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;파일사이에-모델들&quot;&gt;&lt;a href=&quot;#파일사이에-모델들&quot; class=&quot;headerlink&quot; title=&quot;파일사이에 모델들&quot;&gt;&lt;/a&gt;파일사이에 모델들&lt;/h2&gt;&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;다른 앱에 존재하는 모델끼리 관계를 형성해도 괜찮습니다. &lt;/p&gt;
&lt;p&gt;다른 앱에 존재하는 모델을 사용하려면, 관계된 모델을 파일 상단에 가져와서 사용합니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;다른 모델 클래스를 가져온 다음에는, 필요한곳에 사용하면 됩니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;공식문서에서는 예시가 많이 빈약한데, 프로젝트 구조가 아래처럼 되어 있다고 가정합니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;order 라는 앱이 있고, product 라는앱이 있습니다 &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;이런 구조안에서, order/models.py 파일에서, product/models.py 에 있는 모델을 &lt;/p&gt;
&lt;p&gt;가져다 사용할수 있습니다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="파일사이에-모델들"><a href="#파일사이에-모델들" class="headerlink" title="파일사이에 모델들"></a>파일사이에 모델들</h2><br><blockquote><p>다른 앱에 존재하는 모델끼리 관계를 형성해도 괜찮습니다. </p><p>다른 앱에 존재하는 모델을 사용하려면, 관계된 모델을 파일 상단에 가져와서 사용합니다. </p></blockquote><br><p>다른 모델 클래스를 가져온 다음에는, 필요한곳에 사용하면 됩니다. </p><br><p>공식문서에서는 예시가 많이 빈약한데, 프로젝트 구조가 아래처럼 되어 있다고 가정합니다. </p><br><blockquote><p>order 라는 앱이 있고, product 라는앱이 있습니다 </p><br><p>이런 구조안에서, order/models.py 파일에서, product/models.py 에 있는 모델을 </p><p>가져다 사용할수 있습니다.  </p></blockquote><p><br><a id="more"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">├── config</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── db.sqlite3</span><br><span class="line">├── manage.py</span><br><span class="line">├── order</span><br><span class="line">│   ├── admin.py</span><br><span class="line">│   ├── apps.py</span><br><span class="line">│   ├── forms.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── migrations</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── tests.py</span><br><span class="line">│   └── views.py</span><br><span class="line">├── product</span><br><span class="line">│   ├── admin.py</span><br><span class="line">│   ├── apps.py</span><br><span class="line">│   ├── forms.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── migrations</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── tests.py</span><br><span class="line">│   └── views.py</span><br></pre></td></tr></table></figure><br><br><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2><br><blockquote><p>파일 상단에, 다른 앱에 존재하는 클래스를 가져와서 사용하면 됩니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> order.models <span class="keyword">import</span> Order </span><br><span class="line"></span><br><span class="line"><span class="comment"># order 앱에 있는 models.py 에서 Order 라는 모델을 불러옴</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ... </span></span><br><span class="line">    order = models.ForeignKey(Order, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><br><h2 id="공식문서-예시"><a href="#공식문서-예시" class="headerlink" title="공식문서 예시"></a>공식문서 예시</h2><br><p>공식문서 예시에서는, geography 에 있는 models 를 불러오고, 그 안에 있는 ZipCode 클래스를 가져와서 사용하는것을 보여주고 있습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"><span class="keyword">from</span> geography.models <span class="keyword">import</span> ZipCode </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ... </span></span><br><span class="line">    zip_code = models.ForeignKey(</span><br><span class="line">    ZipCode, on_delete=models.SET_NULL,</span><br><span class="line">    blank=<span class="literal">True</span>,</span><br><span class="line">    null=<span class="literal">True</span>, </span><br><span class="line">    )</span><br></pre></td></tr></table></figure><br><p>파일 상단에 다른 앱에 존재하는 모델을 불러오기 위해서는, 아래 형식으로 불러와주면 됩니다. </p><br><p><code>from &lt;앱이름&gt;.models import &lt;가져올클래스이름&gt;</code></p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/07/Django-Models-10%ED%8E%B8-Fields-Models-across-files/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 9편 - One-to-One</title>
      <link>http://djangojeng-e.github.io/2020/08/06/Django-Models-9%ED%8E%B8-One-to-One/</link>
      <guid>http://djangojeng-e.github.io/2020/08/06/Django-Models-9%ED%8E%B8-One-to-One/</guid>
      <pubDate>Thu, 06 Aug 2020 08:29:30 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Models-Relationships-One-to-One&quot;&gt;&lt;a href=&quot;#Models-Relationships-One-to-One&quot; class=&quot;headerlink&quot; title=&quot;Models - Relationships (One-to-One)&quot;&gt;&lt;/a&gt;Models - Relationships (One-to-One)&lt;/h2&gt;&lt;br&gt;

&lt;h3 id=&quot;one-to-one-relationships&quot;&gt;&lt;a href=&quot;#one-to-one-relationships&quot; class=&quot;headerlink&quot; title=&quot;one-to-one relationships&quot;&gt;&lt;/a&gt;one-to-one relationships&lt;/h3&gt;&lt;br&gt;

&lt;p&gt;one-to-one 관계, 즉 1대 1 관계를 정의하기 위해서는, &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;code&gt;OneToOneField&lt;/code&gt;를 사용해 줍니다. 다른 필드 타입을 사용하는것과 비슷하게, 모델 클래스 안에 클래스 속성으로 정의해 줍니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;OneToOneField 는 위치 인자를 필요로 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;OneToOneField 는 연결된 모델 클래스를, 필수 위치 인자로 받습니다 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;예를들어, “places” 라는 데이터베이스를 만들고 있었는데,  &lt;code&gt;address&lt;/code&gt; 나 &lt;code&gt;phone number&lt;/code&gt; 같이 매우 보편적인 것들을 데이터베이스에 만드려고 하는 상황이 올지 모릅니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;places 라는 장소위에 restaurant 이라는 데이터베이스를 만들고 싶으면, Place 를 만들때 포함하였던 &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;데이터베이스 필드들을 Restaurant 모델에 반복하여 생성해 주기 보다는, &lt;/p&gt;
&lt;p&gt;Restaurant 이 OneToOneField 를 Place 에 갖게 하면 됩니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;이게 무슨 이야기냐면,,, 하나의 장소 (Place)는 &lt;code&gt;address&lt;/code&gt; 나 &lt;code&gt;phone number&lt;/code&gt; 같은 보편적인 정보를 가지고 있을지 모릅니다. 그런데 만약, 하나의 장소 위에 식당 (restaurant) 을 만들고 싶다면? &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;restaurant 모델을 만들어 줄때에 &lt;code&gt;address&lt;/code&gt; 나 &lt;code&gt;phone number&lt;/code&gt; 같은 보편적인 필드들을 다시 정의하지 않고,&lt;/p&gt;
&lt;p&gt;&lt;br&gt;Restaurant 이 OneToOneField 를 사용하여 Place 모델과 연결되면 됩니다.  &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Models-Relationships-One-to-One"><a href="#Models-Relationships-One-to-One" class="headerlink" title="Models - Relationships (One-to-One)"></a>Models - Relationships (One-to-One)</h2><br><h3 id="one-to-one-relationships"><a href="#one-to-one-relationships" class="headerlink" title="one-to-one relationships"></a>one-to-one relationships</h3><br><p>one-to-one 관계, 즉 1대 1 관계를 정의하기 위해서는, </p><p><br><code>OneToOneField</code>를 사용해 줍니다. 다른 필드 타입을 사용하는것과 비슷하게, 모델 클래스 안에 클래스 속성으로 정의해 줍니다. </p><br><p>OneToOneField 는 위치 인자를 필요로 합니다. </p><br><blockquote><p>OneToOneField 는 연결된 모델 클래스를, 필수 위치 인자로 받습니다 </p></blockquote><br><p>예를들어, “places” 라는 데이터베이스를 만들고 있었는데,  <code>address</code> 나 <code>phone number</code> 같이 매우 보편적인 것들을 데이터베이스에 만드려고 하는 상황이 올지 모릅니다. </p><br><p>places 라는 장소위에 restaurant 이라는 데이터베이스를 만들고 싶으면, Place 를 만들때 포함하였던 </p><br><blockquote><p>데이터베이스 필드들을 Restaurant 모델에 반복하여 생성해 주기 보다는, </p><p>Restaurant 이 OneToOneField 를 Place 에 갖게 하면 됩니다. </p></blockquote><br><p>이게 무슨 이야기냐면,,, 하나의 장소 (Place)는 <code>address</code> 나 <code>phone number</code> 같은 보편적인 정보를 가지고 있을지 모릅니다. 그런데 만약, 하나의 장소 위에 식당 (restaurant) 을 만들고 싶다면? </p><br><p>restaurant 모델을 만들어 줄때에 <code>address</code> 나 <code>phone number</code> 같은 보편적인 필드들을 다시 정의하지 않고,</p><p><br>Restaurant 이 OneToOneField 를 사용하여 Place 모델과 연결되면 됩니다.  </p><br><a id="more"></a><br><p>사실, Restaurant 도 하나의 Place 이기 때문에, 이런 상황을 해결 하기 위해서는 보통 상속 개념을 사용합니다. </p><p>클래스를 상속 하면, 상속받는 클래스의 필드와 메서드들을 사용할수 있다는것을 숙지해둡시다. </p><br><p>데이터베이스 상속은 암묵적으로, <code>one-to-one</code> 관계를 형성합니다. </p><br><h2 id="OneToOneField-예시"><a href="#OneToOneField-예시" class="headerlink" title="OneToOneField 예시"></a>OneToOneField 예시</h2><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Place</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">80</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s the place"</span> % self.name </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># OneToOneField 의 첫번째 인자로, Place 클래스를 받음 </span></span><br><span class="line">    place = models.OneToOneField(Place, on_delete=models.CASCADE,  primary_key=<span class="literal">True</span>)</span><br><span class="line">    serves_hot_dogs = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    serves_pizza = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s the restaurant"</span> % self.place.name </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    restaurant = models.ForeignKey(Restaurant, on_delete=models.CASCADE)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s the waiter at %s"</span> % (self.name, self.restaurant)</span><br></pre></td></tr></table></figure><p><br><br></p><p>위의 예시 모델에서, 하나의 장소 <code>Place</code> 에는 하나의 <code>Restaurant</code> 이 존재하고, 이는 <code>OneToOneField</code> 로 연결되어 있습니다. 하나의 <code>Restaurant</code> 에는 <code>ForeignKey</code> 로 연결되어 있는, <code>Waiter</code>  라는 모델이 존재합니다. </p><p><br>이는, 하나의 Restaurant 에 일하는 웨이터가 여러명 있을수 있는 관계를 모델링 한것입니다. <br><br></p><blockquote><p><code>OneToOneField</code> 는 선택 인자로 parent_link 를 받습니다. </p></blockquote><br><h2 id="Python-API-사용해보기"><a href="#Python-API-사용해보기" class="headerlink" title="Python API 사용해보기"></a>Python API 사용해보기</h2><br><p>장소 (Place) 2 곳을 생성해 줍니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [1]: p1 = Place(name="명랑핫도그", address="성남시 분당구 정자1동")                                                                                                    </span><br><span class="line"></span><br><span class="line">In [2]: p1.save()                                                                                                                                                         </span><br><span class="line"></span><br><span class="line">In [3]: p2 = Place(name="피자헛", address="성남시 분당구 금곡동 불정로 87")                                                                                               </span><br><span class="line"></span><br><span class="line">In [4]: p2.save()</span><br></pre></td></tr></table></figure><br><p>식당을 생성해 주고, 부모 객체를 해당 객체의 primary key 로 전달해줍니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [5]: r = Restaurant(place=p1, serves_hot_dogs=True, serves_pizza=False)                                                                                                </span><br><span class="line"></span><br><span class="line">In [6]: r.save()</span><br></pre></td></tr></table></figure><br><p>r 은 Restaurant 의 인스턴스 이니까, 하나의 Restaurant 인스턴스는, 해당 장소에 접근할수 있습니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [7]: r.place                                                                                                                                                           </span><br><span class="line">Out[7]: &lt;Place: 명랑핫도그 the place&gt;</span><br></pre></td></tr></table></figure><br><p>반대로, 하나의 Place 는 restaurant 에 접근할수 있습니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [8]: p1.restaurant                                                                                                                                                     </span><br><span class="line">Out[8]: &lt;Restaurant: 명랑핫도그 the restaurant&gt;</span><br></pre></td></tr></table></figure><br><blockquote><p>p2 는 연결된 restaurant 이 아직 없습니다. </p><p>따라서, 아래 코드를 shell 에서 실행 하면, p2 에는 restaurant 이 없다고 나옵니다 </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [9]: from django.core.exceptions import ObjectDoesNotExist                                                                                                             </span><br><span class="line"></span><br><span class="line">In [10]: try: </span><br><span class="line">    ...:     p2.restaurant </span><br><span class="line">    ...: except ObjectDoesNotExist: </span><br><span class="line">    ...:     print("There is no restaurant here.") </span><br><span class="line">    ...:                                                                                                                                                                  </span><br><span class="line"><span class="meta">#</span><span class="bash"> Shift + Enter 를 실행하면, 실행됨. </span></span><br><span class="line"></span><br><span class="line">There is no restaurant here.</span><br></pre></td></tr></table></figure><br><blockquote><p><code>hasattr</code> 메서드를 사용하여, 예외처리를 하지 않아도 됩니다. </p><ul><li><code>hasattr</code> 는 파이썬 내장함수 입니다.</li><li>객체가 주어진 이름의 어트리뷰트를 가지고 있을때 True 를 반환하고, 그렇지 않을때에 False 를 반환합니다.  </li><li><code>hasatt(object, name)</code></li></ul></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [11]: hasattr(p2, 'restaurant')                                                                                                                                        </span><br><span class="line">Out[11]: False</span><br></pre></td></tr></table></figure><br><p>할당 기호 (<code>=</code>) 를  사용하여, place 를 설정해 줍니다. place 는 Restaurant 의 primary key 이므로, save 는 새로운 restaurant 을 생성합니다 </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 위에서 r = Restaurant(place=p1, serves_hot_dogs=True, serves_pizza=False)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r.place = p2 로 바꿔줍니다. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [12]: r.place = p2                                                                                                                                               </span><br><span class="line">In [13]: r.save()                                                                                                                                                   </span><br><span class="line"></span><br><span class="line">In [14]: p2.restaurant                                                                                                                                                    </span><br><span class="line">Out[14]: &lt;Restaurant: 피자헛 the restaurant&gt;</span><br><span class="line"></span><br><span class="line">In [15]: r.place                                                                                                                                                          </span><br><span class="line">Out[15]: &lt;Place: 피자헛 the place&gt;</span><br></pre></td></tr></table></figure><br><p>Place 를 다시 역으로 바꿔줍니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [16]: p1.restaurant = r                                                                                                                                                </span><br><span class="line"></span><br><span class="line">In [17]: p1.restaurant                                                                                                                                                    </span><br><span class="line">Out[17]: &lt;Restaurant: 명랑핫도그 the restaurant&gt;</span><br></pre></td></tr></table></figure><br><blockquote><p>One-To-One 관계가 할당 되기 이전에 </p><p>객체가 저장 되어 있어야 ValueError 가 나질 않습니다. </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [18]: p3 = Place(name='Daemon Dogs', address='944 W. Fullerton')                                                                                                       </span><br><span class="line"></span><br><span class="line">In [19]: Restaurant.objects.create(place=p3, serves_hot_dogs=True, serves_pizza=False)                                                                                    </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-19-18b4cdec5239&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta">----&gt;</span><span class="bash"> 1 Restaurant.objects.create(place=p3, serves_hot_dogs=True, serves_pizza=False)</span></span><br></pre></td></tr></table></figure><br><blockquote><p>Restaurant.objects.all() 은 Restaurants 만 반환합니다. Place 는 반환하지 않습니다. </p><p>Place.objects.all() 은 Places 들을 반환합니다. Restaurant을 가지고 있던 안있던,  결과를 반환합니다. </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [20]: Restaurant.objects.all()                                                                                                                                         </span><br><span class="line">Out[20]: &lt;QuerySet [&lt;Restaurant: 명랑핫도그 the restaurant&gt;, &lt;Restaurant: 피자헛 the restaurant&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [21]: Place.objects.order_by('name')                                                                                                                                   </span><br><span class="line">Out[21]: &lt;QuerySet [&lt;Place: 명랑핫도그 the place&gt;, &lt;Place: 피자헛 the place&gt;]&gt;</span><br></pre></td></tr></table></figure><br><blockquote><p>관계간 룩업들을 사용하여, 해당 모델에 쿼리문을 작성할수 있습니다. </p></blockquote><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [22]: Restaurant.objects.get(place&#x3D;p1)                                                                                                                                 </span><br><span class="line">Out[22]: &lt;Restaurant: 명랑핫도그 the restaurant&gt;</span><br><span class="line"></span><br><span class="line">In [23]: Restaurant.objects.get(place__pk&#x3D;1)                                                                                                                              </span><br><span class="line">Out[23]: &lt;Restaurant: 명랑핫도그 the restaurant&gt;</span><br><span class="line"></span><br><span class="line">In [24]: Restaurant.objects.filter(place__name__startswith&#x3D;&quot;명&quot;)                                                                                                          </span><br><span class="line">Out[24]: &lt;QuerySet [&lt;Restaurant: 명랑핫도그 the restaurant&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [25]: Restaurant.objects.exclude(place__address__contains&#x3D;&quot;헛&quot;)                                                                                                        </span><br><span class="line">Out[25]: &lt;QuerySet [&lt;Restaurant: 명랑핫도그 the restaurant&gt;, &lt;Restaurant: 피자헛 the restaurant&gt;]&gt;</span><br><span class="line"></span><br><span class="line"># 한글은 조회 필터가 안걸리는지, exclude 를 했는데도. 조회가 되서 나옵니다;;;;</span><br></pre></td></tr></table></figure><br><p>물론 거꾸로도 작동 합니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [27]: Place.objects.get(pk=1)                                                                                                                                          </span><br><span class="line">Out[27]: &lt;Place: 명랑핫도그 the place&gt;</span><br><span class="line"></span><br><span class="line">In [28]: Place.objects.get(restaurant__place=p1)                                                                                                                          </span><br><span class="line">Out[28]: &lt;Place: 명랑핫도그 the place&gt;</span><br><span class="line"></span><br><span class="line">In [29]: Place.objects.get(restaurant=r)                                                                                                                                  </span><br><span class="line">Out[29]: &lt;Place: 명랑핫도그 the place&gt;</span><br><span class="line"></span><br><span class="line">In [30]: Place.objects.get(restaurant__place__name__startswith="명")                                                                                                      </span><br><span class="line">Out[30]: &lt;Place: 명랑핫도그 the place&gt;</span><br></pre></td></tr></table></figure><br><br><blockquote><p>Waiter 를 Restaurant 에 추가해 줍니다. </p><p>Waiter는 Restaurant 에 ForeignKey 로 등록 되어 있습니다. </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [31]: w = r.waiter_set.create(name="장고쟁이")                                                                                                                         </span><br><span class="line"></span><br><span class="line">In [32]: w                                                                                                                                                                </span><br><span class="line">Out[32]: &lt;Waiter: 장고쟁이 the waiter at 명랑핫도그 the restaurant&gt;</span><br></pre></td></tr></table></figure><br><p>웨이터들을 쿼리를 통해 조회합니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [33]: Waiter.objects.filter(restaurant__place=p1)                                                                                                                      </span><br><span class="line">Out[33]: &lt;QuerySet [&lt;Waiter: 장고쟁이 the waiter at 명랑핫도그 the restaurant&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [34]: Waiter.objects.filter(restaurant__place__name__startswith="명")                                                                                                  </span><br><span class="line">Out[34]: &lt;QuerySet [&lt;Waiter: 장고쟁이 the waiter at 명랑핫도그 the restaurant&gt;]&gt;</span><br></pre></td></tr></table></figure><br><h2 id="데이터베이스-리뷰"><a href="#데이터베이스-리뷰" class="headerlink" title="데이터베이스 리뷰"></a>데이터베이스 리뷰</h2><br><img src="/2020/08/06/Django-Models-9%ED%8E%B8-One-to-One/image1.png" class=""><img src="/2020/08/06/Django-Models-9%ED%8E%B8-One-to-One/image2.png" class=""> <img src="/2020/08/06/Django-Models-9%ED%8E%B8-One-to-One/image3.png" class="">  <p><br><br></p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/06/Django-Models-9%ED%8E%B8-One-to-One/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 8편 - Many-to-many 예시</title>
      <link>http://djangojeng-e.github.io/2020/08/05/Django-Models-8%ED%8E%B8-Many-to-many-%EC%98%88%EC%8B%9C/</link>
      <guid>http://djangojeng-e.github.io/2020/08/05/Django-Models-8%ED%8E%B8-Many-to-many-%EC%98%88%EC%8B%9C/</guid>
      <pubDate>Wed, 05 Aug 2020 03:53:46 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Django-Models-ManyToMany-예시&quot;&gt;&lt;a href=&quot;#Django-Models-ManyToMany-예시&quot; class=&quot;headerlink&quot; title=&quot;Django Models - ManyToMany 예시&quot;&gt;&lt;/a&gt;Django Models - ManyToMany 예시&lt;/h2&gt;&lt;br&gt;

&lt;h3 id=&quot;예시-개요&quot;&gt;&lt;a href=&quot;#예시-개요&quot; class=&quot;headerlink&quot; title=&quot;예시 개요&quot;&gt;&lt;/a&gt;예시 개요&lt;/h3&gt;&lt;br&gt;

&lt;p&gt;대학교에서 학생들이 듣는 과정들과 학생들에 대한 모델링을 합니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;과정은, Course 로 표현하고, 과목들은 아래와 같이 몇개만 정리 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;CourseID&lt;/th&gt;
&lt;th&gt;CourseName&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Algorithm Design&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Systems Programming&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Object-Oriented Programming&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;br&gt;

&lt;p&gt;아래 학생들이 재학하고 있다고 가정합니다. &lt;/p&gt;
&lt;br&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;StudentID&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;djangojeng-e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Jennifer Lawrence&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Will Smith&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;학생들은, 여러개의 과목들을 수강할수 있고. &lt;/p&gt;
&lt;p&gt;한 과목은 여러명의 수강생들이 들을수 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;따라서, Students - to - Courses 는 Many-to-Many, 다대다 관계가 성립됩니다 &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;일반적인 Many-to-Many 관계로는, 학생의 수강날짜, 수강종료날짜, 그리고 성적 같은것들을 모두 기록할수 없기 때문에. 중간 모델을 하나 만들어서 관리할수 있습니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Django-Models-ManyToMany-예시"><a href="#Django-Models-ManyToMany-예시" class="headerlink" title="Django Models - ManyToMany 예시"></a>Django Models - ManyToMany 예시</h2><br><h3 id="예시-개요"><a href="#예시-개요" class="headerlink" title="예시 개요"></a>예시 개요</h3><br><p>대학교에서 학생들이 듣는 과정들과 학생들에 대한 모델링을 합니다. </p><p><br>과정은, Course 로 표현하고, 과목들은 아래와 같이 몇개만 정리 합니다. </p><br><table><thead><tr><th>CourseID</th><th>CourseName</th></tr></thead><tbody><tr><td>1</td><td>Algorithm Design</td></tr><tr><td>2</td><td>Systems Programming</td></tr><tr><td>3</td><td>Object-Oriented Programming</td></tr></tbody></table><br><p>아래 학생들이 재학하고 있다고 가정합니다. </p><br><table><thead><tr><th>StudentID</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>djangojeng-e</td></tr><tr><td>2</td><td>Jennifer Lawrence</td></tr><tr><td>3</td><td>Will Smith</td></tr></tbody></table><br><blockquote><p>학생들은, 여러개의 과목들을 수강할수 있고. </p><p>한 과목은 여러명의 수강생들이 들을수 있습니다. </p><br><p>따라서, Students - to - Courses 는 Many-to-Many, 다대다 관계가 성립됩니다 </p><br><p>일반적인 Many-to-Many 관계로는, 학생의 수강날짜, 수강종료날짜, 그리고 성적 같은것들을 모두 기록할수 없기 때문에. 중간 모델을 하나 만들어서 관리할수 있습니다. </p></blockquote><br><a id="more"></a><h3 id="모델링"><a href="#모델링" class="headerlink" title="모델링"></a>모델링</h3><br><p>Student 와 Course 모델들의 중간 모델인, Enrolment 를 생성하고. </p><p><br>Enrolment 에 수강날짜, 수강종료날짜, 그리고 성적을 관리 할겁니다. </p><br><table><thead><tr><th>Student</th><th>Course</th><th>Enrolment</th></tr></thead><tbody><tr><td>name (CHARFIELD)</td><td>name (CHARFIELD)</td><td>student (ForeignKey, Student)</td></tr><tr><td></td><td>enrolments - Enrolment 라는 중간 모델을 통해서 Student 와 M2M을 성립</td><td>enrolment (ForeignKey, Course)</td></tr><tr><td></td><td>- 중간모델을 성립하기 위해 through 를 사용해야 함</td><td>enrolled_date (수강시작 날짜)</td></tr><tr><td></td><td></td><td>finished_date (수강종료 날짜)</td></tr><tr><td></td><td></td><td>academic_record (성적)</td></tr></tbody></table><br><blockquote><p>이렇게 정리된 사항을, Django 모델로 작성을 해보면, 아래와 같습니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student(models.Model);</span><br><span class="line">name = models.CharField(max_length=<span class="number">40</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    enrolments = models.ManyToManyField(Student, through=<span class="string">'Enrolment'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name </span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enrolment</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    student = models.ForeignKey(Student, on_delete=models.CASCADE)</span><br><span class="line">    course = models.ForeignKey(Course, on_delete=models.CASCADE)</span><br><span class="line">    enrolled_date = models.DateTimeField()</span><br><span class="line">    finished_date = models.DateTimeField(blank=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 학점을 관리 하기 위해서, 등급을 ABCDEF 로 나눕니다 </span></span><br><span class="line">    <span class="comment"># 학점 선택을 위해서, models.TextChoice 로 선택할수 있는 학점을 밑에 넣어줍니다. </span></span><br><span class="line">    </span><br><span class="line">    AcademicType = models.TextChoices(<span class="string">'AcademicType'</span>, <span class="string">'A B C D E F'</span>)</span><br><span class="line">    </span><br><span class="line">    academic_record = models.CharField(blank=<span class="literal">True</span>, choices=AcademicType.choices,    max_length=<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.student + <span class="string">" "</span></span><br><span class="line">               + self.course + <span class="string">" "</span></span><br><span class="line">               + self.enrolled_date + <span class="string">" "</span></span><br><span class="line">               + self.finished_date + <span class="string">" "</span></span><br><span class="line">               + self.academic_record)</span><br></pre></td></tr></table></figure><br><h2 id="객체-생성-연습"><a href="#객체-생성-연습" class="headerlink" title="객체 생성 연습"></a>객체 생성 연습</h2><br><p>아래 테이블에 정리된 데이터 처럼, 객체 생성 연습을 해봅니다. </p><br><table><thead><tr><th>CourseID</th><th>CourseName</th><th>StudentID</th><th>StudentName</th></tr></thead><tbody><tr><td>1</td><td>Algorithm Design</td><td>1</td><td>djangojeng-e</td></tr><tr><td>2</td><td>Systems Programming</td><td>2</td><td>Jennifer Lawrence</td></tr><tr><td>3</td><td>Object-Oriented Programming</td><td>3</td><td>Will Smith</td></tr></tbody></table><br><blockquote><p>shell_plus  를 사용해서, 객체 생성을 해보았습니다. </p><p>Student 와 Course 데이터 생성 </p></blockquote><br><h3 id="Student-와-Course-객체-생성"><a href="#Student-와-Course-객체-생성" class="headerlink" title="Student 와 Course 객체 생성"></a>Student 와 Course 객체 생성</h3><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: djangojeng_e = Student.objects.create(name="장고쟁이")                                                                                                            </span><br><span class="line"></span><br><span class="line">In [2]: jennifer = Student.objects.create(name="Jennifer Lawrence")                                                                                                       </span><br><span class="line"></span><br><span class="line">In [3]: will = Student.objects.create(name="Will Smith")                                                                                                                  </span><br><span class="line"></span><br><span class="line">In [4]: algorith_design = Course.objects.create(name="Algorith Design")                                                                                                   </span><br><span class="line"></span><br><span class="line">In [5]: systems_programming = Course.objects.create(name="Systems Programming")                                                                                           </span><br><span class="line"></span><br><span class="line">In [6]: object_oriented_programming = Course.objects.create(name="Object Oriented Programming")</span><br></pre></td></tr></table></figure><br><blockquote><p>db 에 아래와 같이 저장 됩니다 </p></blockquote><br><img src="/2020/08/05/Django-Models-8%ED%8E%B8-Many-to-many-%EC%98%88%EC%8B%9C/image1.png" class=""><br><img src="/2020/08/05/Django-Models-8%ED%8E%B8-Many-to-many-%EC%98%88%EC%8B%9C/image2.png" class=""><br><h3 id="Student-객체-둘러보기"><a href="#Student-객체-둘러보기" class="headerlink" title="Student 객체 둘러보기"></a>Student 객체 둘러보기</h3><br><p>shell 에서, 아래와 같이 Student 객체를 생성후, <code>dir(인스턴스)</code>를 쳐보면, 해당 인스턴스의 메서드들이 모두 나열됩니다. 이 메서드중에, 가장 중요한것만 나열해 봅니다.  (<code>__메서드</code> 들은 모두 빼주고 나열함)</p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">djangojeng_e = Student.objects.create(name='장고쟁이')     </span><br><span class="line"></span><br><span class="line">dir(djangojeng_e)                                                                                                                         </span><br><span class="line">['DoesNotExist',</span><br><span class="line"> 'MultipleObjectsReturned',</span><br><span class="line"> 'course_set',</span><br><span class="line"> 'delete',</span><br><span class="line"> 'enrolment_set',</span><br><span class="line"> 'id',</span><br><span class="line"> 'name',</span><br><span class="line"> 'pk',</span><br><span class="line"> 'save',</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> djangojeng_e 인스턴스로 호출가능한것들</span></span><br><span class="line">djangojeng_e.id </span><br><span class="line">djangojeng_e.name </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 해당 인스턴스와 연관된 enrolment 객체에 접근 가능 </span></span><br><span class="line">djangojeng_e.enrolment_set   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 예를들면, </span></span><br><span class="line">djangojeng_e.enrolment_set.all() </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 해당 인스턴스와 연관된 course 객체에 접근 가능 </span></span><br><span class="line">djangojeng_e.course_set </span><br><span class="line"><span class="meta">#</span><span class="bash"> 예를들면, </span></span><br><span class="line">djangojeng_e.course_set.all()</span><br></pre></td></tr></table></figure><br><h3 id="Course-객체-둘러보기"><a href="#Course-객체-둘러보기" class="headerlink" title="Course 객체 둘러보기"></a>Course 객체 둘러보기</h3><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">oop = Course.objects.create(name='객체지향 프로그래밍')</span><br><span class="line">dir(oop)</span><br><span class="line"></span><br><span class="line">['DoesNotExist',</span><br><span class="line"> 'MultipleObjectsReturned',</span><br><span class="line"> 'delete',</span><br><span class="line"> 'enrolment_set',</span><br><span class="line"> 'enrolments',</span><br><span class="line"> 'id',</span><br><span class="line"> 'name',</span><br><span class="line"> 'pk',</span><br><span class="line"> 'save',</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">oop.id </span><br><span class="line">oop.name</span><br><span class="line">oop.pk</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> oop 인스턴스와 연결된 enrolment 객체 조회 가능 </span></span><br><span class="line">oop.enrolment_set.all() </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> enrolments </span></span><br><span class="line">oop.enrolments</span><br></pre></td></tr></table></figure><br><br><br><h3 id="Enrolment-객체-생성"><a href="#Enrolment-객체-생성" class="headerlink" title="Enrolment 객체 생성"></a>Enrolment 객체 생성</h3><br><p>아래 테이블에 정리된대로, Enrolment 객체를 생성해 줍시다. </p><br><table><thead><tr><th>EnrolmentID</th><th>Student</th><th>Course</th><th>enrolled_date</th><th>finished_date</th><th>academic_record</th></tr></thead><tbody><tr><td>1</td><td>djangojeng-e</td><td>Object-Oriented Programming</td><td>2020.04.20</td><td></td><td></td></tr><tr><td>2</td><td>Jennifer Lawrence</td><td>Object-Oriented Programming</td><td>2020.04.20</td><td></td><td></td></tr><tr><td>3</td><td>Will Smith</td><td>Systems Programming</td><td>2019.04.21</td><td>2020.04.21</td><td>A</td></tr></tbody></table><p><br><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> import datetime 을 먼저 하고 명령어를 실행해줘야 합니다. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [9]: e1 = Enrolment(student=djangojeng_e, </span><br><span class="line">                       course=oop, </span><br><span class="line">                       enrolled_date=datetime.datetime(2020, 4, 20))                                            </span><br><span class="line">In [10]: e1.save()          </span><br><span class="line"></span><br><span class="line">In [11]: oop.enrolments.all()                                                                                                                     </span><br><span class="line">Out[11]: &lt;QuerySet [&lt;Student: 장고쟁이&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [12]: djangojeng_e.course_set.all()     </span><br><span class="line"><span class="meta">#</span><span class="bash"> 장고쟁이 학생에 관련된 course 를 조회하려면, course_set.all() 하면 됩니다.                                                                                                   <span class="comment"># 참고로, djangojeng_e.enrolment_set.all() 하면, enrol 된 객체가 조회 됩니다.                             </span></span></span><br><span class="line">Out[12]: &lt;QuerySet [&lt;Course: 객체지향 프로그래밍&gt;]&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [15]: e2 = Enrolment.objects.create(student=jennifer, </span><br><span class="line">course=oop, </span><br><span class="line">enrolled_date=datetime.datetime(2020, 4, 20))    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [17]: e3 = Enrolment.objects.create(student=will,  </span><br><span class="line">    ...: course=systems_programming,  </span><br><span class="line">    ...: enrolled_date=datetime.datetime(2019, 4, 19), </span><br><span class="line">    ...: finished_date=datetime.datetime(2020, 4, 20),  </span><br><span class="line">    ...: academic_record="A")</span><br></pre></td></tr></table></figure><br><p>데이터베이스 데이터를 저장할때, datetime 관련 에러가 날수가 있는데. 이 점에 대해서는 추후에 해결해봐야 할것 같습니다. </p><br><img src="/2020/08/05/Django-Models-8%ED%8E%B8-Many-to-many-%EC%98%88%EC%8B%9C/image3.png" class=""><p><br><br></p><blockquote><p>add(), create() 혹은 set() 을 사용해서, </p><p>관계들을 생성 할수 있습니다. through_defaults 를 통해, 요구되는 필드값을 넣어줄수 있습니다. </p></blockquote><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [18]: john &#x3D; Student.objects.create(name&#x3D;&quot;John Snow&quot;)   </span><br><span class="line"></span><br><span class="line">In [19]: systems_programming.enrolments.add(john, through_defaults&#x3D;&#123;&#39;enrolled_date&#39;: datetime.datetime(2020, 4, 19)&#125;)</span><br><span class="line"></span><br><span class="line">In [20]: object_oriented_programming.enrolments.create(name&#x3D;&quot;Arya Stark&quot;, through_defaults&#x3D;&#123;&#39;enrolled_date&#39;: datetime.datetime(2020, 4, 19)&#125;) </span><br><span class="line"></span><br><span class="line">In [21]: algorithm_design.enrolments.set([djangojeng_e, jennifer, will], through_defaults&#x3D;&#123;&#39;enrolled_date&#39;: datetime.datetime(2020, 4, 19)&#125;) </span><br><span class="line"></span><br><span class="line">In [23]: algorithm_design.enrolments.all()                                                                                                                                </span><br><span class="line">Out[23]: &lt;QuerySet [&lt;Student: 장고쟁이&gt;, &lt;Student: Jennifer Lawrence&gt;, &lt;Student: Will Smith&gt;]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">john &#x3D; Student.objects.create(name&#x3D;&quot;John Snow&quot;)</span><br><span class="line">systems_programming.enrolments.add(jogn, through_defaults&#x3D;</span><br><span class="line">&#123;&#39;enrolled_date&#39;: datetime.datetime(2020, 4, 19) &#125;)</span><br><span class="line"></span><br><span class="line">object_oriented_programming.enrolments.create(name&#x3D;&quot;Arya Stark&quot;, through_defaults&#x3D;&#123;&#39;enrolled_date&#39;: datetime.datetime(2020, 4, 19)&#125;)</span><br><span class="line"></span><br><span class="line">algorithm_design.enrolments.set(</span><br><span class="line">[djangojeng_e, jennifer, will],</span><br><span class="line">through_defaults&#x3D;&#123;&#39;enrolled_date&#39;: datetime.datetime(2020, 4, 19)&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">algorith_design.enrolments.all() </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">Out[23]: &lt;QuerySet [&lt;Student: 장고쟁이&gt;, &lt;Student: Jennifer Lawrence&gt;, &lt;Student: Will Smith&gt;]&gt;</span><br></pre></td></tr></table></figure><br><img src="/2020/08/05/Django-Models-8%ED%8E%B8-Many-to-many-%EC%98%88%EC%8B%9C/image4.png" class=""><br><br><blockquote><p>remove() 사용하기 </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> oop 에서 장고쟁이 빼기 </span></span><br><span class="line"></span><br><span class="line">In [25]: object_oriented_programming.enrolments.all()                                                                                                             </span><br><span class="line">Out[25]: &lt;QuerySet [&lt;Student: 장고쟁이&gt;, &lt;Student: Jennifer Lawrence&gt;, &lt;Student: Arya Stark&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [26]: object_oriented_programming.enrolments.remove(djangojeng_e)                                                                                                 </span><br><span class="line">In [27]: object_oriented_programming.enrolments.all()                                                                                                             </span><br><span class="line">Out[27]: &lt;QuerySet [&lt;Student: Jennifer Lawrence&gt;, &lt;Student: Arya Stark&gt;]&gt;</span><br></pre></td></tr></table></figure><p><br><br></p><blockquote><p>many-to-many 로 관계된 모델들의 속성을 사용하여 </p><p>쿼리 생성하기 </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 과목중에서, 수강중인 학생 이름이 will 로 시작하는 과목 찾기 </span></span><br><span class="line"></span><br><span class="line">In [28]: Course.objects.filter(enrolments__name__startswith='Will')           </span><br><span class="line">Out[28]: &lt;QuerySet [&lt;Course: Systems Programming&gt;, &lt;Course: Algorith Design&gt;]&gt;</span><br></pre></td></tr></table></figure><br><blockquote><p>중간 모델을 사용하여, 쿼리 작성하기 </p><p>Student 가 중간 모델을 이용해서, 찾고자 하는 데이터를 조회 </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Student 중에서, 아래 조건들을 충족하는 데이터 검색 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 수강 과목 이름이 <span class="string">"Systems Programming' 인것 </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 수강 시작 날짜가 2018년 4월 19일 이후인것들을 조회 </span></span><br><span class="line"></span><br><span class="line">In [30]: Student.objects.filter( </span><br><span class="line">    ...:                 course__name='Systems Programming', </span><br><span class="line">    ...:                 enrolment__enrolled_date__gte=datetime.datetime(2018, 4, 19))  </span><br><span class="line"></span><br><span class="line">Out[30]: &lt;QuerySet [&lt;Student: Will Smith&gt;, &lt;Student: John Snow&gt;]&gt;</span><br></pre></td></tr></table></figure><p><br><br></p><blockquote><p>Enrolment 의 정보를 바로 접근 </p><p>Enrolment 모델에 직접 쿼리를 사용해서 데이터를 조회할수 있습니다 </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [32]: will_enrolment = Enrolment.objects.get(course=systems_programming, student=will)                                                                                 </span><br><span class="line">In [33]: will_enrolment.enrolled_date                                                                                                                               </span><br><span class="line">Out[33]: datetime.datetime(2019, 4, 19, 0, 0, tzinfo=&lt;UTC&gt;)</span><br><span class="line"></span><br><span class="line">In [34]: will_enrolment.finished_date                                                                                                                               </span><br><span class="line">Out[34]: datetime.datetime(2020, 4, 20, 0, 0, tzinfo=&lt;UTC&gt;)</span><br><span class="line"></span><br><span class="line">In [35]: will_enrolment.academic_record                                                                                                                             </span><br><span class="line">Out[35]: 'A'</span><br></pre></td></tr></table></figure><br><blockquote><p>Student 객체에서부터, enrolment 에 접근하는 many-to-many reverse </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n [36]: will_enrolment = will.enrolment_set.get(course=systems_programming)                                                                                              </span><br><span class="line"></span><br><span class="line">In [37]: will_enrolment.enrolled_date                                                                                                                                     </span><br><span class="line">Out[37]: datetime.datetime(2019, 4, 19, 0, 0, tzinfo=&lt;UTC&gt;)</span><br><span class="line"></span><br><span class="line">In [38]: will_enrolment.finished_date                                                                                                                                     </span><br><span class="line">Out[38]: datetime.datetime(2020, 4, 20, 0, 0, tzinfo=&lt;UTC&gt;)</span><br><span class="line"></span><br><span class="line">In [39]: will_enrolment.academic_record                                                                                                                                   </span><br><span class="line">Out[39]: 'A'</span><br></pre></td></tr></table></figure><br><p>reverse, back_ward relationship, forward relationship 에 대한 정리도 필요할것으로 보입니다! </p>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/05/Django-Models-8%ED%8E%B8-Many-to-many-%EC%98%88%EC%8B%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 8편 - Relationships (Many-to-many) B</title>
      <link>http://djangojeng-e.github.io/2020/08/04/Django-Models-8%ED%8E%B8-Relationships-Many-to-many-B/</link>
      <guid>http://djangojeng-e.github.io/2020/08/04/Django-Models-8%ED%8E%B8-Relationships-Many-to-many-B/</guid>
      <pubDate>Tue, 04 Aug 2020 12:29:24 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Many-to-Many-2편&quot;&gt;&lt;a href=&quot;#Many-to-Many-2편&quot; class=&quot;headerlink&quot; title=&quot;Many-to-Many-2편&quot;&gt;&lt;/a&gt;Many-to-Many-2편&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;Many-To-Many 인스턴스들 생성하기 &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;지난 포스팅에서, through 를 사용하여, 중간 모델을 가진 Many-to-Many 관계에 대한 모델을 작성했고. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;중간모델 Membership 을 사용하는 ManyToManyField 를 설정하였습니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;이제 몇가지 many-to-many relationship 을 생성할 준비가 되어 있습니다. 중간 모델의 인스턴스들을 생성하면서 Membership 을 사용하는 Many-to-Many 관계를 생성해 봅시다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = models.CharField(max_length=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Group&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = models.CharField(max_length=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    members = models.ManyToManyField(Person, through=&lt;span class=&quot;string&quot;&gt;&#39;Membership&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# through=&quot;Membership&quot; 을 넣어줌으로, &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# Membership 이 Person 과 Group  사이의 중간 모델 역할을 하게 만들수 있음 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.name &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Membership&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 중간 모델에서는, Person과 Group이 ForeignKey 로 등록 되어 있어야 함 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    person = models.ForeignKey(Person, on_delete=models.CASCADE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    group = models.ForeignKey(Group, on_delete=models.CASCADE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    date_joined = models.DateField() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    invite_reason = models.CharField(max_length=&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;br&gt;

&lt;p&gt;위 모델을 바탕으로, shell 에서 객체를 만들어 봅니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;shell 에 접속하려면,&lt;/p&gt;
&lt;p&gt;python manage.py shell 명령어를 커맨드 라인에서 실행 시키면 됩니다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Many-to-Many-2편"><a href="#Many-to-Many-2편" class="headerlink" title="Many-to-Many-2편"></a>Many-to-Many-2편</h2><br><p>Many-To-Many 인스턴스들 생성하기 </p><br><p>지난 포스팅에서, through 를 사용하여, 중간 모델을 가진 Many-to-Many 관계에 대한 모델을 작성했고. </p><br><p>중간모델 Membership 을 사용하는 ManyToManyField 를 설정하였습니다. </p><p><br>이제 몇가지 many-to-many relationship 을 생성할 준비가 되어 있습니다. 중간 모델의 인스턴스들을 생성하면서 Membership 을 사용하는 Many-to-Many 관계를 생성해 봅시다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line">    members = models.ManyToManyField(Person, through=<span class="string">'Membership'</span>)</span><br><span class="line">    <span class="comment"># through="Membership" 을 넣어줌으로, </span></span><br><span class="line">    <span class="comment"># Membership 이 Person 과 Group  사이의 중간 모델 역할을 하게 만들수 있음 </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Membership</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 중간 모델에서는, Person과 Group이 ForeignKey 로 등록 되어 있어야 함 </span></span><br><span class="line">    person = models.ForeignKey(Person, on_delete=models.CASCADE)</span><br><span class="line">    group = models.ForeignKey(Group, on_delete=models.CASCADE)</span><br><span class="line">    date_joined = models.DateField() </span><br><span class="line">    invite_reason = models.CharField(max_length=<span class="number">64</span>)</span><br></pre></td></tr></table></figure><br><p>위 모델을 바탕으로, shell 에서 객체를 만들어 봅니다. </p><br><blockquote><p>shell 에 접속하려면,</p><p>python manage.py shell 명령어를 커맨드 라인에서 실행 시키면 됩니다.  </p></blockquote><br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ringo = Person.objects.create(name="Ringo Starr")</span><br><span class="line">paul = Person.objects.create(name="Paul McCartney")</span><br><span class="line">beatles = Group.objects.create(name="The Beatles")</span><br><span class="line"></span><br><span class="line">import datetime </span><br><span class="line"></span><br><span class="line">m1 = Membership(person=ringo, group=beatles, date_joined=datetime.datetime(1962,8, 16), invite_reason="Needed a new drummer.")</span><br><span class="line"></span><br><span class="line">m1.save()</span><br><span class="line"></span><br><span class="line">In [7]: beatles.members.all()                                                                                                                                             </span><br><span class="line">Out[7]: &lt;QuerySet [&lt;Person: Ringo Starr&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [8]: ringo.group_set.all()                                                                                                                                             </span><br><span class="line">Out[8]: &lt;QuerySet [&lt;Group: The Beatles&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [9]: m2 = Membership.objects.create(person=paul, group=beatles, date_joined=datetime.datetime(1960, 8, 1), invite_reason="Wanted to form a band.")                     </span><br><span class="line"></span><br><span class="line">In [10]: beatles.members.all()                                                                                                                                            </span><br><span class="line">Out[10]: &lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;]&gt;</span><br></pre></td></tr></table></figure><br><blockquote><p>add(), create() 혹은 set() 을 사용해서 관계들을 생성할수도 있습니다. </p><p>요구되는 필드에 through_defaults 만 명시해주면 됩니다. </p></blockquote><br><p>공식문서에는, 아래와 같은 예제가 있는데. shell 에서 쳐보면, 하나도 제대로 동작하지 않습니다. </p><p><br>공식문서를 무슨생각으로 만들어 놓은건지;;; </p><br><p>john 이라는 객체를 생성하면 잘 동작할것입니다만. 우선, 아래와 같이 연습 내역을 담습니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [11]: beatles.members.add(john, through_defaults=&#123;'date_joined': date(1960, 8, 1)&#125;)                                                                                    </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-11-47e459b083b9&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta">----&gt;</span><span class="bash"> 1 beatles.members.add(john, through_defaults=&#123;<span class="string">'date_joined'</span>: date(1960, 8, 1)&#125;)</span></span><br><span class="line"></span><br><span class="line">NameError: name 'john' is not defined</span><br><span class="line"></span><br><span class="line">In [12]: beatles.members.create(name="George Harrison", through_defaults=&#123;'date_joined': datetime.datetime(1960, 8, 1)&#125; </span><br><span class="line">    ...: )                                                                                                                                                                </span><br><span class="line">Out[12]: &lt;Person: George Harrison&gt;</span><br><span class="line"></span><br><span class="line">In [13]: beatles.members.set([john, paul, ringo, george], through_defaults=&#123;'date_joined': date(1960, 8, 1)&#125;)                                                             </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-13-cad5aee581b9&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta">----&gt;</span><span class="bash"> 1 beatles.members.set([john, paul, ringo, george], through_defaults=&#123;<span class="string">'date_joined'</span>: date(1960, 8, 1)&#125;)</span></span><br><span class="line"></span><br><span class="line">NameError: name 'john' is not defined</span><br></pre></td></tr></table></figure><br><br><p>만약 중간 모델에 의해서, through 테이블이 커스텀 정의가 되었는데, (model1, model2 ) 페어에 강제적으로 고유성을 요구하지 않고, 다중의 값을 허용한다면, remove() 를 호출해서 모든 중간 모델 인스턴스들을 제거할수 있습니다.</p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [14]: Membership.objects.create(person=ringo, group=beatles, date_joined=datetime.datetime(1968, 9, 4), invite_reason="You've been gone for a month and we miss you.") </span><br><span class="line">Out[14]: &lt;Membership: Membership object (9)&gt;</span><br><span class="line"></span><br><span class="line">In [15]: beatles.members.all()                                                                                                                                            </span><br><span class="line">Out[15]: &lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;, &lt;Person: George Harrison&gt;, &lt;Person: Ringo Starr&gt;]&gt;</span><br><span class="line"></span><br><span class="line">In [16]: beatles.members.remove(ringo)                                                                                                                                    </span><br><span class="line"></span><br><span class="line">In [17]: beatles.members.all()                                                                                                                                            </span><br><span class="line">Out[17]: &lt;QuerySet [&lt;Person: Paul McCartney&gt;, &lt;Person: George Harrison&gt;]&gt;</span><br></pre></td></tr></table></figure><br><br><blockquote><p>clear() 메서드는, </p><p>하나의 인스턴스를 위한 모든 Many-to-Many 관계들을 없애줍니다.</p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [18]: # 비틀즈가 해산                                                                                                                                                  </span><br><span class="line"></span><br><span class="line">In [19]: beatles.members.clear()                                                                                                                                          </span><br><span class="line"></span><br><span class="line">In [20]: # 이 방식은 중간 모델 인스턴스를 삭제해줍니다                                                                                                                    </span><br><span class="line"></span><br><span class="line">In [21]: Membership.objects.all()                                                                                                                                         </span><br><span class="line">Out[21]: &lt;QuerySet []&gt;</span><br></pre></td></tr></table></figure><br><p>한번 many-to-many 관계를 성립하였으면, 쿼리들을 발행할수 있습니다. 보통의 many-to-many 관계와 같이, many-to-many 로 관계된 모델들의 속성들을 사용하여 쿼리를 사용할수 있습니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 멤버의 이름이 <span class="string">'Paul'</span> 로 시작하는 그룹 찾기                                                                                                                     </span></span><br><span class="line"></span><br><span class="line">In [39]: Group.objects.filter(members__name__startswith='Paul')                                                                                                           </span><br><span class="line">Out[39]: &lt;QuerySet [&lt;Group: The Beatles&gt;]&gt;</span><br></pre></td></tr></table></figure><br><p>중간 모델을 사용하면서, 중간 모델의 속성을 쿼리 조회 할수 있습니다. </p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Person 중에, group 이름이 <span class="string">'The Beatles'</span> 이면서 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Membership에 든 날짜가 1961년 1월 1일 보다 이후인 객체를 조회 </span></span><br><span class="line">In [40]: Person.objects.filter( </span><br><span class="line">    ...:     group__name='The Beatles', </span><br><span class="line">    ...:     membership__date_joined__gt=datetime.datetime(1961, 1, 1))                                                                                                   </span><br><span class="line">Out[40]: &lt;QuerySet [&lt;Person: Ringo Starr&gt;]&gt;</span><br></pre></td></tr></table></figure><br><blockquote><p>membership  의 정보를 바로 접근하고 싶으면, </p><p>바로 Membership 모델에 쿼리를 보내면 됩니다. </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [41]: ringos_membership = Membership.objects.get(group=beatles, person=ringo)                                                                                          </span><br><span class="line"></span><br><span class="line">In [42]: ringos_membership.date_joined                                                                                                                                    </span><br><span class="line">Out[42]: datetime.date(1962, 8, 16)</span><br><span class="line"></span><br><span class="line">In [43]: ringos_membership.invite_reason                                                                                                                                  </span><br><span class="line">Out[43]: 'Needed a new drummer.'</span><br></pre></td></tr></table></figure><br><br><blockquote><p>Person 객체에서 부터 거꾸로 가는  </p><p>Many-To-Many reverse 관계도 존재합니다 </p></blockquote><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [44]: ringos_membership = ringo.membership_set.get(group=beatles)                                                                                                      </span><br><span class="line"></span><br><span class="line">In [45]: ringos_membership.date_joined                                                                                                                                    </span><br><span class="line">Out[45]: datetime.date(1962, 8, 16)</span><br><span class="line"></span><br><span class="line">In [46]: ringos_membership.invite_reason                                                                                                                                  </span><br><span class="line">Out[46]: 'Needed a new drummer.'</span><br></pre></td></tr></table></figure><br><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>공식문서가 예시도 너무 불충분하고,, 뭐라 설명은 하는지는 잘 모르겠습니다. </p><p><br>다음 포스팅에서는, ManyToMany 예제를 좀 들어서, 데이터베이스 검색 및 쿼리문 사용을 좀 연습 해봐야 할것 같습니다. </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/04/Django-Models-8%ED%8E%B8-Relationships-Many-to-many-B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 8편 - Relationships (Many-to-many) A</title>
      <link>http://djangojeng-e.github.io/2020/08/03/Django-Models-8%ED%8E%B8-Relationships-Many-to-many/</link>
      <guid>http://djangojeng-e.github.io/2020/08/03/Django-Models-8%ED%8E%B8-Relationships-Many-to-many/</guid>
      <pubDate>Mon, 03 Aug 2020 09:29:15 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Many-to-many-Relationships&quot;&gt;&lt;a href=&quot;#Many-to-many-Relationships&quot; class=&quot;headerlink&quot; title=&quot;Many-to-many Relationships&quot;&gt;&lt;/a&gt;Many-to-many Relationships&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;many-to-many 관계를 정의하기 위해서는, ManyToManyField 를 사용해 주면 됩니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;다른 Field 타입을 사용하는것과 비슷하게 사용합니다. 클래스 속성에 포함해주는 방식으로 사용하면 됩니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;ManyToManyField 는 위치 인자를 필요로 합니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;관계된 모델을 &lt;/p&gt;
&lt;p&gt;ManyToManyField 의 위치인자로 넣어주어야 합니다 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;예를들면, 하나의 피자가 다수의 토핑 객체를 가진다면, &lt;/p&gt;
&lt;p&gt;&lt;br&gt;- 토핑은 다수의 피자에 있을수 있고, 각 피자는 다수의 토핑들을 가질수 있습니다. &lt;/p&gt;
&lt;p&gt;이러한 관계는 아래의 형태로 표현될수 있습니다. &lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; models &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Topping&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# ... &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Pizza&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# ... &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# toppings = models.ManyToManyField(Topping)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Many-to-many-Relationships"><a href="#Many-to-many-Relationships" class="headerlink" title="Many-to-many Relationships"></a>Many-to-many Relationships</h2><br><p>many-to-many 관계를 정의하기 위해서는, ManyToManyField 를 사용해 주면 됩니다. </p><p><br>다른 Field 타입을 사용하는것과 비슷하게 사용합니다. 클래스 속성에 포함해주는 방식으로 사용하면 됩니다. </p><br><p>ManyToManyField 는 위치 인자를 필요로 합니다. </p><br><blockquote><p>관계된 모델을 </p><p>ManyToManyField 의 위치인자로 넣어주어야 합니다 </p></blockquote><br><p>예를들면, 하나의 피자가 다수의 토핑 객체를 가진다면, </p><p><br>- 토핑은 다수의 피자에 있을수 있고, 각 피자는 다수의 토핑들을 가질수 있습니다. </p><p>이러한 관계는 아래의 형태로 표현될수 있습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topping</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ... </span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ... </span></span><br><span class="line">    <span class="comment"># toppings = models.ManyToManyField(Topping)</span></span><br></pre></td></tr></table></figure><p><br><a id="more"></a></p><p>ForeignKey 와 마찬가지로, 재귀적인 관계를 생성할수도 있습니다. (객체가 many-to-many 관계를 자기 자신에게 갖는것). 그리고, 아직 정의되지 않은 모델과도 관계를 생성할수도 있습니다. </p><br><blockquote><p>필수는 아니지만, 권장 사항으로는, </p><p>ManyToManyField 필드명은, 관계된 모델 객체의 복수형으로 표현합니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ... </span></span><br><span class="line">    toppings = models.ManyToManyField(Topping)</span><br><span class="line">    <span class="comment"># toppings 라고 복수형의 필드로 사용</span></span><br></pre></td></tr></table></figure><br><p>위 예시에서 Pizza 와 Topping, 두 모델을 예시로 들어봤는데. </p><p>두 모델중 한쪽에만 ManyToManyField 가 사용되어야 합니다. 양쪽 다 사용하지는 않습니다! </p><br><p>보통 ManyToManyField 인스턴스들은, Form 에서 수정될 객체에 생성됩니다. </p><p><br>위 예시에서는, Pizza 안에 toppings 가 들어가 있는데. Pizza 가 여러개의 topping 들을 가지고, 피자에 들어간 토핑을 고치는 개념이 Topping 이 Pizza 를 가지고, 토핑에 들어간 피자를 고치는것보다 자연스럽기 때문에. </p><p><br>Pizza 클래스안에 ManyToManyField 를 넣어준것입니다. </p><br><h2 id="Extra-fields-on-many-to-many-relationships"><a href="#Extra-fields-on-many-to-many-relationships" class="headerlink" title="Extra fields on many-to-many relationships"></a>Extra fields on many-to-many relationships</h2><br><p>many-to-many 관계에는, 추가적인 필드들이 존재합니다. </p><p><br>피자와 토핑같은 피자와 토핑을 섞고 매칭하는 다대다 관계를 다룰때는, 일반적인 ManyToManyField 만으로도 충분히 다룰수 있습니다. </p><br><p>하지만, 때때로, 우리는 두개의 모델 사이의 관계를 관련지어서 데이터들을 생각할 필요가 생깁니다. </p><br><p>예를들어서, 뮤지컬 그룹과 뮤지컬 그룹들에 속해 있는 뮤지션들의 관계를 생각해 봅시다. </p><p><br><br></p><p>한 사람과, 사람이 멤버로 속해 있는 그룹 사이에는 many-to-many 관계를 사용할수 있습니다. 따라서, ManyToManyField 를 사용하여 해당 관계를 표현할수 있습니다. 그렇지만, 멤버쉽에 대한 조금 더 많은 세부 사항들을 수집하고 싶어질지 모릅니다. 예를들면, 아래와 같은 사항들을 따로 기록해 놓고 싶을지 모릅니다. </p><br><ul><li>사람이 어떤 날짜에 그룹에 합류 하였는지  </li><li>언제 떠나갔는지 </li><li>가입 장소는 어디인지 </li><li>기타 정보 </li></ul><br><p>이러한 상황들에서, Django 는 many-to-many 관계를 관리하기 위한 모델을 명시할수 있게 해줍니다.  </p><p><br><code>extra field</code> 를 중간 모델에 넣어둘수 있습니다.  여기서 이야기 하는 중간 모델은, 새로운 모델로써, ManyToManyField 와 연관되어 있고, through 인자를 사용하여, 해당 모델이 중간 모델 역할을 할거라고 명시할수 있습니다. <br></p><br><blockquote><p>조금 더 복잡한 many-to-many 관계를 관리하기 위해, 두 모델 사이에 어떠한 모델을 생성해 주고. </p><p>extra field  들을 중간 모델에 넣어주고 사용할수 있습니다. </p><br><p>중간 모델은 ManyToManyField 와 연관되어 있고, through 인자를 사용하여, </p><p>해당 모델이 중간 모델 역할을 할것이라고 명시할수 있습니다. </p><br><p>코드를 보면서 이해하는것이 더 빠를것입니다. 뮤지션 예시를 보면 아래와 같습니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line">    members = models.ManyToManyField(Person, through=<span class="string">'Membership'</span>)</span><br><span class="line">    <span class="comment"># through = "Membership" 을 넣어줌으로, </span></span><br><span class="line">    <span class="comment"># Membership 이 Person 과 Group 사이의 중간 모델 역할을 하게 만들수 있음 </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Membership</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 중간 모델에서는, Person 과 Group 이 ForeginKey 로 등록 되어 있어야 함 </span></span><br><span class="line">    person = models.ForeignKey(Person, on_delete=models.CASCADE)</span><br><span class="line">    group = models.ForeignKey(Group, on_delete=models.CASCADE)</span><br><span class="line">    date_joined = models.DateField()</span><br><span class="line">    invite_reason = models.CharField(max_length=<span class="number">64</span>)</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="중간모델의-제약사항"><a href="#중간모델의-제약사항" class="headerlink" title="중간모델의 제약사항"></a>중간모델의 제약사항</h2><p><br><br></p><ul><li>중간 모델은 반드시 하나의 소스모델을 가르키는 foreign Key 를 가져야 합니다 (예시에서는 Group 이 됩니다) </li><li>Group 모델이 바로 소스 모델인데, Group class 안에 <code>through=&#39;Membership&#39;</code> 을 사용해서, Membership 이 Group 모델에 대한 중간 모델이 되게 만들어 주었습니다. </li><li>따라서, 중간 모델인  Membership 에서 1개의 Foreign Key 를 소스 모델인 Group 에 지정해 주었습니다. </li></ul><br><p><strong>유의사항</strong></p><br><p>소스모델이 두개 이상이라면, ManyToManyField.through_fields 를 사용해서, Django 가 데이터베이스 관계를 위해 사용할 foreign key 들을 명시적으로 지정해 줘야 합니다. </p><p>만약 foreign key 가 한개 이상 있고, through_fields 가 지정되어 있지 않으면, 유효성 에러가 발생하게 됩니다. </p><p><br>비슷한 제약 사항이 타겟 모델에 쓰이는 Foreign key 에도 적용됩니다 (예시에서는, Person 모델이 타겟 모델입니다)<br><br></p><p>- 중간 모델을 통해서 many-to-many 관계를 자기자신에 갖는 모델들은, 두개의 Foreign key 들을 같은 모델에 지정하는것이 허용됩니다. 하지만, 이것은 many-to-many 관계의 양쪽 사이드로 취급됩니다. 만일 2개 이상의 foreign key 들이 존재한다면, through_fields 를 사용해서 지정을 해줘야 합니다. 그렇지 않으면, 유효성 에러가 발생 합니다.  </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/03/Django-Models-8%ED%8E%B8-Relationships-Many-to-many/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 7편 - Relationships (Many-to-one)</title>
      <link>http://djangojeng-e.github.io/2020/08/03/Django-Models-7%ED%8E%B8-Relationships-Many-to-one/</link>
      <guid>http://djangojeng-e.github.io/2020/08/03/Django-Models-7%ED%8E%B8-Relationships-Many-to-one/</guid>
      <pubDate>Mon, 03 Aug 2020 07:07:49 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Models-Relationships-Many-to-one&quot;&gt;&lt;a href=&quot;#Models-Relationships-Many-to-one&quot; class=&quot;headerlink&quot; title=&quot;Models - Relationships (Many-to-one)&quot;&gt;&lt;/a&gt;Models - Relationships (Many-to-one)&lt;/h2&gt;&lt;br&gt;

&lt;br&gt;

&lt;p&gt;확실히, 관계형 데이터베이스의 장점은, 테이블들끼리 관계를 생성하는데에서 옵니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;관계형 데이터베이스란?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;데이터베이스계의 주류로, &lt;/p&gt;
&lt;p&gt;데이터를 로우 (Row:행, 줄) 과 컬럼 (Column: 열, 칸) 이라는 일종의 표 형태로 저장하고, &lt;/p&gt;
&lt;p&gt;데이터의 종속성은 관계 (Relation) 으로 표현한다. &lt;/p&gt;
&lt;p&gt;한 테이블에 있는 모든 로우는 같은 길이의 컬럼을 가지고 있으며, 이 컬럼의 구조와 데이터의 관계가 테이블 스키마 (Schema) 로 사전 정의 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;br&gt;

&lt;p&gt;Django 는 가장 공통적인 relational database 3가지를 지원합니다. &lt;/p&gt;
&lt;br&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;many-to-one (1:M, 1 대 다수)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;many-to-many (M:M, 다수 대 다수)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;one-to-one (1:1, 일 대 일 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Models-Relationships-Many-to-one"><a href="#Models-Relationships-Many-to-one" class="headerlink" title="Models - Relationships (Many-to-one)"></a>Models - Relationships (Many-to-one)</h2><br><br><p>확실히, 관계형 데이터베이스의 장점은, 테이블들끼리 관계를 생성하는데에서 옵니다. </p><br><blockquote><p><strong>관계형 데이터베이스란?</strong></p><p>데이터베이스계의 주류로, </p><p>데이터를 로우 (Row:행, 줄) 과 컬럼 (Column: 열, 칸) 이라는 일종의 표 형태로 저장하고, </p><p>데이터의 종속성은 관계 (Relation) 으로 표현한다. </p><p>한 테이블에 있는 모든 로우는 같은 길이의 컬럼을 가지고 있으며, 이 컬럼의 구조와 데이터의 관계가 테이블 스키마 (Schema) 로 사전 정의 된다.</p></blockquote><br><br><p>Django 는 가장 공통적인 relational database 3가지를 지원합니다. </p><br><ul><li><p>many-to-one (1:M, 1 대 다수)</p></li><li><p>many-to-many (M:M, 다수 대 다수)</p></li><li><p>one-to-one (1:1, 일 대 일 )</p></li></ul><a id="more"></a><br><h2 id="Many-to-one-relationships"><a href="#Many-to-one-relationships" class="headerlink" title="Many-to-one relationships"></a>Many-to-one relationships</h2><br><p>다수 : 1 혹은 1: 다수 관계를 정의하기 위해서는, django.db.models.ForeignKey 를 사용합니다. </p><p>모델내에 클래스 속성으로 다른 필드 타입을 사용하는것과 비슷하게 사용할수 있습니다. </p><br><blockquote><p>ForeignKey 는 위치 인자를 필수적으로 필요로 합니다 </p><p>ForeignKey 를 사용하면, 다른 모델과 해당 필드에 관계를 만들어 놓을수 있습니다. </p><p>ForeignKey 를 사용할때에는, 위치인자에 관계를 만들고 싶은 다른 class 이름을 넣어줍니다. </p><br><p>예를들면, </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manufuacturer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ... </span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 여러대의 Car 는 1개의 Manufacturuer 를 가집니다 </span></span><br><span class="line">    <span class="comment"># ForeginKey 를 사용해서, 이 관계를 모델링 해줄수 있습니다. </span></span><br><span class="line">    <span class="comment"># 위의 Manufacturer 클래스를 소문자화한 이름으로 필드명을 짓는것이 권장 됩니다. </span></span><br><span class="line">    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><br><ul><li>Car 모델은 하나의 Manufacturer 를 가집니다 </li><li>하나의 Manufacturer (브랜드 공장) 은 여러개의 자동차를 생산합니다 </li><li>하지만, 각 자동차는 하나의 Manufacturer 만 가질수 있습니다 </li><li>다수 : 1 의 데이터베이스 관계를 성립하여, ForeignKey 를 이용해 위의 예시처럼 정의해주었습니다. </li></ul><br><p>또한, 재귀적인 관계를 생성할수도 있습니다 (many-to-one 관계를 스스로 갖는 객체) </p><br><p>필수는 아니지만, 권장되는 사항은, ForeignKey 필드 이름은 해당 모델의 소문자로 표현하는게 좋습니다. </p><p><br>하지만, 당연히 필드명은 우리가 원하는데로 지을수 있습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    company_that_makes_it = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 필드명을 company_that_makes_it 으로, 사용자가 사용하기 편하게 지어줬습니다 </span></span><br><span class="line">    <span class="comment"># 하지만, 이 필드명은 Manufacturer 의 소문자 형태인 manufacturer 로 짓는것이 권장됩니다.</span></span><br></pre></td></tr></table></figure><br><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dev_Department</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    team = models.CharField(max_length=<span class="number">40</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dev_Staff</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">40</span>, verbose_name=<span class="string">"직원이름"</span>)</span><br><span class="line">    department = models.ForeignKey(Dev_Department, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><br><ul><li>개발 조직에 있는 하나의 팀에는, 여러명의 직원이 소속될수 있습니다 </li><li>Dev_Staff 는, 직원의 이름과 부서 팀을 정의합니다. ForeignKey 를 사용하여, Dev_Department 와 관계를 가지게 정의되었습니다. </li></ul><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/03/Django-Models-7%ED%8E%B8-Relationships-Many-to-one/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 6편 - Fields (verbose field names)</title>
      <link>http://djangojeng-e.github.io/2020/08/02/Django-Models-6%ED%8E%B8-Fields-verbose-field-names/</link>
      <guid>http://djangojeng-e.github.io/2020/08/02/Django-Models-6%ED%8E%B8-Fields-verbose-field-names/</guid>
      <pubDate>Sun, 02 Aug 2020 12:22:43 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Models-Fields-verbose-field-names&quot;&gt;&lt;a href=&quot;#Models-Fields-verbose-field-names&quot; class=&quot;headerlink&quot; title=&quot;Models - Fields (verbose field names)&quot;&gt;&lt;/a&gt;Models - Fields (verbose field names)&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;&lt;code&gt;ForeignKey&lt;/code&gt;, &lt;code&gt;ManyToManyField&lt;/code&gt; 그리고 &lt;code&gt;OneToOneField&lt;/code&gt; 들을 제외한, 각 필드 타입은 선택적으로 첫번째 위치인자로, &lt;code&gt;verbose name&lt;/code&gt; 을 받습니다. &lt;/p&gt;
&lt;br&gt;

&lt;p&gt;&lt;code&gt;verbose name&lt;/code&gt; 이 주어지지 않았을때는, Django 는 자동으로 field 의 속성명의 언더스코어를 공백으로 전환하여 verbose name 을 생성합니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;verbose name 은 &lt;/p&gt;
&lt;p&gt;사용자가 사용하는 자세한 이름을 의미합니다 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;&lt;code&gt;verbose name&lt;/code&gt; 을 지정하지 않으면, 어드민에 표시되는 이름이 이상하다는것을 느낄수 있을겁니다. &lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Models-Fields-verbose-field-names"><a href="#Models-Fields-verbose-field-names" class="headerlink" title="Models - Fields (verbose field names)"></a>Models - Fields (verbose field names)</h2><br><p><code>ForeignKey</code>, <code>ManyToManyField</code> 그리고 <code>OneToOneField</code> 들을 제외한, 각 필드 타입은 선택적으로 첫번째 위치인자로, <code>verbose name</code> 을 받습니다. </p><br><p><code>verbose name</code> 이 주어지지 않았을때는, Django 는 자동으로 field 의 속성명의 언더스코어를 공백으로 전환하여 verbose name 을 생성합니다. </p><br><blockquote><p>verbose name 은 </p><p>사용자가 사용하는 자세한 이름을 의미합니다 </p></blockquote><br><p><code>verbose name</code> 을 지정하지 않으면, 어드민에 표시되는 이름이 이상하다는것을 느낄수 있을겁니다. </p><br><a id="more"></a><br><blockquote><p>아래 예시에서, verbose name 은 “person’s first name” 입니다 </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_name = models.CharField(<span class="string">"person's first name"</span>, max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><br><blockquote><p>아래 예시에서는, verbose name 이 “first name” 입니다.</p><p>필드 타입의 첫번째 인자로, verbose name 이 명시되지 않았기 때문에, </p><p>필드명 first_name 에서, 언더스코어를 공백으로 전환하여 verbose name 을 표시합니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_name = models.CharField(max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><br><blockquote><p>verbose_name 을 정의한 모델의 예시입니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Members</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>, verbose_name=<span class="string">'이름'</span>)</span><br><span class="line">    nick_name = models.CharField(max_length=<span class="number">50</span>, verbose_name=<span class="string">"닉네임"</span>)</span><br><span class="line">    birth_date = models.DateField(verbose_name=<span class="string">"생년월일"</span>, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br><p>위 Members 모델에서는, name, nick_name, birth_date 이 각각 한글로 표시된 verbose_name 들을 어드민에 표시할것입니다.  </p><br><h2 id="외래키-모델들"><a href="#외래키-모델들" class="headerlink" title="외래키 모델들"></a>외래키 모델들</h2><br><p>아직 살펴보지는 않았지만, <code>ForeignKey</code>, <code>ManyToManyField</code> 그리고 <code>OneToOneField</code> 들은 첫번째 인자로 모델 클래스가 옵니다. </p><blockquote><p>따라서, <code>verbose_name</code>을 키워드 인자로 사용해줍니다. </p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">poll = models.ForeignKey(Poll, on_delete=models.CASCADE, verbose_name=<span class="string">"the related poll"</span>)</span><br><span class="line"><span class="comment"># poll 은 ForeignKey (외래키) 로 Poll 이라는 클래스를 첫번째 인자로 받음 </span></span><br><span class="line"><span class="comment"># verbose_name 은 키워드 인자로 넣어줌 </span></span><br><span class="line"></span><br><span class="line">sites = models.ManyToManyField(Site, verbose_name=<span class="string">"list of sites"</span>)</span><br><span class="line"><span class="comment"># sites 는 ManyToManyField 로 Site 라는 클래스를 첫번째 인자로 받음 </span></span><br><span class="line"><span class="comment"># verbose_name 은 키워드 인자로 넣어줌 </span></span><br><span class="line"></span><br><span class="line">place = models.OneToOneField(Place, on_delete=models.CASCADE, verbose_name=<span class="string">'related place'</span>)</span><br><span class="line"><span class="comment"># place 는 OneToOneField 로 Place 라는 클래스를 첫번째 인자로 받음 </span></span><br><span class="line"><span class="comment"># verbose_name 은 키워드 인자로 넣어줌</span></span><br></pre></td></tr></table></figure><br><p>위의 예시에서는, 단지 <code>ForeignKey</code>, <code>ManyToManyField</code>  그리고 <code>OneToOneField</code> 를 사용할때에, verbose_name 이 어떻게 키워드 인자로 들어가는지에 대한 코딩 스타일만 보여주고 있습니다. </p><br><blockquote><p>관례적으로, </p><p>verbose_name 의 첫번째 글자는 대문자로 써주지 않습니다. </p><p>Django 가 필요할때 자동으로 첫번째 글자를 대문자화 해줍니다. </p></blockquote><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>verbose_name 에 대해서 알아보았습니다.<br>verbose_name 을 사용하면, 어떤것이 달라지는지 완벽한 예시가 있으면 좋았을텐데, <br><br></p><p>현재까지는, verbose_name 을 사용할경우, 해당 필드가 어드민에 표시되는 바가 달라지게 된다는점을 알고 넘어가면 될것 같습니다. </p><br><p>지난 포스팅에서 Runner 모델을 작성했었는데, 아래와 같이, <br></p><p>name 필드에 verbose_name 을 추가해주었습니다. “러너 이름” </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    MedalType = models.TextChoices(<span class="string">'MedalType'</span>, <span class="string">'GOLD SILVER BRONZE'</span>)</span><br><span class="line">    name = models.CharField(<span class="string">"러너이름"</span>, max_length=<span class="number">60</span>)</span><br><span class="line">    medal = models.CharField(blank=<span class="literal">True</span>, choices=MedalType.choices, max_length=<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name + <span class="string">" "</span> + self.medal</span><br></pre></td></tr></table></figure><br><p>위와같이 verbose_name 을 모델 필드에 추가하면, 아래처럼 어드민에 “러너이름” 이라고 표시가 됩니다. </p><br><img src="/2020/08/02/Django-Models-6%ED%8E%B8-Fields-verbose-field-names/image1.png" class="">]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/02/Django-Models-6%ED%8E%B8-Fields-verbose-field-names/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 5편 - Fields (Automatic primary key fields)</title>
      <link>http://djangojeng-e.github.io/2020/08/02/Django-Models-5%ED%8E%B8-Fields-Automatic-primary-key-fields/</link>
      <guid>http://djangojeng-e.github.io/2020/08/02/Django-Models-5%ED%8E%B8-Fields-Automatic-primary-key-fields/</guid>
      <pubDate>Sun, 02 Aug 2020 10:22:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Models-Fields-Automatic-primary-key&quot;&gt;&lt;a href=&quot;#Models-Fields-Automatic-primary-key&quot; class=&quot;headerlink&quot; title=&quot;Models - Fields(Automa
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Models-Fields-Automatic-primary-key"><a href="#Models-Fields-Automatic-primary-key" class="headerlink" title="Models - Fields(Automatic primary key)"></a>Models - Fields(Automatic primary key)</h2><br><p>기본값으로, Django 는 각 모델에 다음과 같은 field 를 부여 합니다. </p><p>아래 필드는, 해당 모델에 명시적으로 정의해 놓지 않아도, 자동으로 적용이 되어 있습니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br><p>이는, 자동으로 증가하는 primary key 입니다. </p><br><p>만약 사용자 정의의 primary key  를 명시하고 싶으면, primary_key 로 사용하고 싶은 필드에, <code>primary_key=True</code> 를 명시해주면 됩니다. </p><br><p>만약, 여러분들이 명시적으로, 어떠한 필드에 <code>primary_key = True</code> 를 설정한것을 보면, django 는 자동으로 id 컬럼을 추가하지 않을것입니다. </p><br><p>각 모델은, 정확히 하나의 필드가 primary_key = True 를 가질것을 요구합니다 (두개 이상의 필드가 primary_key=True  를 가질수는 없다는 이야기 입니다) </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/02/Django-Models-5%ED%8E%B8-Fields-Automatic-primary-key-fields/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Models 4편 - Fields (Field Options)</title>
      <link>http://djangojeng-e.github.io/2020/08/02/Django-Models-4%ED%8E%B8-Fields-Field-Options/</link>
      <guid>http://djangojeng-e.github.io/2020/08/02/Django-Models-4%ED%8E%B8-Fields-Field-Options/</guid>
      <pubDate>Sun, 02 Aug 2020 01:53:03 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Field-Options&quot;&gt;&lt;a href=&quot;#Field-Options&quot; class=&quot;headerlink&quot; title=&quot;Field Options&quot;&gt;&lt;/a&gt;Field Options&lt;/h2&gt;&lt;br&gt;

&lt;p&gt;각각의 필드들은, 해당 필드에 특화된 독립 변수들을 갖습니다. &lt;/p&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;예를들면, &lt;/p&gt;
&lt;p&gt;CharField 와 CharField 의 서브클래스들은, &lt;/p&gt;
&lt;p&gt;max_length 같은, 데이터를 저장하기 위해서 길이를 정의하는 독립된 변수들을 갖게 됩니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;

&lt;p&gt;또한, 모든 필드 타입들에 유효한, 공통 독립 변수들도 존재합니다. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;모든 변수들은, 선택적으로 사용할수 있고, reference 문서에 완벽하게 설명이 되어 있지만. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;strong&gt;가장 공통적으로 많이 사용되는것들을 정리하고 넘어갑니다.&lt;/strong&gt; &lt;br&gt;&lt;/p&gt;
&lt;br&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Field-Options"><a href="#Field-Options" class="headerlink" title="Field Options"></a>Field Options</h2><br><p>각각의 필드들은, 해당 필드에 특화된 독립 변수들을 갖습니다. </p><br><blockquote><p>예를들면, </p><p>CharField 와 CharField 의 서브클래스들은, </p><p>max_length 같은, 데이터를 저장하기 위해서 길이를 정의하는 독립된 변수들을 갖게 됩니다. </p></blockquote><br><p>또한, 모든 필드 타입들에 유효한, 공통 독립 변수들도 존재합니다. </p><p><br>모든 변수들은, 선택적으로 사용할수 있고, reference 문서에 완벽하게 설명이 되어 있지만. </p><p><br><strong>가장 공통적으로 많이 사용되는것들을 정리하고 넘어갑니다.</strong> <br></p><br><a id="more"></a> <br><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><br><p><code>null=True</code> 일 경우에, Django 는 빈값을 NULL 로 데이터베이스에 저장합니다. </p><p>기본값은 False 입니다. </p><br><h3 id="blank"><a href="#blank" class="headerlink" title="blank"></a>blank</h3><br><p><code>blank=True</code> 일 경우에, 필드는 비어있는 값이 허용됩니다. 기본값은 False 입니다. </p><br><br><h2 id="NULL-vs-Blank"><a href="#NULL-vs-Blank" class="headerlink" title="NULL vs Blank?"></a>NULL vs Blank?</h2><br><blockquote><p>blank 와 null 은 다르다는것을 숙지해야 합니다. </p><p>null 은 순수하게 데이터베이스 측면에서 생각하는 값이고, </p><p>blank 는 검증 혹은 유효성 검사 측면에서 바라보는것입니다. </p><br><p>null 은 필드의 값이 NULL (정보없음) 으로 저장되는것을 허용하고, </p><p>blank 는 필드가 폼(입력 양식) 에서 비어있는 채로 저장되는것을 허용합니다. </p><br><p>blank = false 이면, 해당 필드가 비어있는채로 저장되는것을 허용하지 않습니다. </p><p>비슷하게도, null=false 일 경우에, 필드의 값이 NULL (정보없음) 으로 저장되는것을 허용하지 않습니다. </p></blockquote><br><h3 id="choices"><a href="#choices" class="headerlink" title="choices"></a>choices</h3><br><p>2개로된 튜플은, 필드의 선택값으로 사용할수 있습니다. </p><p><br>튜플이 주어지면, 기본 양식 폼 위젯은 문자열 필드 대신에 select box 가 될것이고, 튜플에 들어있는 선택들로, 선택이 제한됩니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YEAR_IN_SCHOOL_CHOICES = [</span><br><span class="line">    (<span class="string">'FR'</span>, <span class="string">'Freshman'</span>), </span><br><span class="line">    (<span class="string">'SO'</span>, <span class="string">'Sophomore'</span>), </span><br><span class="line">    (<span class="string">'JR'</span>, <span class="string">'Junior'</span>), </span><br><span class="line">    (<span class="string">'SR'</span>, <span class="string">'Senior'</span>), </span><br><span class="line">    (<span class="string">'GR'</span>, <span class="string">'Graduate'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br><p>여기서 알아야 할게, </p><br><blockquote><p>Choices 의 순서가 바뀔대마다, 새로운 migration  이 생겨납니다. </p></blockquote><br><blockquote><p>또한, </p><p>튜플의 첫번째 값은, 데이터베이스에 저장되는 값이고, </p><p>튜플의 두번째 값은, 필드의 입력양식 위젯에 표시됩니다. 즉, 이 모델을 가지고 폼 (입력양식) 을 만들었을때, 입력양식 위젯에 표시되는것은, 튜플의 두번째 값이고. </p><p>실제 사용자가 이 입력양식을 통해서 값을 입력하여 데이터베이스에 저장할시에는, 튜플의 첫번째 값으로 저장이 됩니다. </p></blockquote><br><br><p>모델 인스턴스가 주어졌을때, Choices 를 가진 필드의 표시값은, get_shirt_size_display() 메서드를 사용해서 접근할수 있습니다. 아래 예시를 통해서 알아봅니다. </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    SHIRT_SIZES = (</span><br><span class="line">    (<span class="string">'S'</span>, <span class="string">'Small'</span>),</span><br><span class="line">        (<span class="string">'M'</span>, <span class="string">'Medium'</span>),</span><br><span class="line">        (<span class="string">'L'</span>, <span class="string">'Large'</span>),</span><br><span class="line">    )</span><br><span class="line">    name = models.CharField(max_length=<span class="number">60</span>)</span><br><span class="line">    shirt_size = models.CharField(max_length=<span class="number">1</span>, choices=SHIRT_SIZES)</span><br></pre></td></tr></table></figure><br><h4 id="choices-값의-표시"><a href="#choices-값의-표시" class="headerlink" title="choices 값의 표시"></a>choices 값의 표시</h4><p><br><br></p><ul><li>shirt_size 가 데이터베이스에 저장될때에는, 튜플의 첫번째 값들인, S, M, L 로 저장이 되고 </li><li>shirt_size 가 폼에 표시될때는, Small, Medium, Large 로 표시가 됩니다 </li><li>이렇게 데이터베이스 외의 위치에서 표시되는 값들은, get_shirt_size_display() 로 호출할수 있습니다. </li></ul><br><br><blockquote><p>실제로 model 을 작성해서 테스트 해봅니다 </p><p>shell 에 접속하여, 아래 코드를 입력합니다. </p></blockquote><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell 에 접속 </span></span><br><span class="line">python manage.py shell </span><br><span class="line"></span><br><span class="line"><span class="comment"># shell 접속후에 실습 </span></span><br><span class="line"></span><br><span class="line">In [1]: p = Person(name=<span class="string">"Superman"</span>, shirt_size=<span class="string">"L"</span>)                                   </span><br><span class="line"></span><br><span class="line">In [2]: <span class="comment"># Person의 name이 Superman, 셔츠 사이즈가 L 인 인스턴스 생성                                                                                                      </span></span><br><span class="line"></span><br><span class="line">In [3]: p.save()                                                                                                                                                          </span><br><span class="line"></span><br><span class="line">In [4]: <span class="comment">#  p.save() 를 호출하여, p 를 데이터베이스에 저장                                                                                                                 </span></span><br><span class="line"></span><br><span class="line">In [5]: p.shirt_size                                                                                                                                                      </span><br><span class="line">Out[5]: <span class="string">'L'</span></span><br><span class="line"></span><br><span class="line">In [6]: p.get_shirt_size_display()                                                                                                                                        </span><br><span class="line">Out[6]: <span class="string">'Large'</span></span><br><span class="line"></span><br><span class="line">In [7]: <span class="comment"># p의 shirt_size의 display 값을 표시</span></span><br></pre></td></tr></table></figure><br><p>어드민에서 SHIRT_SIZE 는  Large 라고 표시됩니다.</p><br><img src="/2020/08/02/Django-Models-4%ED%8E%B8-Fields-Field-Options/image1.png" class=""><br><p>하지만, 정작 DB 에는, L 로 저장되어 있는것을 확인 할수 있습니다. </p><br><img src="/2020/08/02/Django-Models-4%ED%8E%B8-Fields-Field-Options/image2.png" class=""><br><br><h4 id="간단하게-choices-정의하기"><a href="#간단하게-choices-정의하기" class="headerlink" title="간단하게 choices 정의하기"></a>간단하게 choices 정의하기</h4><br><p>enumeration 클래스들을 사용해서 간단한 방법으로 choices 들을 정의할수 있습니다 </p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">class Runner(models.Model);</span><br><span class="line">MedalType = models.TextChoices(<span class="string">'MedalType'</span>, <span class="string">'GOLD SILVER BRONZE'</span>)</span><br><span class="line"><span class="comment"># 튜플에서 두번째 값인, 'GOLD SILVER BRONZE' 가 선택할수 있는값이 됨 </span></span><br><span class="line">name = models.CharField(max_length=<span class="number">60</span>)</span><br><span class="line">medal = models.CharField(blank=<span class="literal">True</span>, choices=MedalType.choices, max_length=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><br><blockquote><p>Runner 를 추가할때, GOLD SILVER BRONZE 셋중 하나를 선택해서 추가할수 있습니다. </p></blockquote><br><img src="/2020/08/02/Django-Models-4%ED%8E%B8-Fields-Field-Options/image3.png" class=""><p><br><br></p><h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><br><p>필드의 기본값을 지정합니다. 기본값은 특정 값일수도 있고, 호출 가능한 객체일수도 있습니다. </p><p>호출 가능한 객체라면, 새로운 객체가 생성될때마다, 호출이 됩니다.<br></p><p>예) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line">class Djangojeng_e(models.Model);</span><br><span class="line"><span class="comment"># 이름이 장고쟁이인 객체만 생성할수 있음 </span></span><br><span class="line">name = models.CharFied(max_length=<span class="number">20</span>, default=<span class="string">'장고쟁이'</span>)</span><br></pre></td></tr></table></figure><br><h3 id="help-text"><a href="#help-text" class="headerlink" title="help_text"></a>help_text</h3><br><p>추가적인 help 텍스트가 입력양식 위젯과 함께 표시가 됩니다. 필드가 입력양식에서 사용되지 않더라도. </p><p><br>문서화 할때에 유용합니다 <br><br></p><h3 id="primary-key"><a href="#primary-key" class="headerlink" title="primary_key"></a>primary_key</h3><br><p><code>primary_key = True</code> 일때, 해당 필드는 모델의 primary key 가 됩니다. </p><br><p>모델안에 어떻나 필드도 primary_key = True 라고 명시하지 않은 경우에는, django가 자동적으로 IntegerField 를 추가하여, primary key 를 지니게 합니다. 딸사ㅓ, primary_key = True 라고 어떠한 필드에도 설정해줄 필요는 없습니다. 하지만, 기본 primary-key 동작을 오버라이드 하고 싶으면, 명시적으로 설정해 주면 됩니다.  <br><br></p><p>primary key 필드는 read-only 입니다.<br>만약, 이미 존재하는 객체의 primary key 값을 바꾸고 저장하면, 새로운 객체가 기존의 객체와 같이 생성이 됩니다. 예를들면, <br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 이름이 primary_key 값으로 되어있음</span></span><br></pre></td></tr></table></figure><p><br><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. name 이 '사과' 인 객체를 생성 </span></span><br><span class="line">fruit = Fruit.objects.create(name=<span class="string">'사과'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. name 을 '배' 로 바꾸어줌 </span></span><br><span class="line">fruit.name = <span class="string">'배'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 바뀐 name 을 데이터베이스에 저장 </span></span><br><span class="line">fruit.save() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 값 list 를 조회 </span></span><br><span class="line">Fruit.objects.values_list(<span class="string">'nam'</span>, flat=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">4</span>]: &lt;QuerySet [<span class="string">'사과'</span>, <span class="string">'배'</span>]&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: Fruit.objects.all()                               <span class="comment"># 모든 객체 조회                                                                                                                 </span></span><br><span class="line">Out[<span class="number">5</span>]: &lt;QuerySet [&lt;Fruit: 사과&gt;, &lt;Fruit: 배&gt;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># primary key 값인 name 을 바꾸고 저장했기 때문에, 새로운 객체인 '배' 가 생겨난것을 확인</span></span><br></pre></td></tr></table></figure><br><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><br><p>만일 True 일 경우, 해당 필드는 테이블 전체에서 고유한 값이여야 합니다. </p><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h2><br><p>공통된 필드 옵션에 대한 짧은 설명이었습니다. 더 많은 디테일들은, common model field option reference 문서에서 확인할수 있습니다. </p><br>]]></content:encoded>
      
      <comments>http://djangojeng-e.github.io/2020/08/02/Django-Models-4%ED%8E%B8-Fields-Field-Options/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
